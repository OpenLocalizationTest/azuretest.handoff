<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-cn" original="2/17/2016 2:52:58 PM" tool-id="MarkdownTransformer" product-name="N/A" product-version="N/A" build-num="1">
    <header>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">80e0b02215464bc0e596df3c92f644115439d979</xliffext:olfilehash>
      <tool tool-id="MarkdownTransformer" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
    </header>
    <body>
      <group extype="content">
        <group id="101">
          <trans-unit id="101" xml:space="preserve">
            <source>Caching guidance | Microsoft Azure</source>
            <target state="new">Caching guidance | Microsoft Azure</target>
          </trans-unit>
          <trans-unit id="102" xml:space="preserve">
            <source>Guidance on caching to improve performance and scalability.</source>
            <target state="new">Guidance on caching to improve performance and scalability.</target>
          </trans-unit>
          <trans-unit id="103" xml:space="preserve">
            <source>キャッシング ガイド</source>
            <target state="new">キャッシング ガイド</target>
          </trans-unit>
          <trans-unit id="104" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="105" xml:space="preserve">
            <source>キャッシュは、パフォーマンスを向上させることを目的とする一般的な手法、</source>
            <target state="new">キャッシュは、パフォーマンスを向上させることを目的とする一般的な手法、</target>
          </trans-unit>
          <trans-unit id="106" xml:space="preserve">
            <source>アクセスされるデータを一時的に頻繁にコピーすることによってシステムのスケーラビリティ</source>
            <target state="new">アクセスされるデータを一時的に頻繁にコピーすることによってシステムのスケーラビリティ</target>
          </trans-unit>
          <trans-unit id="107" xml:space="preserve">
            <source>高速なストレージ アプリケーションの近くに位置します。もしこの高速データ ストレージ</source>
            <target state="new">高速なストレージ アプリケーションの近くに位置します。もしこの高速データ ストレージ</target>
          </trans-unit>
          <trans-unit id="108" xml:space="preserve">
            <source>元のキャッシュよりアプリケーションに近い方には、します。</source>
            <target state="new">元のキャッシュよりアプリケーションに近い方には、します。</target>
          </trans-unit>
          <trans-unit id="109" xml:space="preserve">
            <source>提供することによってクライアント アプリケーションの応答時間を改善することができます。</source>
            <target state="new">提供することによってクライアント アプリケーションの応答時間を改善することができます。</target>
          </trans-unit>
          <trans-unit id="110" xml:space="preserve">
            <source>データより迅速に。キャッシュは、クライアントが繰り返しインスタンスする場合最も効果的です</source>
            <target state="new">データより迅速に。キャッシュは、クライアントが繰り返しインスタンスする場合最も効果的です</target>
          </trans-unit>
          <trans-unit id="111" xml:space="preserve">
            <source>データが比較的静的なまま場合は特に同じデータを読み取り、</source>
            <target state="new">データが比較的静的なまま場合は特に同じデータを読み取り、</target>
          </trans-unit>
          <trans-unit id="112" xml:space="preserve">
            <source>元のデータ ストア キャッシュの速度に比べて遅いが、</source>
            <target state="new">元のデータ ストア キャッシュの速度に比べて遅いが、</target>
          </trans-unit>
          <trans-unit id="113" xml:space="preserve">
            <source>や遠く離れたときネットワーク ・ レーテンシーは、高レベルの競合の対象</source>
            <target state="new">や遠く離れたときネットワーク ・ レーテンシーは、高レベルの競合の対象</target>
          </trans-unit>
          <trans-unit id="114" xml:space="preserve">
            <source>遅くなる可能性があります。</source>
            <target state="new">遅くなる可能性があります。</target>
          </trans-unit>
          <trans-unit id="115" xml:space="preserve">
            <source>分散アプリケーションでキャッシュ</source>
            <target state="new">分散アプリケーションでキャッシュ</target>
          </trans-unit>
          <trans-unit id="116" xml:space="preserve">
            <source>分散アプリケーションは、通常の一方または両方を実装、</source>
            <target state="new">分散アプリケーションは、通常の一方または両方を実装、</target>
          </trans-unit>
          <trans-unit id="117" xml:space="preserve">
            <source>次の戦略データをキャッシュする場合:</source>
            <target state="new">次の戦略データをキャッシュする場合:</target>
          </trans-unit>
          <trans-unit id="118" xml:space="preserve">
            <source>アプリケーションまたはサービスのインスタンスを実行しているコンピューター上でのデータのローカルの開催するプライベート キャッシュを使用してください。</source>
            <target state="new">アプリケーションまたはサービスのインスタンスを実行しているコンピューター上でのデータのローカルの開催するプライベート キャッシュを使用してください。</target>
          </trans-unit>
          <trans-unit id="119" xml:space="preserve">
            <source>複数のプロセスまたは複数のコンピューターでアクセスできる一般的なソースとして、共有キャッシュを使用します。</source>
            <target state="new">複数のプロセスまたは複数のコンピューターでアクセスできる一般的なソースとして、共有キャッシュを使用します。</target>
          </trans-unit>
          <trans-unit id="120" xml:space="preserve">
            <source>両方のケースでキャッシングすることができます (プロセスを提供することによって実行されるクライアント側</source>
            <target state="new">両方のケースでキャッシングすることができます (プロセスを提供することによって実行されるクライアント側</target>
          </trans-unit>
          <trans-unit id="121" xml:space="preserve">
            <source>web ブラウザーやデスクトップ アプリケーションなど、システムのユーザインターフェイス)</source>
            <target state="new">web ブラウザーやデスクトップ アプリケーションなど、システムのユーザインターフェイス)</target>
          </trans-unit>
          <trans-unit id="122" xml:space="preserve">
            <source>サーバー側 (ビジネス サービスの提供プロセスによっておよび/または</source>
            <target state="new">サーバー側 (ビジネス サービスの提供プロセスによっておよび/または</target>
          </trans-unit>
          <trans-unit id="123" xml:space="preserve">
            <source>リモートで実行する)。</source>
            <target state="new">リモートで実行する)。</target>
          </trans-unit>
          <trans-unit id="124" xml:space="preserve">
            <source>プライベート キャッシュ</source>
            <target state="new">プライベート キャッシュ</target>
          </trans-unit>
          <trans-unit id="125" xml:space="preserve">
            <source>キャッシュの最も基本的なタイプはアドレスで開催されたメモリ内ストアです。</source>
            <target state="new">キャッシュの最も基本的なタイプはアドレスで開催されたメモリ内ストアです。</target>
          </trans-unit>
          <trans-unit id="126" xml:space="preserve">
            <source>1 つのプロセスの空間、実行するコードで直接アクセス</source>
            <target state="new">1 つのプロセスの空間、実行するコードで直接アクセス</target>
          </trans-unit>
          <trans-unit id="127" xml:space="preserve">
            <source>そのプロセス。このタイプのキャッシュは非常に迅速にアクセスでき</source>
            <target state="new">そのプロセス。このタイプのキャッシュは非常に迅速にアクセスでき</target>
          </trans-unit>
          <trans-unit id="128" xml:space="preserve">
            <source>適度な量を格納するための非常に効果的な戦略を提供します。</source>
            <target state="new">適度な量を格納するための非常に効果的な戦略を提供します。</target>
          </trans-unit>
          <trans-unit id="129" xml:space="preserve">
            <source>静的なデータをキャッシュのサイズとして通常拘束されて、</source>
            <target state="new">静的なデータをキャッシュのサイズとして通常拘束されて、</target>
          </trans-unit>
          <trans-unit id="130" xml:space="preserve">
            <source>プロセスをホストするコンピューターで利用できるメモリの量。場合します。</source>
            <target state="new">プロセスをホストするコンピューターで利用できるメモリの量。場合します。</target>
          </trans-unit>
          <trans-unit id="131" xml:space="preserve">
            <source>メモリで物理的に可能であるより多くの情報をキャッシュする必要があります。</source>
            <target state="new">メモリで物理的に可能であるより多くの情報をキャッシュする必要があります。</target>
          </trans-unit>
          <trans-unit id="132" xml:space="preserve">
            <source>ローカル ファイル システムにキャッシュされているデータを記述できます。これは、します。</source>
            <target state="new">ローカル ファイル システムにキャッシュされているデータを記述できます。これは、します。</target>
          </trans-unit>
          <trans-unit id="133" xml:space="preserve">
            <source>必ずしもデータ メモリ内に保持する必要がありますよりアクセスが遅くなります。</source>
            <target state="new">必ずしもデータ メモリ内に保持する必要がありますよりアクセスが遅くなります。</target>
          </trans-unit>
          <trans-unit id="134" xml:space="preserve">
            <source>速くより信頼性の高いネットワーク経由でデータを取得するがあります。</source>
            <target state="new">速くより信頼性の高いネットワーク経由でデータを取得するがあります。</target>
          </trans-unit>
          <trans-unit id="135" xml:space="preserve">
            <source>このモデルを使用してアプリケーションの複数のインスタンスがある場合</source>
            <target state="new">このモデルを使用してアプリケーションの複数のインスタンスがある場合</target>
          </trans-unit>
          <trans-unit id="136" xml:space="preserve">
            <source>同時に実行して、各アプリケーション インスタンスがあります独自</source>
            <target state="new">同時に実行して、各アプリケーション インスタンスがあります独自</target>
          </trans-unit>
          <trans-unit id="137" xml:space="preserve">
            <source>独立したキャッシュ データの独自のコピーを保持します。</source>
            <target state="new">独立したキャッシュ データの独自のコピーを保持します。</target>
          </trans-unit>
          <trans-unit id="138" xml:space="preserve">
            <source>いくつかの元のデータのスナップショットとしてキャッシュの考える必要があります。</source>
            <target state="new">いくつかの元のデータのスナップショットとしてキャッシュの考える必要があります。</target>
          </trans-unit>
          <trans-unit id="139" xml:space="preserve">
            <source>過去にポイントします。そうだこのデータは静的ではない場合、</source>
            <target state="new">過去にポイントします。そうだこのデータは静的ではない場合、</target>
          </trans-unit>
          <trans-unit id="140" xml:space="preserve">
            <source>別のアプリケーションのインスタンスの異なるバージョンを保持する、</source>
            <target state="new">別のアプリケーションのインスタンスの異なるバージョンを保持する、</target>
          </trans-unit>
          <trans-unit id="141" xml:space="preserve">
            <source>それらのキャッシュ内のデータ。これらによって実行されるため、同じクエリ</source>
            <target state="new">それらのキャッシュ内のデータ。これらによって実行されるため、同じクエリ</target>
          </trans-unit>
          <trans-unit id="142" xml:space="preserve">
            <source>図 1 に示すように、インスタンスは、異なる結果を返すことができます。</source>
            <target state="new">図 1 に示すように、インスタンスは、異なる結果を返すことができます。</target>
          </trans-unit>
          <trans-unit id="143" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt>アプリケーションの別のインスタンスのメモリ内キャッシュを使用してください。<ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt>アプリケーションの別のインスタンスのメモリ内キャッシュを使用してください。<ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="144" xml:space="preserve">
            <source>_図 1: アプリケーションの別のインスタンスのメモリ内キャッシュを使用してください。_</source>
            <target state="new">_図 1: アプリケーションの別のインスタンスのメモリ内キャッシュを使用してください。_</target>
          </trans-unit>
          <trans-unit id="145" xml:space="preserve">
            <source>共有キャッシュ</source>
            <target state="new">共有キャッシュ</target>
          </trans-unit>
          <trans-unit id="146" xml:space="preserve">
            <source>共有キャッシュを使用して、データ可能性があります懸念を軽減するために助けることができます。</source>
            <target state="new">共有キャッシュを使用して、データ可能性があります懸念を軽減するために助けることができます。</target>
          </trans-unit>
          <trans-unit id="147" xml:space="preserve">
            <source>各キャッシュに異なるメモリ内キャッシュで発生することができます。共有</source>
            <target state="new">各キャッシュに異なるメモリ内キャッシュで発生することができます。共有</target>
          </trans-unit>
          <trans-unit id="148" xml:space="preserve">
            <source>キャッシュにより別のアプリケーション インスタンスが、同じを参照してください。</source>
            <target state="new">キャッシュにより別のアプリケーション インスタンスが、同じを参照してください。</target>
          </trans-unit>
          <trans-unit id="149" xml:space="preserve">
            <source>別の場所にキャッシュを配置することによってキャッシュされたデータのビュー</source>
            <target state="new">別の場所にキャッシュを配置することによってキャッシュされたデータのビュー</target>
          </trans-unit>
          <trans-unit id="150" xml:space="preserve">
            <source>図 2 に示すように、別のサービスの一部としてホスト通常。</source>
            <target state="new">図 2 に示すように、別のサービスの一部としてホスト通常。</target>
          </trans-unit>
          <trans-unit id="151" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt>共有キャッシュを使用_<ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt>共有キャッシュを使用_<ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="152" xml:space="preserve">
            <source>_図 2: 共有キャッシュを使用_</source>
            <target state="new">_図 2: 共有キャッシュを使用_</target>
          </trans-unit>
          <trans-unit id="153" xml:space="preserve">
            <source>共有キャッシュのアプローチを使用しての重要な利点は、</source>
            <target state="new">共有キャッシュのアプローチを使用しての重要な利点は、</target>
          </trans-unit>
          <trans-unit id="154" xml:space="preserve">
            <source>スケーラビリティを提供することができます。多くの共有キャッシュ サービスします。</source>
            <target state="new">スケーラビリティを提供することができます。多くの共有キャッシュ サービスします。</target>
          </trans-unit>
          <trans-unit id="155" xml:space="preserve">
            <source>サーバーのクラスターを使用してによって実装されており、ソフトウェアを利用します。</source>
            <target state="new">サーバーのクラスターを使用してによって実装されており、ソフトウェアを利用します。</target>
          </trans-unit>
          <trans-unit id="156" xml:space="preserve">
            <source>透過的な方法でクラスターにデータを分散します。、</source>
            <target state="new">透過的な方法でクラスターにデータを分散します。、</target>
          </trans-unit>
          <trans-unit id="157" xml:space="preserve">
            <source>アプリケーション インスタンスは、単にキャッシュ サービスに要求を送信します。</source>
            <target state="new">アプリケーション インスタンスは、単にキャッシュ サービスに要求を送信します。</target>
          </trans-unit>
          <trans-unit id="158" xml:space="preserve">
            <source>基盤となるインフラストラクチャが判断して、</source>
            <target state="new">基盤となるインフラストラクチャが判断して、</target>
          </trans-unit>
          <trans-unit id="159" xml:space="preserve">
            <source>クラスター内のキャッシュされたデータの場所です。容易に拡張できる、</source>
            <target state="new">クラスター内のキャッシュされたデータの場所です。容易に拡張できる、</target>
          </trans-unit>
          <trans-unit id="160" xml:space="preserve">
            <source>多くのサーバーを追加してキャッシュします。</source>
            <target state="new">多くのサーバーを追加してキャッシュします。</target>
          </trans-unit>
          <trans-unit id="161" xml:space="preserve">
            <source>共有キャッシュの不利な点に近づくキャッシュは、</source>
            <target state="new">共有キャッシュの不利な点に近づくキャッシュは、</target>
          </trans-unit>
          <trans-unit id="162" xml:space="preserve">
            <source>それもはやローカル各を開催ですので、アクセスに時間がかかります</source>
            <target state="new">それもはやローカル各を開催ですので、アクセスに時間がかかります</target>
          </trans-unit>
          <trans-unit id="163" xml:space="preserve">
            <source>アプリケーション インスタンス、および別を実装するための要件</source>
            <target state="new">アプリケーション インスタンス、および別を実装するための要件</target>
          </trans-unit>
          <trans-unit id="164" xml:space="preserve">
            <source>キャッシュ サービスは、複雑さをソリューションに追加できます。</source>
            <target state="new">キャッシュ サービスは、複雑さをソリューションに追加できます。</target>
          </trans-unit>
          <trans-unit id="165" xml:space="preserve">
            <source>キャッシュの使用に関する考慮事項</source>
            <target state="new">キャッシュの使用に関する考慮事項</target>
          </trans-unit>
          <trans-unit id="166" xml:space="preserve">
            <source>以下は考慮事項の詳細について説明します。</source>
            <target state="new">以下は考慮事項の詳細について説明します。</target>
          </trans-unit>
          <trans-unit id="167" xml:space="preserve">
            <source>設計およびキャッシュを使用しています。</source>
            <target state="new">設計およびキャッシュを使用しています。</target>
          </trans-unit>
          <trans-unit id="168" xml:space="preserve">
            <source>データがキャッシュされるとき</source>
            <target state="new">データがキャッシュされるとき</target>
          </trans-unit>
          <trans-unit id="169" xml:space="preserve">
            <source>キャッシュは、パフォーマンス、スケーラビリティ、および可用性を飛躍的に向上することができます。多くのデータ</source>
            <target state="new">キャッシュは、パフォーマンス、スケーラビリティ、および可用性を飛躍的に向上することができます。多くのデータ</target>
          </trans-unit>
          <trans-unit id="170" xml:space="preserve">
            <source>なとより大きい、このデータにアクセスする必要があるユーザー数が大きい</source>
            <target state="new">なとより大きい、このデータにアクセスする必要があるユーザー数が大きい</target>
          </trans-unit>
          <trans-unit id="171" xml:space="preserve">
            <source>なる遅延や処理に関連する競合を減らすことによってキャッシュの利点</source>
            <target state="new">なる遅延や処理に関連する競合を減らすことによってキャッシュの利点</target>
          </trans-unit>
          <trans-unit id="172" xml:space="preserve">
            <source>大量の元データの同時実行要求を格納します。たとえば、データベース</source>
            <target state="new">大量の元データの同時実行要求を格納します。たとえば、データベース</target>
          </trans-unit>
          <trans-unit id="173" xml:space="preserve">
            <source>同時接続が、共有から取得するデータの限られた数をサポート可能性があります。</source>
            <target state="new">同時接続が、共有から取得するデータの限られた数をサポート可能性があります。</target>
          </trans-unit>
          <trans-unit id="174" xml:space="preserve">
            <source>基になるデータベースではなくキャッシュ データにアクセスするクライアント アプリケーションをことができます。</source>
            <target state="new">基になるデータベースではなくキャッシュ データにアクセスするクライアント アプリケーションをことができます。</target>
          </trans-unit>
          <trans-unit id="175" xml:space="preserve">
            <source>場合でも、利用可能な接続数は現在使い果たされます。さらに、もし、</source>
            <target state="new">場合でも、利用可能な接続数は現在使い果たされます。さらに、もし、</target>
          </trans-unit>
          <trans-unit id="176" xml:space="preserve">
            <source>データベースが使用できなくなると、クライアント アプリケーションを使用して続行することができるかもしれない、</source>
            <target state="new">データベースが使用できなくなると、クライアント アプリケーションを使用して続行することができるかもしれない、</target>
          </trans-unit>
          <trans-unit id="177" xml:space="preserve">
            <source>データがキャッシュに保持されます。</source>
            <target state="new">データがキャッシュに保持されます。</target>
          </trans-unit>
          <trans-unit id="178" xml:space="preserve">
            <source>よく、それは頻繁に変更が読み取られるデータのキャッシュを検討してください。</source>
            <target state="new">よく、それは頻繁に変更が読み取られるデータのキャッシュを検討してください。</target>
          </trans-unit>
          <trans-unit id="179" xml:space="preserve">
            <source>(データ書き込み操作と読み取り操作の割合が高いを持っている)。ただし、</source>
            <target state="new">(データ書き込み操作と読み取り操作の割合が高いを持っている)。ただし、</target>
          </trans-unit>
          <trans-unit id="180" xml:space="preserve">
            <source>重要な情報の信頼できるストアとして、キャッシュを使用しないでください。必要があります。</source>
            <target state="new">重要な情報の信頼できるストアとして、キャッシュを使用しないでください。必要があります。</target>
          </trans-unit>
          <trans-unit id="181" xml:space="preserve">
            <source>あなたのアプリケーションを失うことができないすべての変更に常に保存されることを確認します。</source>
            <target state="new">あなたのアプリケーションを失うことができないすべての変更に常に保存されることを確認します。</target>
          </trans-unit>
          <trans-unit id="182" xml:space="preserve">
            <source>永続的なデータ ストア。これで、キャッシュが利用できない場合、アプリケーションことができます。</source>
            <target state="new">永続的なデータ ストア。これで、キャッシュが利用できない場合、アプリケーションことができます。</target>
          </trans-unit>
          <trans-unit id="183" xml:space="preserve">
            <source>データ ストアを使用して動作するように引き続き、重要な失われません</source>
            <target state="new">データ ストアを使用して動作するように引き続き、重要な失われません</target>
          </trans-unit>
          <trans-unit id="184" xml:space="preserve">
            <source>情報。</source>
            <target state="new">情報。</target>
          </trans-unit>
          <trans-unit id="185" xml:space="preserve">
            <source>データ ・ キャッシュの人口戦略の種類</source>
            <target state="new">データ ・ キャッシュの人口戦略の種類</target>
          </trans-unit>
          <trans-unit id="186" xml:space="preserve">
            <source>キャッシュを効果的に使用する鍵は最も適切なデータを決定します。</source>
            <target state="new">キャッシュを効果的に使用する鍵は最も適切なデータを決定します。</target>
          </trans-unit>
          <trans-unit id="187" xml:space="preserve">
            <source>キャッシュ、およびキャッシュを適切なタイミングで。キャッシュにデータを追加することがあります。</source>
            <target state="new">キャッシュ、およびキャッシュを適切なタイミングで。キャッシュにデータを追加することがあります。</target>
          </trans-unit>
          <trans-unit id="188" xml:space="preserve">
            <source>アプリケーションによって取得された最初の時間を要求するアプリケーションに必要なので、</source>
            <target state="new">アプリケーションによって取得された最初の時間を要求するアプリケーションに必要なので、</target>
          </trans-unit>
          <trans-unit id="189" xml:space="preserve">
            <source>データ ストアとそれ以降のアクセスが満たされる 1 回だけデータをフェッチします。</source>
            <target state="new">データ ストアとそれ以降のアクセスが満たされる 1 回だけデータをフェッチします。</target>
          </trans-unit>
          <trans-unit id="190" xml:space="preserve">
            <source>キャッシュを使用します。</source>
            <target state="new">キャッシュを使用します。</target>
          </trans-unit>
          <trans-unit id="191" xml:space="preserve">
            <source>また、キャッシュが部分的または完全にデータを設定する、事前に</source>
            <target state="new">また、キャッシュが部分的または完全にデータを設定する、事前に</target>
          </trans-unit>
          <trans-unit id="192" xml:space="preserve">
            <source>通常、アプリケーションの起動時 (シードと呼ばれるアプローチ)。しかし、それは可能性があります。</source>
            <target state="new">通常、アプリケーションの起動時 (シードと呼ばれるアプローチ)。しかし、それは可能性があります。</target>
          </trans-unit>
          <trans-unit id="193" xml:space="preserve">
            <source>このアプローチが課すことができる、大容量のキャッシュのシードを実装することをお勧めではないです。</source>
            <target state="new">このアプローチが課すことができる、大容量のキャッシュのシードを実装することをお勧めではないです。</target>
          </trans-unit>
          <trans-unit id="194" xml:space="preserve">
            <source>元のデータ ストア、アプリケーションの実行開始時に突然、高負荷。</source>
            <target state="new">元のデータ ストア、アプリケーションの実行開始時に突然、高負荷。</target>
          </trans-unit>
          <trans-unit id="195" xml:space="preserve">
            <source>使用パターンの分析が決定する助けることができる多くの場合するかどうか完全にまたは部分的に</source>
            <target state="new">使用パターンの分析が決定する助けることができる多くの場合するかどうか完全にまたは部分的に</target>
          </trans-unit>
          <trans-unit id="196" xml:space="preserve">
            <source>あらかじめしておくキャッシュとキャッシュすべきデータを選択します。たとえば、</source>
            <target state="new">あらかじめしておくキャッシュとキャッシュすべきデータを選択します。たとえば、</target>
          </trans-unit>
          <trans-unit id="197" xml:space="preserve">
            <source>静的なユーザー プロファイル データとキャッシュをシードする有用でしょう</source>
            <target state="new">静的なユーザー プロファイル データとキャッシュをシードする有用でしょう</target>
          </trans-unit>
          <trans-unit id="198" xml:space="preserve">
            <source>(多分毎日)、定期的にアプリケーションをご利用のお客様が、</source>
            <target state="new">(多分毎日)、定期的にアプリケーションをご利用のお客様が、</target>
          </trans-unit>
          <trans-unit id="199" xml:space="preserve">
            <source>週に 1 回だけアプリケーションをご使用のお客様。</source>
            <target state="new">週に 1 回だけアプリケーションをご使用のお客様。</target>
          </trans-unit>
          <trans-unit id="200" xml:space="preserve">
            <source>データには変更または変更されるとうまく動作通常キャッシュ</source>
            <target state="new">データには変更または変更されるとうまく動作通常キャッシュ</target>
          </trans-unit>
          <trans-unit id="201" xml:space="preserve">
            <source>頻度が低い。リファレンス情報については、製品と価格設定などがあります。</source>
            <target state="new">頻度が低い。リファレンス情報については、製品と価格設定などがあります。</target>
          </trans-unit>
          <trans-unit id="202" xml:space="preserve">
            <source>e コマース アプリケーション、または高価な共有の静的リソースの情報</source>
            <target state="new">e コマース アプリケーション、または高価な共有の静的リソースの情報</target>
          </trans-unit>
          <trans-unit id="203" xml:space="preserve">
            <source>構築します。このデータの一部またはすべてのアプリケーションをキャッシュに読み込むことができます。</source>
            <target state="new">構築します。このデータの一部またはすべてのアプリケーションをキャッシュに読み込むことができます。</target>
          </trans-unit>
          <trans-unit id="204" xml:space="preserve">
            <source>起動時のリソースに対する要求を最小限に抑えるため、パフォーマンスを向上させる。あります。</source>
            <target state="new">起動時のリソースに対する要求を最小限に抑えるため、パフォーマンスを向上させる。あります。</target>
          </trans-unit>
          <trans-unit id="205" xml:space="preserve">
            <source>参照データを定期的に更新するバック グラウンド プロセスを持つことが適当</source>
            <target state="new">参照データを定期的に更新するバック グラウンド プロセスを持つことが適当</target>
          </trans-unit>
          <trans-unit id="206" xml:space="preserve">
            <source>それは日付、またはキャッシュを更新するようにキャッシュを参照する場合</source>
            <target state="new">それは日付、またはキャッシュを更新するようにキャッシュを参照する場合</target>
          </trans-unit>
          <trans-unit id="207" xml:space="preserve">
            <source>データの変更。</source>
            <target state="new">データの変更。</target>
          </trans-unit>
          <trans-unit id="208" xml:space="preserve">
            <source>キャッシュは動的データのためあまり有用ことがありますいくつかの例外がありますが</source>
            <target state="new">キャッシュは動的データのためあまり有用ことがありますいくつかの例外がありますが</target>
          </trans-unit>
          <trans-unit id="209" xml:space="preserve">
            <source>この考察 (後述の非常に動的なデータのキャッシュ」を参照してください。</source>
            <target state="new">この考察 (後述の非常に動的なデータのキャッシュ」を参照してください。</target>
          </trans-unit>
          <trans-unit id="210" xml:space="preserve">
            <source>詳細についてはガイダンス)。時元のデータを定期的に変更、どちらか</source>
            <target state="new">詳細についてはガイダンス)。時元のデータを定期的に変更、どちらか</target>
          </trans-unit>
          <trans-unit id="211" xml:space="preserve">
            <source>キャッシュされた情報はすぐに古くなることができるまたは維持のオーバーヘッド</source>
            <target state="new">キャッシュされた情報はすぐに古くなることができるまたは維持のオーバーヘッド</target>
          </trans-unit>
          <trans-unit id="212" xml:space="preserve">
            <source>元のデータ ストアと同期してキャッシュの有効性が低下します。</source>
            <target state="new">元のデータ ストアと同期してキャッシュの有効性が低下します。</target>
          </trans-unit>
          <trans-unit id="213" xml:space="preserve">
            <source>キャッシュ。キャッシュがへの完全なデータが含まれていないことに注意してください、</source>
            <target state="new">キャッシュ。キャッシュがへの完全なデータが含まれていないことに注意してください、</target>
          </trans-unit>
          <trans-unit id="214" xml:space="preserve">
            <source>エンティティ。たとえば、データ項目は、銀行などの複数値を持つオブジェクトを表します</source>
            <target state="new">エンティティ。たとえば、データ項目は、銀行などの複数値を持つオブジェクトを表します</target>
          </trans-unit>
          <trans-unit id="215" xml:space="preserve">
            <source>名前、アドレス、およびアカウントの残高を持つ顧客、これらの要素のいくつかの可能性があります。</source>
            <target state="new">名前、アドレス、およびアカウントの残高を持つ顧客、これらの要素のいくつかの可能性があります。</target>
          </trans-unit>
          <trans-unit id="216" xml:space="preserve">
            <source>まま静的 (名前とアドレス)、他 (口座残高) など</source>
            <target state="new">まま静的 (名前とアドレス)、他 (口座残高) など</target>
          </trans-unit>
          <trans-unit id="217" xml:space="preserve">
            <source>ダイナミックながあります。これらの状況では、静的をキャッシュすると便利かもしれません</source>
            <target state="new">ダイナミックながあります。これらの状況では、静的をキャッシュすると便利かもしれません</target>
          </trans-unit>
          <trans-unit id="218" xml:space="preserve">
            <source>データの一部のみを取得 (または計算) として残りの情報と</source>
            <target state="new">データの一部のみを取得 (または計算) として残りの情報と</target>
          </trans-unit>
          <trans-unit id="219" xml:space="preserve">
            <source>それが必要な場合。</source>
            <target state="new">それが必要な場合。</target>
          </trans-unit>
          <trans-unit id="220" xml:space="preserve">
            <source>決定するためのパフォーマンス テストと利用状況分析が行われるべきかどうか</source>
            <target state="new">決定するためのパフォーマンス テストと利用状況分析が行われるべきかどうか</target>
          </trans-unit>
          <trans-unit id="221" xml:space="preserve">
            <source>キャッシュ、またはその両方の組み合わせの前の人口やオンデマンドの読み込みが</source>
            <target state="new">キャッシュ、またはその両方の組み合わせの前の人口やオンデマンドの読み込みが</target>
          </trans-unit>
          <trans-unit id="222" xml:space="preserve">
            <source>適切です。ボラティリティの組み合わせに基づいて決定をする必要がありますが、</source>
            <target state="new">適切です。ボラティリティの組み合わせに基づいて決定をする必要がありますが、</target>
          </trans-unit>
          <trans-unit id="223" xml:space="preserve">
            <source>データの使用パターン。キャッシュの使用率とパフォーマンスの分析は</source>
            <target state="new">データの使用パターン。キャッシュの使用率とパフォーマンスの分析は</target>
          </trans-unit>
          <trans-unit id="224" xml:space="preserve">
            <source>重い負荷が発生しする必要がありますアプリケーションでは特に重要</source>
            <target state="new">重い負荷が発生しする必要がありますアプリケーションでは特に重要</target>
          </trans-unit>
          <trans-unit id="225" xml:space="preserve">
            <source>拡張性の高い。たとえば、拡張性の高いシナリオでそれに意味をなさない可能性があります。</source>
            <target state="new">拡張性の高い。たとえば、拡張性の高いシナリオでそれに意味をなさない可能性があります。</target>
          </trans-unit>
          <trans-unit id="226" xml:space="preserve">
            <source>ピーク時にデータ ストアの負荷を減らすためにキャッシュをシードします。</source>
            <target state="new">ピーク時にデータ ストアの負荷を減らすためにキャッシュをシードします。</target>
          </trans-unit>
          <trans-unit id="227" xml:space="preserve">
            <source>キャッシュも、アプリケーションが計算を繰り返しを避けるために使用できます。</source>
            <target state="new">キャッシュも、アプリケーションが計算を繰り返しを避けるために使用できます。</target>
          </trans-unit>
          <trans-unit id="228" xml:space="preserve">
            <source>実行しています。操作データを変換または複雑な計算を実行する場合</source>
            <target state="new">実行しています。操作データを変換または複雑な計算を実行する場合</target>
          </trans-unit>
          <trans-unit id="229" xml:space="preserve">
            <source>それは、キャッシュの操作の結果を保存できます。もし同じ計算</source>
            <target state="new">それは、キャッシュの操作の結果を保存できます。もし同じ計算</target>
          </trans-unit>
          <trans-unit id="230" xml:space="preserve">
            <source>アプリケーションことができますから結果を取得して単にその後、必要です。</source>
            <target state="new">アプリケーションことができますから結果を取得して単にその後、必要です。</target>
          </trans-unit>
          <trans-unit id="231" xml:space="preserve">
            <source>キャッシュ。</source>
            <target state="new">キャッシュ。</target>
          </trans-unit>
          <trans-unit id="232" xml:space="preserve">
            <source>アプリケーションは、キャッシュに保持されているデータを変更できますが、考慮する必要があります、</source>
            <target state="new">アプリケーションは、キャッシュに保持されているデータを変更できますが、考慮する必要があります、</target>
          </trans-unit>
          <trans-unit id="233" xml:space="preserve">
            <source>いつでも消えることができる一時的なデータ ストアとしてキャッシュします。保存しません。</source>
            <target state="new">いつでも消えることができる一時的なデータ ストアとしてキャッシュします。保存しません。</target>
          </trans-unit>
          <trans-unit id="234" xml:space="preserve">
            <source>貴重なデータ、キャッシュでのみが、情報を維持することを確認します。</source>
            <target state="new">貴重なデータ、キャッシュでのみが、情報を維持することを確認します。</target>
          </trans-unit>
          <trans-unit id="235" xml:space="preserve">
            <source>オリジナルのデータ ストアにも。これで、キャッシュする必要がありますになる場合</source>
            <target state="new">オリジナルのデータ ストアにも。これで、キャッシュする必要がありますになる場合</target>
          </trans-unit>
          <trans-unit id="236" xml:space="preserve">
            <source>利用できない場合、あなたはデータを失う可能性を最小限に抑えます。</source>
            <target state="new">利用できない場合、あなたはデータを失う可能性を最小限に抑えます。</target>
          </trans-unit>
          <trans-unit id="237" xml:space="preserve">
            <source>非常に動的なデータのキャッシュ</source>
            <target state="new">非常に動的なデータのキャッシュ</target>
          </trans-unit>
          <trans-unit id="238" xml:space="preserve">
            <source>永続的なデータ ストアで急速に変更を課すことができる情報を格納します。</source>
            <target state="new">永続的なデータ ストアで急速に変更を課すことができる情報を格納します。</target>
          </trans-unit>
          <trans-unit id="239" xml:space="preserve">
            <source>システムのオーバーヘッドです。たとえば、常にレポートされるデバイス</source>
            <target state="new">システムのオーバーヘッドです。たとえば、常にレポートされるデバイス</target>
          </trans-unit>
          <trans-unit id="240" xml:space="preserve">
            <source>ステータスまたはいくつかの他の測定。これをキャッシュにしないアプリケーションを選択した場合</source>
            <target state="new">ステータスまたはいくつかの他の測定。これをキャッシュにしないアプリケーションを選択した場合</target>
          </trans-unit>
          <trans-unit id="241" xml:space="preserve">
            <source>データに基づいて、キャッシュされた情報がほぼ常に時代遅れになる、</source>
            <target state="new">データに基づいて、キャッシュされた情報がほぼ常に時代遅れになる、</target>
          </trans-unit>
          <trans-unit id="242" xml:space="preserve">
            <source>同じ意識を保存して、この情報を取得する場合は true かもしれない</source>
            <target state="new">同じ意識を保存して、この情報を取得する場合は true かもしれない</target>
          </trans-unit>
          <trans-unit id="243" xml:space="preserve">
            <source>データ ストアから保存し、このデータを取得するのにかかる時間にそれがあります。</source>
            <target state="new">データ ストアから保存し、このデータを取得するのにかかる時間にそれがあります。</target>
          </trans-unit>
          <trans-unit id="244" xml:space="preserve">
            <source>変更。このような動的に格納する利点を考慮します。</source>
            <target state="new">変更。このような動的に格納する利点を考慮します。</target>
          </trans-unit>
          <trans-unit id="245" xml:space="preserve">
            <source>永続的なデータ ストアではなくキャッシュに直接情報です。場合は、</source>
            <target state="new">永続的なデータ ストアではなくキャッシュに直接情報です。場合は、</target>
          </trans-unit>
          <trans-unit id="246" xml:space="preserve">
            <source>データが重要ではない、監査することを必要としないし、それは問題ではないです。</source>
            <target state="new">データが重要ではない、監査することを必要としないし、それは問題ではないです。</target>
          </trans-unit>
          <trans-unit id="247" xml:space="preserve">
            <source>場合は、時折変更失われます。</source>
            <target state="new">場合は、時折変更失われます。</target>
          </trans-unit>
          <trans-unit id="248" xml:space="preserve">
            <source>キャッシュ データの有効期限を管理します。</source>
            <target state="new">キャッシュ データの有効期限を管理します。</target>
          </trans-unit>
          <trans-unit id="249" xml:space="preserve">
            <source>ほとんどの場合、キャッシュに保持されているデータは元のデータのデータのコピー</source>
            <target state="new">ほとんどの場合、キャッシュに保持されているデータは元のデータのデータのコピー</target>
          </trans-unit>
          <trans-unit id="250" xml:space="preserve">
            <source>格納します。引き起こして、それがキャッシュされた後に元のデータ ストア内のデータを変更可能性があります。</source>
            <target state="new">格納します。引き起こして、それがキャッシュされた後に元のデータ ストア内のデータを変更可能性があります。</target>
          </trans-unit>
          <trans-unit id="251" xml:space="preserve">
            <source>キャッシュされたデータが古くなるを。多くのキャッシング システムを構成することを有効にする、</source>
            <target state="new">キャッシュされたデータが古くなるを。多くのキャッシング システムを構成することを有効にする、</target>
          </trans-unit>
          <trans-unit id="252" xml:space="preserve">
            <source>キャッシュ データを有効期限が切れるし、データが期限切れである期間を短縮します。</source>
            <target state="new">キャッシュ データを有効期限が切れるし、データが期限切れである期間を短縮します。</target>
          </trans-unit>
          <trans-unit id="253" xml:space="preserve">
            <source>キャッシュされたデータの有効期限が切れるキャッシュから削除され、アプリケーションにする必要があります。</source>
            <target state="new">キャッシュされたデータの有効期限が切れるキャッシュから削除され、アプリケーションにする必要があります。</target>
          </trans-unit>
          <trans-unit id="254" xml:space="preserve">
            <source>(置くことが新しくフェッチ元のデータ ストアからデータを取得します。</source>
            <target state="new">(置くことが新しくフェッチ元のデータ ストアからデータを取得します。</target>
          </trans-unit>
          <trans-unit id="255" xml:space="preserve">
            <source>情報キャッシュに戻す)。既定の有効期限ポリシーを設定することができますとあなた</source>
            <target state="new">情報キャッシュに戻す)。既定の有効期限ポリシーを設定することができますとあなた</target>
          </trans-unit>
          <trans-unit id="256" xml:space="preserve">
            <source>キャッシュを構成します。多くのキャッシュ サービスで、有効期限を決めることも</source>
            <target state="new">キャッシュを構成します。多くのキャッシュ サービスで、有効期限を決めることも</target>
          </trans-unit>
          <trans-unit id="257" xml:space="preserve">
            <source>プログラムによってキャッシュにそれらを格納する個々 のオブジェクトの期間</source>
            <target state="new">プログラムによってキャッシュにそれらを格納する個々 のオブジェクトの期間</target>
          </trans-unit>
          <trans-unit id="258" xml:space="preserve">
            <source>(いくつかのキャッシュを有効にすると、絶対値として有効期限を指定すること、または</source>
            <target state="new">(いくつかのキャッシュを有効にすると、絶対値として有効期限を指定すること、または</target>
          </trans-unit>
          <trans-unit id="259" xml:space="preserve">
            <source>スライド値として原因じゃない場合、キャッシュから削除するアイテム</source>
            <target state="new">スライド値として原因じゃない場合、キャッシュから削除するアイテム</target>
          </trans-unit>
          <trans-unit id="260" xml:space="preserve">
            <source>指定した時間内にアクセス。この設定は、任意のキャッシュ全体</source>
            <target state="new">指定した時間内にアクセス。この設定は、任意のキャッシュ全体</target>
          </trans-unit>
          <trans-unit id="261" xml:space="preserve">
            <source>指定したオブジェクトに対してだけ有効期限ポリシー。</source>
            <target state="new">指定したオブジェクトに対してだけ有効期限ポリシー。</target>
          </trans-unit>
          <trans-unit id="262" xml:space="preserve">
            <source>[AZURE。メモ] キャッシュと慎重に含まれているオブジェクトの有効期間を検討します。短すぎるとして、オブジェクトが余りにすぐに切れるし、キャッシュを使用する利点が減少します。あまりにも長い期間を加えると、データが古くなって危険があります。</source>
            <target state="new">[AZURE。メモ] キャッシュと慎重に含まれているオブジェクトの有効期間を検討します。短すぎるとして、オブジェクトが余りにすぐに切れるし、キャッシュを使用する利点が減少します。あまりにも長い期間を加えると、データが古くなって危険があります。</target>
          </trans-unit>
          <trans-unit id="263" xml:space="preserve">
            <source>可能維持するデータが許可されている場合は、キャッシュがいっぱいです。</source>
            <target state="new">可能維持するデータが許可されている場合は、キャッシュがいっぱいです。</target>
          </trans-unit>
          <trans-unit id="264" xml:space="preserve">
            <source>長い時間の居住者。この場合、いずれかをする新しい項目を追加する要求、</source>
            <target state="new">長い時間の居住者。この場合、いずれかをする新しい項目を追加する要求、</target>
          </trans-unit>
          <trans-unit id="265" xml:space="preserve">
            <source>キャッシュと呼ばれるプロセスで、強制的に削除されるいくつかの項目があります。</source>
            <target state="new">キャッシュと呼ばれるプロセスで、強制的に削除されるいくつかの項目があります。</target>
          </trans-unit>
          <trans-unit id="266" xml:space="preserve">
            <source>立ち退き。キャッシュ サービスは、通常最も最近使用 (LRU) 上のデータを削除します。</source>
            <target state="new">立ち退き。キャッシュ サービスは、通常最も最近使用 (LRU) 上のデータを削除します。</target>
          </trans-unit>
          <trans-unit id="267" xml:space="preserve">
            <source>基礎が通常このポリシーをオーバーライドして、できます項目を防ぐ</source>
            <target state="new">基礎が通常このポリシーをオーバーライドして、できます項目を防ぐ</target>
          </trans-unit>
          <trans-unit id="268" xml:space="preserve">
            <source>削除。しかし、このアプローチを採用する場合、あなたはキャッシュを超える危険性、</source>
            <target state="new">削除。しかし、このアプローチを採用する場合、あなたはキャッシュを超える危険性、</target>
          </trans-unit>
          <trans-unit id="269" xml:space="preserve">
            <source>メモリには項目を追加しようと、使用可能なアプリケーションがあります。</source>
            <target state="new">メモリには項目を追加しようと、使用可能なアプリケーションがあります。</target>
          </trans-unit>
          <trans-unit id="270" xml:space="preserve">
            <source>キャッシュには、例外で失敗します。</source>
            <target state="new">キャッシュには、例外で失敗します。</target>
          </trans-unit>
          <trans-unit id="271" xml:space="preserve">
            <source>一部のキャッシュの実装は、追加削除ポリシーにあります。これら</source>
            <target state="new">一部のキャッシュの実装は、追加削除ポリシーにあります。これら</target>
          </trans-unit>
          <trans-unit id="272" xml:space="preserve">
            <source>通常最も最近使用されたポリシーを含める (期待する、</source>
            <target state="new">通常最も最近使用されたポリシーを含める (期待する、</target>
          </trans-unit>
          <trans-unit id="273" xml:space="preserve">
            <source>データ必要はありませんもう一度)、(最も古いデータは、先入れ先出しのポリシー</source>
            <target state="new">データ必要はありませんもう一度)、(最も古いデータは、先入れ先出しのポリシー</target>
          </trans-unit>
          <trans-unit id="274" xml:space="preserve">
            <source>削除最初)、またはトリガーされたイベントに基づいて明示的な削除 (など、</source>
            <target state="new">削除最初)、またはトリガーされたイベントに基づいて明示的な削除 (など、</target>
          </trans-unit>
          <trans-unit id="275" xml:space="preserve">
            <source>変更されるデータ)。</source>
            <target state="new">変更されるデータ)。</target>
          </trans-unit>
          <trans-unit id="276" xml:space="preserve">
            <source>クライアント側キャッシュ内のデータを無効化</source>
            <target state="new">クライアント側キャッシュ内のデータを無効化</target>
          </trans-unit>
          <trans-unit id="277" xml:space="preserve">
            <source>クライアント側のキャッシュに保持されたデータはおおむねの外</source>
            <target state="new">クライアント側のキャッシュに保持されたデータはおおむねの外</target>
          </trans-unit>
          <trans-unit id="278" xml:space="preserve">
            <source>クライアントにデータを提供するサービスの後援サービス</source>
            <target state="new">クライアントにデータを提供するサービスの後援サービス</target>
          </trans-unit>
          <trans-unit id="279" xml:space="preserve">
            <source>情報を追加、削除するクライアントを強制的ことはできません直接、</source>
            <target state="new">情報を追加、削除するクライアントを強制的ことはできません直接、</target>
          </trans-unit>
          <trans-unit id="280" xml:space="preserve">
            <source>クライアント側のキャッシュ。つまり、それはクライアントを使用することが可能</source>
            <target state="new">クライアント側のキャッシュ。つまり、それはクライアントを使用することが可能</target>
          </trans-unit>
          <trans-unit id="281" xml:space="preserve">
            <source>構成が不十分なキャッシュ (たとえば、有効期限ポリシーがないです。</source>
            <target state="new">構成が不十分なキャッシュ (たとえば、有効期限ポリシーがないです。</target>
          </trans-unit>
          <trans-unit id="282" xml:space="preserve">
            <source>キャッシュされた古い情報を使用し続けるに適切に実装)</source>
            <target state="new">キャッシュされた古い情報を使用し続けるに適切に実装)</target>
          </trans-unit>
          <trans-unit id="283" xml:space="preserve">
            <source>ローカル元のデータ ソース内の情報が変更されたとします。</source>
            <target state="new">ローカル元のデータ ソース内の情報が変更されたとします。</target>
          </trans-unit>
          <trans-unit id="284" xml:space="preserve">
            <source>HTTP を介してデータを提供する web アプリケーションを構築する場合</source>
            <target state="new">HTTP を介してデータを提供する web アプリケーションを構築する場合</target>
          </trans-unit>
          <trans-unit id="285" xml:space="preserve">
            <source>接続、暗黙的に web クライアントを強制的ことができます (ブラウザーなどや</source>
            <target state="new">接続、暗黙的に web クライアントを強制的ことができます (ブラウザーなどや</target>
          </trans-unit>
          <trans-unit id="286" xml:space="preserve">
            <source>web プロキシ) リソースが更新された場合、最新の情報を取得するには</source>
            <target state="new">web プロキシ) リソースが更新された場合、最新の情報を取得するには</target>
          </trans-unit>
          <trans-unit id="287" xml:space="preserve">
            <source>そのリソースの URI を変更します。Web クライアントは、通常、URI を使用してください。</source>
            <target state="new">そのリソースの URI を変更します。Web クライアントは、通常、URI を使用してください。</target>
          </trans-unit>
          <trans-unit id="288" xml:space="preserve">
            <source>クライアント側のキャッシュのキーとしてリソースの URI を変更するので</source>
            <target state="new">クライアント側のキャッシュのキーとしてリソースの URI を変更するので</target>
          </trans-unit>
          <trans-unit id="289" xml:space="preserve">
            <source>により、web クライアントのすべてのキャッシュ済みバージョンを無視する、</source>
            <target state="new">により、web クライアントのすべてのキャッシュ済みバージョンを無視する、</target>
          </trans-unit>
          <trans-unit id="290" xml:space="preserve">
            <source>リソース、代わりに新しいバージョンを取得します。</source>
            <target state="new">リソース、代わりに新しいバージョンを取得します。</target>
          </trans-unit>
          <trans-unit id="291" xml:space="preserve">
            <source>キャッシュ内の同時実行の管理</source>
            <target state="new">キャッシュ内の同時実行の管理</target>
          </trans-unit>
          <trans-unit id="292" xml:space="preserve">
            <source>キャッシュは、頻繁の複数のインスタンスで共有するために設計されている、</source>
            <target state="new">キャッシュは、頻繁の複数のインスタンスで共有するために設計されている、</target>
          </trans-unit>
          <trans-unit id="293" xml:space="preserve">
            <source>アプリケーション。各アプリケーション インスタンスが読み書きのデータの変更</source>
            <target state="new">アプリケーション。各アプリケーション インスタンスが読み書きのデータの変更</target>
          </trans-unit>
          <trans-unit id="294" xml:space="preserve">
            <source>キャッシュ。その結果、同じ同時実行の問題が発生します。</source>
            <target state="new">キャッシュ。その結果、同じ同時実行の問題が発生します。</target>
          </trans-unit>
          <trans-unit id="295" xml:space="preserve">
            <source>任意の共有データ ストアのキャッシュにも当てはまります。状況で</source>
            <target state="new">任意の共有データ ストアのキャッシュにも当てはまります。状況で</target>
          </trans-unit>
          <trans-unit id="296" xml:space="preserve">
            <source>アプリケーションがキャッシュに保持されているデータを変更する必要がある場合があります。</source>
            <target state="new">アプリケーションがキャッシュに保持されているデータを変更する必要がある場合があります。</target>
          </trans-unit>
          <trans-unit id="297" xml:space="preserve">
            <source>アプリケーションの 1 つのインスタンスで更新が行われるようにする必要があります。</source>
            <target state="new">アプリケーションの 1 つのインスタンスで更新が行われるようにする必要があります。</target>
          </trans-unit>
          <trans-unit id="298" xml:space="preserve">
            <source>盲目的に別のインスタンスで行った変更を上書きしません。</source>
            <target state="new">盲目的に別のインスタンスで行った変更を上書きしません。</target>
          </trans-unit>
          <trans-unit id="299" xml:space="preserve">
            <source>データの性質との衝突の可能性に応じてください。</source>
            <target state="new">データの性質との衝突の可能性に応じてください。</target>
          </trans-unit>
          <trans-unit id="300" xml:space="preserve">
            <source>同時実行する 2 つの方法のいずれかを採用することができます。</source>
            <target state="new">同時実行する 2 つの方法のいずれかを採用することができます。</target>
          </trans-unit>
          <trans-unit id="301" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>楽観的。<ept id="1">&lt;/strong&gt;</ept> アプリケーションは、キャッシュ内のデータはすぐにそれを更新する前に、それが取得されてから変わったかどうかを確認します。データが同じでも変更は可能です。それ以外の場合、アプリケーションが (この決定を行うビジネス ロジックは特定のアプリケーションになります) それを更新するかどうかを決定します。この方法は、更新が頻繁に、または衝突が発生する可能性が状況に適しています。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>楽観的。<ept id="1">&lt;/strong&gt;</ept> アプリケーションは、キャッシュ内のデータはすぐにそれを更新する前に、それが取得されてから変わったかどうかを確認します。データが同じでも変更は可能です。それ以外の場合、アプリケーションが (この決定を行うビジネス ロジックは特定のアプリケーションになります) それを更新するかどうかを決定します。この方法は、更新が頻繁に、または衝突が発生する可能性が状況に適しています。</target>
          </trans-unit>
          <trans-unit id="302" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>悲観的。<ept id="1">&lt;/strong&gt;</ept> アプリケーションは、別のインスタンスがデータを変更するを防ぐためにそれを取得するときに、キャッシュ内のデータをロックします。このプロセスにより、衝突は発生することはできませんが、同じデータを処理する必要があります他のインスタンスをブロック可能性があります。ペシミスティック同時実行制御ソリューションのスケーラビリティに影響を与えることができるし、短時間の操作にのみ使用する必要があります。このアプローチは、アプリケーション キャッシュ内の複数の項目を更新し、これらの変更が一貫して適用されていることを確認する必要がある場合は特に、衝突が本当らしい、状況に適した可能性があります。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>悲観的。<ept id="1">&lt;/strong&gt;</ept> アプリケーションは、別のインスタンスがデータを変更するを防ぐためにそれを取得するときに、キャッシュ内のデータをロックします。このプロセスにより、衝突は発生することはできませんが、同じデータを処理する必要があります他のインスタンスをブロック可能性があります。ペシミスティック同時実行制御ソリューションのスケーラビリティに影響を与えることができるし、短時間の操作にのみ使用する必要があります。このアプローチは、アプリケーション キャッシュ内の複数の項目を更新し、これらの変更が一貫して適用されていることを確認する必要がある場合は特に、衝突が本当らしい、状況に適した可能性があります。</target>
          </trans-unit>
          <trans-unit id="303" xml:space="preserve">
            <source>高い可用性とスケーラビリティを実装してパフォーマンスを向上させる</source>
            <target state="new">高い可用性とスケーラビリティを実装してパフォーマンスを向上させる</target>
          </trans-unit>
          <trans-unit id="304" xml:space="preserve">
            <source>キャッシュは、データのプライマリ ・ リポジトリをしないでください。これはロールです。</source>
            <target state="new">キャッシュは、データのプライマリ ・ リポジトリをしないでください。これはロールです。</target>
          </trans-unit>
          <trans-unit id="305" xml:space="preserve">
            <source>キャッシュの設定を元のデータ ストア。、</source>
            <target state="new">キャッシュの設定を元のデータ ストア。、</target>
          </trans-unit>
          <trans-unit id="306" xml:space="preserve">
            <source>元のデータ ストアの永続性を確保するための責任は、</source>
            <target state="new">元のデータ ストアの永続性を確保するための責任は、</target>
          </trans-unit>
          <trans-unit id="307" xml:space="preserve">
            <source>データ。</source>
            <target state="new">データ。</target>
          </trans-unit>
          <trans-unit id="308" xml:space="preserve">
            <source>可用性の重要な依存関係を導入することに注意してください。</source>
            <target state="new">可用性の重要な依存関係を導入することに注意してください。</target>
          </trans-unit>
          <trans-unit id="309" xml:space="preserve">
            <source>ソリューションに共有キャッシュ サービス。アプリケーションする必要があります。</source>
            <target state="new">ソリューションに共有キャッシュ サービス。アプリケーションする必要があります。</target>
          </trans-unit>
          <trans-unit id="310" xml:space="preserve">
            <source>場合は、機能を継続することができる共有のキャッシュを提供するサービス</source>
            <target state="new">場合は、機能を継続することができる共有のキャッシュを提供するサービス</target>
          </trans-unit>
          <trans-unit id="311" xml:space="preserve">
            <source>無効です。アプリケーションがハングするか待っている間失敗しません。</source>
            <target state="new">無効です。アプリケーションがハングするか待っている間失敗しません。</target>
          </trans-unit>
          <trans-unit id="312" xml:space="preserve">
            <source>キャッシュ サービスの再開します。したがって、アプリケーション必要があります。</source>
            <target state="new">キャッシュ サービスの再開します。したがって、アプリケーション必要があります。</target>
          </trans-unit>
          <trans-unit id="313" xml:space="preserve">
            <source>キャッシュ サービスの可用性を検出し、フォールバックする準備</source>
            <target state="new">キャッシュ サービスの可用性を検出し、フォールバックする準備</target>
          </trans-unit>
          <trans-unit id="314" xml:space="preserve">
            <source>元のデータの保存、キャッシュにアクセスできない場合。、</source>
            <target state="new">元のデータの保存、キャッシュにアクセスできない場合。、</target>
          </trans-unit>
          <trans-unit id="315" xml:space="preserve">
            <source><bpt id="1CapsExtId1">&lt;link&gt;</bpt><bpt id="1CapsExtId2">&lt;linkText&gt;</bpt>回路ブレーカーのパターン<ept id="1CapsExtId2">&lt;/linkText&gt;</ept><bpt id="1CapsExtId3">&lt;title&gt;</bpt><ept id="1CapsExtId3">&lt;/title&gt;</ept><ept id="1CapsExtId1">&lt;/link&gt;</ept> このシナリオを処理するために便利です。、</source>
            <target state="new"><bpt id="1CapsExtId1">&lt;link&gt;</bpt><bpt id="1CapsExtId2">&lt;linkText&gt;</bpt>回路ブレーカーのパターン<ept id="1CapsExtId2">&lt;/linkText&gt;</ept><bpt id="1CapsExtId3">&lt;title&gt;</bpt><ept id="1CapsExtId3">&lt;/title&gt;</ept><ept id="1CapsExtId1">&lt;/link&gt;</ept> このシナリオを処理するために便利です。、</target>
          </trans-unit>
          <trans-unit id="316" xml:space="preserve">
            <source>キャッシュを回復することができますと一度それになりますを提供するサービスします。</source>
            <target state="new">キャッシュを回復することができますと一度それになりますを提供するサービスします。</target>
          </trans-unit>
          <trans-unit id="317" xml:space="preserve">
            <source>利用可能なキャッシュ再作成できます読み取りフォーム、</source>
            <target state="new">利用可能なキャッシュ再作成できます読み取りフォーム、</target>
          </trans-unit>
          <trans-unit id="318" xml:space="preserve">
            <source>元のデータ ストアは、次の戦略など、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>キャッシュ アサイド パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</source>
            <target state="new">元のデータ ストアは、次の戦略など、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>キャッシュ アサイド パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="319" xml:space="preserve">
            <source>ただし、フォールバック元のデータ ストアにキャッシュがある場合</source>
            <target state="new">ただし、フォールバック元のデータ ストアにキャッシュがある場合</target>
          </trans-unit>
          <trans-unit id="320" xml:space="preserve">
            <source>一時的にはシステムのスケーラビリティの影響を持つかもしれない</source>
            <target state="new">一時的にはシステムのスケーラビリティの影響を持つかもしれない</target>
          </trans-unit>
          <trans-unit id="321" xml:space="preserve">
            <source>データ ストアがされて回収元のデータ ストア</source>
            <target state="new">データ ストアがされて回収元のデータ ストア</target>
          </trans-unit>
          <trans-unit id="322" xml:space="preserve">
            <source>タイムアウトの結果データの要求が殺到することが、</source>
            <target state="new">タイムアウトの結果データの要求が殺到することが、</target>
          </trans-unit>
          <trans-unit id="323" xml:space="preserve">
            <source>接続に失敗しました。考慮すべき戦略は、します。</source>
            <target state="new">接続に失敗しました。考慮すべき戦略は、します。</target>
          </trans-unit>
          <trans-unit id="324" xml:space="preserve">
            <source>アプリケーションの各インスタンスでローカルのプライベート キャッシュを実装します。</source>
            <target state="new">アプリケーションの各インスタンスでローカルのプライベート キャッシュを実装します。</target>
          </trans-unit>
          <trans-unit id="325" xml:space="preserve">
            <source>一緒に共有キャッシュがアプリケーションのすべてのインスタンス</source>
            <target state="new">一緒に共有キャッシュがアプリケーションのすべてのインスタンス</target>
          </trans-unit>
          <trans-unit id="326" xml:space="preserve">
            <source>アクセスします。それが最初にチェックすることができますアプリケーションでは、アイテムを取得するとき</source>
            <target state="new">アクセスします。それが最初にチェックすることができますアプリケーションでは、アイテムを取得するとき</target>
          </trans-unit>
          <trans-unit id="327" xml:space="preserve">
            <source>で、ローカル キャッシュ、共有キャッシュ、最終的に元</source>
            <target state="new">で、ローカル キャッシュ、共有キャッシュ、最終的に元</target>
          </trans-unit>
          <trans-unit id="328" xml:space="preserve">
            <source>データ ストア。データを使用してローカル キャッシュを設定できます、</source>
            <target state="new">データ ストア。データを使用してローカル キャッシュを設定できます、</target>
          </trans-unit>
          <trans-unit id="329" xml:space="preserve">
            <source>共有キャッシュまたはデータベース共有キャッシュが利用できない場合。</source>
            <target state="new">共有キャッシュまたはデータベース共有キャッシュが利用できない場合。</target>
          </trans-unit>
          <trans-unit id="330" xml:space="preserve">
            <source>ローカルを防ぐために構成に注意が必要です。</source>
            <target state="new">ローカルを防ぐために構成に注意が必要です。</target>
          </trans-unit>
          <trans-unit id="331" xml:space="preserve">
            <source>共有キャッシュが、それに関してあまりにも古くなってキャッシュ</source>
            <target state="new">共有キャッシュが、それに関してあまりにも古くなってキャッシュ</target>
          </trans-unit>
          <trans-unit id="332" xml:space="preserve">
            <source>共有キャッシュに到達できない場合は、バッファーとして機能します。図 3</source>
            <target state="new">共有キャッシュに到達できない場合は、バッファーとして機能します。図 3</target>
          </trans-unit>
          <trans-unit id="333" xml:space="preserve">
            <source>この構造を示しています。</source>
            <target state="new">この構造を示しています。</target>
          </trans-unit>
          <trans-unit id="334" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt>ローカル、プライベート キャッシュを用いた共有キャッシュ_<ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt>ローカル、プライベート キャッシュを用いた共有キャッシュ_<ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="335" xml:space="preserve">
            <source>_図 3: 共有キャッシュとローカルの専用のキャッシュを使用してください。_</source>
            <target state="new">_図 3: 共有キャッシュとローカルの専用のキャッシュを使用してください。_</target>
          </trans-unit>
          <trans-unit id="336" xml:space="preserve">
            <source>いくつか比較的長命のデータを保持する大規模なキャッシュをサポートするには</source>
            <target state="new">いくつか比較的長命のデータを保持する大規模なキャッシュをサポートするには</target>
          </trans-unit>
          <trans-unit id="337" xml:space="preserve">
            <source>キャッシュ サービスを実装する高可用性オプションを提供します。</source>
            <target state="new">キャッシュ サービスを実装する高可用性オプションを提供します。</target>
          </trans-unit>
          <trans-unit id="338" xml:space="preserve">
            <source>自動フェールオーバー キャッシュができなくなった場合。このアプローチ</source>
            <target state="new">自動フェールオーバー キャッシュができなくなった場合。このアプローチ</target>
          </trans-unit>
          <trans-unit id="339" xml:space="preserve">
            <source>通常は、主に保存されているキャッシュのデータをレプリケートします。</source>
            <target state="new">通常は、主に保存されているキャッシュのデータをレプリケートします。</target>
          </trans-unit>
          <trans-unit id="340" xml:space="preserve">
            <source>キャッシュ サーバーはセカンダリ キャッシュ サーバー、およびへの切り替え、</source>
            <target state="new">キャッシュ サーバーはセカンダリ キャッシュ サーバー、およびへの切り替え、</target>
          </trans-unit>
          <trans-unit id="341" xml:space="preserve">
            <source>プライマリ サーバーが失敗した場合はセカンダリ サーバーまたは接続が</source>
            <target state="new">プライマリ サーバーが失敗した場合はセカンダリ サーバーまたは接続が</target>
          </trans-unit>
          <trans-unit id="342" xml:space="preserve">
            <source>失った。複数への書き込みに伴う待ち時間を減らすために</source>
            <target state="new">失った。複数への書き込みに伴う待ち時間を減らすために</target>
          </trans-unit>
          <trans-unit id="343" xml:space="preserve">
            <source>目的地、プライマリ キャッシュにデータが書き込まれる</source>
            <target state="new">目的地、プライマリ キャッシュにデータが書き込まれる</target>
          </trans-unit>
          <trans-unit id="344" xml:space="preserve">
            <source>サーバー、セカンダリ サーバーへのレプリケーションが発生します。</source>
            <target state="new">サーバー、セカンダリ サーバーへのレプリケーションが発生します。</target>
          </trans-unit>
          <trans-unit id="345" xml:space="preserve">
            <source>非同期的にします。 このアプローチは、いくつかの可能性につながる</source>
            <target state="new">非同期的にします。 このアプローチは、いくつかの可能性につながる</target>
          </trans-unit>
          <trans-unit id="346" xml:space="preserve">
            <source>キャッシュされた情報が、障害時に失われるが、</source>
            <target state="new">キャッシュされた情報が、障害時に失われるが、</target>
          </trans-unit>
          <trans-unit id="347" xml:space="preserve">
            <source>このデータの割合は、全体と比較して小さくなるはず</source>
            <target state="new">このデータの割合は、全体と比較して小さくなるはず</target>
          </trans-unit>
          <trans-unit id="348" xml:space="preserve">
            <source>キャッシュのサイズ。</source>
            <target state="new">キャッシュのサイズ。</target>
          </trans-unit>
          <trans-unit id="349" xml:space="preserve">
            <source>パーティションに有益な共有キャッシュが大きい場合があります、</source>
            <target state="new">パーティションに有益な共有キャッシュが大きい場合があります、</target>
          </trans-unit>
          <trans-unit id="350" xml:space="preserve">
            <source>キャッシュされたデータの競合の可能性を減らすためにノード間で、</source>
            <target state="new">キャッシュされたデータの競合の可能性を減らすためにノード間で、</target>
          </trans-unit>
          <trans-unit id="351" xml:space="preserve">
            <source>スケーラビリティが向上します。多くの共有キャッシュ機能をサポートします。</source>
            <target state="new">スケーラビリティが向上します。多くの共有キャッシュ機能をサポートします。</target>
          </trans-unit>
          <trans-unit id="352" xml:space="preserve">
            <source>動的に追加 (および削除) ノード間でデータを再配分と</source>
            <target state="new">動的に追加 (および削除) ノード間でデータを再配分と</target>
          </trans-unit>
          <trans-unit id="353" xml:space="preserve">
            <source>パーティション。このアプローチは、それによってクラスタ リングを伴うことがあります、</source>
            <target state="new">パーティション。このアプローチは、それによってクラスタ リングを伴うことがあります、</target>
          </trans-unit>
          <trans-unit id="354" xml:space="preserve">
            <source>ノードのコレクションとしてクライアント アプリケーションに提示します。</source>
            <target state="new">ノードのコレクションとしてクライアント アプリケーションに提示します。</target>
          </trans-unit>
          <trans-unit id="355" xml:space="preserve">
            <source>シームレスに 1 つのキャッシュが内部的にデータを分散します。</source>
            <target state="new">シームレスに 1 つのキャッシュが内部的にデータを分散します。</target>
          </trans-unit>
          <trans-unit id="356" xml:space="preserve">
            <source>次のいくつかのノード間流通戦略を定義済み</source>
            <target state="new">次のいくつかのノード間流通戦略を定義済み</target>
          </trans-unit>
          <trans-unit id="357" xml:space="preserve">
            <source>これは均等に負荷を分散させます。、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データのパーティション分割のガイダンス文書<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept></source>
            <target state="new">これは均等に負荷を分散させます。、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データのパーティション分割のガイダンス文書<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept></target>
          </trans-unit>
          <trans-unit id="358" xml:space="preserve">
            <source>マイクロソフトのウェブサイトはできるだけの詳細についてを提供します。</source>
            <target state="new">マイクロソフトのウェブサイトはできるだけの詳細についてを提供します。</target>
          </trans-unit>
          <trans-unit id="359" xml:space="preserve">
            <source>パーティション分割の方法。</source>
            <target state="new">パーティション分割の方法。</target>
          </trans-unit>
          <trans-unit id="360" xml:space="preserve">
            <source>クラスタ リング追加することも一層キャッシュの可用性場合は、</source>
            <target state="new">クラスタ リング追加することも一層キャッシュの可用性場合は、</target>
          </trans-unit>
          <trans-unit id="361" xml:space="preserve">
            <source>ノードが失敗した場合、キャッシュの残りの部分は、まだアクセス可能です。</source>
            <target state="new">ノードが失敗した場合、キャッシュの残りの部分は、まだアクセス可能です。</target>
          </trans-unit>
          <trans-unit id="362" xml:space="preserve">
            <source>レプリケーションと連動で多用されるクラスタ リング</source>
            <target state="new">レプリケーションと連動で多用されるクラスタ リング</target>
          </trans-unit>
          <trans-unit id="363" xml:space="preserve">
            <source>フェイル オーバー。各ノードを複製することができますとレプリカ</source>
            <target state="new">フェイル オーバー。各ノードを複製することができますとレプリカ</target>
          </trans-unit>
          <trans-unit id="364" xml:space="preserve">
            <source>迅速にオンラインにノードが失敗する場合。</source>
            <target state="new">迅速にオンラインにノードが失敗する場合。</target>
          </trans-unit>
          <trans-unit id="365" xml:space="preserve">
            <source>多くと書き込み操作が 1 つのデータを含む可能性が高い</source>
            <target state="new">多くと書き込み操作が 1 つのデータを含む可能性が高い</target>
          </trans-unit>
          <trans-unit id="366" xml:space="preserve">
            <source>値またはオブジェクト。ただしがある場合があるかもしれません</source>
            <target state="new">値またはオブジェクト。ただしがある場合があるかもしれません</target>
          </trans-unit>
          <trans-unit id="367" xml:space="preserve">
            <source>必要に応じて保存または大量のデータを迅速に取得します。</source>
            <target state="new">必要に応じて保存または大量のデータを迅速に取得します。</target>
          </trans-unit>
          <trans-unit id="368" xml:space="preserve">
            <source>たとえば、何百もの書き込み含むことができるキャッシュをシードまたは</source>
            <target state="new">たとえば、何百もの書き込み含むことができるキャッシュをシードまたは</target>
          </trans-unit>
          <trans-unit id="369" xml:space="preserve">
            <source>キャッシュ、またはアプリケーションへのアイテムの何千もする必要があります。</source>
            <target state="new">キャッシュ、またはアプリケーションへのアイテムの何千もする必要があります。</target>
          </trans-unit>
          <trans-unit id="370" xml:space="preserve">
            <source>としてキャッシュから多数の関連アイテムを取得します。</source>
            <target state="new">としてキャッシュから多数の関連アイテムを取得します。</target>
          </trans-unit>
          <trans-unit id="371" xml:space="preserve">
            <source>同じ要求の一部です。多くの大規模なキャッシュを提供するバッチ</source>
            <target state="new">同じ要求の一部です。多くの大規模なキャッシュを提供するバッチ</target>
          </trans-unit>
          <trans-unit id="372" xml:space="preserve">
            <source>これらの目的は、クライアント アプリケーションの操作</source>
            <target state="new">これらの目的は、クライアント アプリケーションの操作</target>
          </trans-unit>
          <trans-unit id="373" xml:space="preserve">
            <source>大量の 1 つの要求にアイテムをパッケージ化し、</source>
            <target state="new">大量の 1 つの要求にアイテムをパッケージ化し、</target>
          </trans-unit>
          <trans-unit id="374" xml:space="preserve">
            <source>多数の実行に伴うオーバーヘッドを削減</source>
            <target state="new">多数の実行に伴うオーバーヘッドを削減</target>
          </trans-unit>
          <trans-unit id="375" xml:space="preserve">
            <source>小さな要求。</source>
            <target state="new">小さな要求。</target>
          </trans-unit>
          <trans-unit id="376" xml:space="preserve">
            <source>キャッシュおよび最終的な一貫性</source>
            <target state="new">キャッシュおよび最終的な一貫性</target>
          </trans-unit>
          <trans-unit id="377" xml:space="preserve">
            <source>キャッシュ アサイド パターンは、アプリケーションのインスタンスに依存します。</source>
            <target state="new">キャッシュ アサイド パターンは、アプリケーションのインスタンスに依存します。</target>
          </trans-unit>
          <trans-unit id="378" xml:space="preserve">
            <source>最も最近にアクセス キャッシュへの読み込みと</source>
            <target state="new">最も最近にアクセス キャッシュへの読み込みと</target>
          </trans-unit>
          <trans-unit id="379" xml:space="preserve">
            <source>データの一貫性のあるバージョンです。実装するシステムで</source>
            <target state="new">データの一貫性のあるバージョンです。実装するシステムで</target>
          </trans-unit>
          <trans-unit id="380" xml:space="preserve">
            <source>イベンチュアル ・ コンシステンシー (レプリケートされたデータ ストア) などが</source>
            <target state="new">イベンチュアル ・ コンシステンシー (レプリケートされたデータ ストア) などが</target>
          </trans-unit>
          <trans-unit id="381" xml:space="preserve">
            <source>ケースではないです。アプリケーションの 1 つのインスタンスを変更します。</source>
            <target state="new">ケースではないです。アプリケーションの 1 つのインスタンスを変更します。</target>
          </trans-unit>
          <trans-unit id="382" xml:space="preserve">
            <source>データ項目し、その項目のキャッシュされたバージョンを無効にします。もう一つ</source>
            <target state="new">データ項目し、その項目のキャッシュされたバージョンを無効にします。もう一つ</target>
          </trans-unit>
          <trans-unit id="383" xml:space="preserve">
            <source>アプリケーションのインスタンスからこの項目を読むしようとする可能性があります。</source>
            <target state="new">アプリケーションのインスタンスからこの項目を読むしようとする可能性があります。</target>
          </trans-unit>
          <trans-unit id="384" xml:space="preserve">
            <source>キャッシュはキャッシュ ・ ミスが発生するからデータを読み取るので、</source>
            <target state="new">キャッシュはキャッシュ ・ ミスが発生するからデータを読み取るので、</target>
          </trans-unit>
          <trans-unit id="385" xml:space="preserve">
            <source>データ保存し、それをキャッシュに追加します。ただし、データ ストアの場合</source>
            <target state="new">データ保存し、それをキャッシュに追加します。ただし、データ ストアの場合</target>
          </trans-unit>
          <trans-unit id="386" xml:space="preserve">
            <source>他のレプリカと完全に同期されていない、</source>
            <target state="new">他のレプリカと完全に同期されていない、</target>
          </trans-unit>
          <trans-unit id="387" xml:space="preserve">
            <source>アプリケーション インスタンスが読み取りできをキャッシュに設定、</source>
            <target state="new">アプリケーション インスタンスが読み取りできをキャッシュに設定、</target>
          </trans-unit>
          <trans-unit id="388" xml:space="preserve">
            <source>古い値。</source>
            <target state="new">古い値。</target>
          </trans-unit>
          <trans-unit id="389" xml:space="preserve">
            <source>データの整合性の処理の詳細についてを参照してください、</source>
            <target state="new">データの整合性の処理の詳細についてを参照してください、</target>
          </trans-unit>
          <trans-unit id="390" xml:space="preserve">
            <source>Microsoft の web サイト上のデータの一貫性指導のページ。</source>
            <target state="new">Microsoft の web サイト上のデータの一貫性指導のページ。</target>
          </trans-unit>
          <trans-unit id="391" xml:space="preserve">
            <source>キャッシュされたデータの保護</source>
            <target state="new">キャッシュされたデータの保護</target>
          </trans-unit>
          <trans-unit id="392" xml:space="preserve">
            <source>関係なく、キャッシュ サービスを使用して、検討してください。</source>
            <target state="new">関係なく、キャッシュ サービスを使用して、検討してください。</target>
          </trans-unit>
          <trans-unit id="393" xml:space="preserve">
            <source>不正からキャッシュで保持されるデータを保護する方法</source>
            <target state="new">不正からキャッシュで保持されるデータを保護する方法</target>
          </trans-unit>
          <trans-unit id="394" xml:space="preserve">
            <source>アクセスします。2 つの主な懸念があります。</source>
            <target state="new">アクセスします。2 つの主な懸念があります。</target>
          </trans-unit>
          <trans-unit id="395" xml:space="preserve">
            <source>キャッシュ内のデータのプライバシー。</source>
            <target state="new">キャッシュ内のデータのプライバシー。</target>
          </trans-unit>
          <trans-unit id="396" xml:space="preserve">
            <source>キャッシュ間のデータのプライバシーの流れと、</source>
            <target state="new">キャッシュ間のデータのプライバシーの流れと、</target>
          </trans-unit>
          <trans-unit id="397" xml:space="preserve">
            <source>アプリケーション キャッシュを使用します。</source>
            <target state="new">アプリケーション キャッシュを使用します。</target>
          </trans-unit>
          <trans-unit id="398" xml:space="preserve">
            <source>キャッシュ内のデータを保護するためにキャッシュ サービスを実装する場合があります。</source>
            <target state="new">キャッシュ内のデータを保護するためにキャッシュ サービスを実装する場合があります。</target>
          </trans-unit>
          <trans-unit id="399" xml:space="preserve">
            <source>要求する認証メカニズムのアプリケーション</source>
            <target state="new">要求する認証メカニズムのアプリケーション</target>
          </trans-unit>
          <trans-unit id="400" xml:space="preserve">
            <source>、自分自身を識別し、承認スキーム</source>
            <target state="new">、自分自身を識別し、承認スキーム</target>
          </trans-unit>
          <trans-unit id="401" xml:space="preserve">
            <source>どの id が、キャッシュ内のデータにアクセスできるを指定しますと</source>
            <target state="new">どの id が、キャッシュ内のデータにアクセスできるを指定しますと</target>
          </trans-unit>
          <trans-unit id="402" xml:space="preserve">
            <source>これらの id は操作 (読み取りと書き込み)</source>
            <target state="new">これらの id は操作 (読み取りと書き込み)</target>
          </trans-unit>
          <trans-unit id="403" xml:space="preserve">
            <source>実行を許可します。関連するオーバーヘッドを削減するには</source>
            <target state="new">実行を許可します。関連するオーバーヘッドを削減するには</target>
          </trans-unit>
          <trans-unit id="404" xml:space="preserve">
            <source>一度 id が付与されたデータの読み書き</source>
            <target state="new">一度 id が付与されたデータの読み書き</target>
          </trans-unit>
          <trans-unit id="405" xml:space="preserve">
            <source>書き込みや識別に使用できるキャッシュへの読み取りアクセス</source>
            <target state="new">書き込みや識別に使用できるキャッシュへの読み取りアクセス</target>
          </trans-unit>
          <trans-unit id="406" xml:space="preserve">
            <source>キャッシュ内のデータ。アクセスを制限する必要がある場合</source>
            <target state="new">キャッシュ内のデータ。アクセスを制限する必要がある場合</target>
          </trans-unit>
          <trans-unit id="407" xml:space="preserve">
            <source>キャッシュされたデータのサブセットは、次の操作を実行できます。</source>
            <target state="new">キャッシュされたデータのサブセットは、次の操作を実行できます。</target>
          </trans-unit>
          <trans-unit id="408" xml:space="preserve">
            <source>(別のキャッシュを使用して、キャッシュをパーティション分割します。</source>
            <target state="new">(別のキャッシュを使用して、キャッシュをパーティション分割します。</target>
          </trans-unit>
          <trans-unit id="409" xml:space="preserve">
            <source>サーバー) の id にアクセスのみを許可し、</source>
            <target state="new">サーバー) の id にアクセスのみを許可し、</target>
          </trans-unit>
          <trans-unit id="410" xml:space="preserve">
            <source>パーティションを使用して、許可する必要がありますか</source>
            <target state="new">パーティションを使用して、許可する必要がありますか</target>
          </trans-unit>
          <trans-unit id="411" xml:space="preserve">
            <source>別のキーを使用して、各サブセットのデータを暗号化します。</source>
            <target state="new">別のキーを使用して、各サブセットのデータを暗号化します。</target>
          </trans-unit>
          <trans-unit id="412" xml:space="preserve">
            <source>のみ id に暗号化キーを提供して</source>
            <target state="new">のみ id に暗号化キーを提供して</target>
          </trans-unit>
          <trans-unit id="413" xml:space="preserve">
            <source>各サブセットへのアクセスが必要です。クライアント アプリケーション</source>
            <target state="new">各サブセットへのアクセスが必要です。クライアント アプリケーション</target>
          </trans-unit>
          <trans-unit id="414" xml:space="preserve">
            <source>キャッシュ内のデータのすべてを取得することができます。</source>
            <target state="new">キャッシュ内のデータのすべてを取得することができます。</target>
          </trans-unit>
          <trans-unit id="415" xml:space="preserve">
            <source>だけそれのデータを復号化できるようになりますが、</source>
            <target state="new">だけそれのデータを復号化できるようになりますが、</target>
          </trans-unit>
          <trans-unit id="416" xml:space="preserve">
            <source>鍵を持っています。</source>
            <target state="new">鍵を持っています。</target>
          </trans-unit>
          <trans-unit id="417" xml:space="preserve">
            <source>それはデータを保護するためにフロー キャッシュに出入りします。</source>
            <target state="new">それはデータを保護するためにフロー キャッシュに出入りします。</target>
          </trans-unit>
          <trans-unit id="418" xml:space="preserve">
            <source>ネットワークで提供されるセキュリティ機能に依存しています。</source>
            <target state="new">ネットワークで提供されるセキュリティ機能に依存しています。</target>
          </trans-unit>
          <trans-unit id="419" xml:space="preserve">
            <source>インフラストラクチャに接続するクライアント アプリケーションを使用している、</source>
            <target state="new">インフラストラクチャに接続するクライアント アプリケーションを使用している、</target>
          </trans-unit>
          <trans-unit id="420" xml:space="preserve">
            <source>キャッシュ。敷地内のサーバーを使用して、キャッシュを実装する場合</source>
            <target state="new">キャッシュ。敷地内のサーバーを使用して、キャッシュを実装する場合</target>
          </trans-unit>
          <trans-unit id="421" xml:space="preserve">
            <source>クライアント アプリケーションをホストする同じ組織内</source>
            <target state="new">クライアント アプリケーションをホストする同じ組織内</target>
          </trans-unit>
          <trans-unit id="422" xml:space="preserve">
            <source>その後、ネットワーク自体の分離をしないする必要があります。</source>
            <target state="new">その後、ネットワーク自体の分離をしないする必要があります。</target>
          </trans-unit>
          <trans-unit id="423" xml:space="preserve">
            <source>任意の追加の手順を実行します。キャッシュがリモートにある場合、</source>
            <target state="new">任意の追加の手順を実行します。キャッシュがリモートにある場合、</target>
          </trans-unit>
          <trans-unit id="424" xml:space="preserve">
            <source>(このようなパブリック ネットワークを介して TCP または HTTP 接続が必要です。</source>
            <target state="new">(このようなパブリック ネットワークを介して TCP または HTTP 接続が必要です。</target>
          </trans-unit>
          <trans-unit id="425" xml:space="preserve">
            <source>・ インターネットとして SSL を実装することを検討してください。</source>
            <target state="new">・ インターネットとして SSL を実装することを検討してください。</target>
          </trans-unit>
          <trans-unit id="426" xml:space="preserve">
            <source>Microsoft Azure のキャッシュを実装するための考慮事項</source>
            <target state="new">Microsoft Azure のキャッシュを実装するための考慮事項</target>
          </trans-unit>
          <trans-unit id="427" xml:space="preserve">
            <source>Azure では、Azure Redis キャッシュを提供します。これは実装です。</source>
            <target state="new">Azure では、Azure Redis キャッシュを提供します。これは実装です。</target>
          </trans-unit>
          <trans-unit id="428" xml:space="preserve">
            <source>オープン ソースのサービスとして実行される Redis のキャッシュ、</source>
            <target state="new">オープン ソースのサービスとして実行される Redis のキャッシュ、</target>
          </trans-unit>
          <trans-unit id="429" xml:space="preserve">
            <source>Azure のデータ センターです。それはすることができますキャッシュ サービスを提供します</source>
            <target state="new">Azure のデータ センターです。それはすることができますキャッシュ サービスを提供します</target>
          </trans-unit>
          <trans-unit id="430" xml:space="preserve">
            <source>かどうか、任意の Azure アプリケーションからアクセス アプリケーション</source>
            <target state="new">かどうか、任意の Azure アプリケーションからアクセス アプリケーション</target>
          </trans-unit>
          <trans-unit id="431" xml:space="preserve">
            <source>クラウド サービス、web サイト、または内部として実装は、</source>
            <target state="new">クラウド サービス、web サイト、または内部として実装は、</target>
          </trans-unit>
          <trans-unit id="432" xml:space="preserve">
            <source>Azure の仮想マシンです。キャッシュは、クライアントによって共有することができます。</source>
            <target state="new">Azure の仮想マシンです。キャッシュは、クライアントによって共有することができます。</target>
          </trans-unit>
          <trans-unit id="433" xml:space="preserve">
            <source>適切なアクセス キーを持つアプリケーション。</source>
            <target state="new">適切なアクセス キーを持つアプリケーション。</target>
          </trans-unit>
          <trans-unit id="434" xml:space="preserve">
            <source>Redis は高性能のキャッシュ ソリューションを提供します。</source>
            <target state="new">Redis は高性能のキャッシュ ソリューションを提供します。</target>
          </trans-unit>
          <trans-unit id="435" xml:space="preserve">
            <source>可用性、スケーラビリティおよびセキュリティ。それは通常実行します。</source>
            <target state="new">可用性、スケーラビリティおよびセキュリティ。それは通常実行します。</target>
          </trans-unit>
          <trans-unit id="436" xml:space="preserve">
            <source>1 つまたは複数の専用マシンに分散サービスとして、</source>
            <target state="new">1 つまたは複数の専用マシンに分散サービスとして、</target>
          </trans-unit>
          <trans-unit id="437" xml:space="preserve">
            <source>メモリにできるだけ多くの情報を格納しようとしました。</source>
            <target state="new">メモリにできるだけ多くの情報を格納しようとしました。</target>
          </trans-unit>
          <trans-unit id="438" xml:space="preserve">
            <source>高速アクセスを確保します。このアーキテクチャを使用すると、</source>
            <target state="new">高速アクセスを確保します。このアーキテクチャを使用すると、</target>
          </trans-unit>
          <trans-unit id="439" xml:space="preserve">
            <source>低レーテンシーとする必要性を減らすことによる高スループット</source>
            <target state="new">低レーテンシーとする必要性を減らすことによる高スループット</target>
          </trans-unit>
          <trans-unit id="440" xml:space="preserve">
            <source>遅い I/O 操作を実行します。</source>
            <target state="new">遅い I/O 操作を実行します。</target>
          </trans-unit>
          <trans-unit id="441" xml:space="preserve">
            <source>Azure Redis キャッシュは多くの様々 な互換性のあります。</source>
            <target state="new">Azure Redis キャッシュは多くの様々 な互換性のあります。</target>
          </trans-unit>
          <trans-unit id="442" xml:space="preserve">
            <source>クライアント アプリケーションで使用する Api。既存がある場合</source>
            <target state="new">クライアント アプリケーションで使用する Api。既存がある場合</target>
          </trans-unit>
          <trans-unit id="443" xml:space="preserve">
            <source>Redis 社内の実行を既に使用しているアプリケーション、</source>
            <target state="new">Redis 社内の実行を既に使用しているアプリケーション、</target>
          </trans-unit>
          <trans-unit id="444" xml:space="preserve">
            <source>紺碧 Redis キャッシュ キャッシュへの迅速な移行パスを提供します。</source>
            <target state="new">紺碧 Redis キャッシュ キャッシュへの迅速な移行パスを提供します。</target>
          </trans-unit>
          <trans-unit id="445" xml:space="preserve">
            <source>クラウドで。</source>
            <target state="new">クラウドで。</target>
          </trans-unit>
          <trans-unit id="446" xml:space="preserve">
            <source>[AZURE。メモ] Azure には、キャッシュの管理サービスも提供します。これ</source>
            <target state="new">[AZURE。メモ] Azure には、キャッシュの管理サービスも提供します。これ</target>
          </trans-unit>
          <trans-unit id="447" xml:space="preserve">
            <source>サービスは、Microsoft の AppFabric キャッシュ エンジンに基づきます。それ</source>
            <target state="new">サービスは、Microsoft の AppFabric キャッシュ エンジンに基づきます。それ</target>
          </trans-unit>
          <trans-unit id="448" xml:space="preserve">
            <source>共有できる分散キャッシュを作成することができます。</source>
            <target state="new">共有できる分散キャッシュを作成することができます。</target>
          </trans-unit>
          <trans-unit id="449" xml:space="preserve">
            <source>疎結合アプリケーション。キャッシュ上でホストされて</source>
            <target state="new">疎結合アプリケーション。キャッシュ上でホストされて</target>
          </trans-unit>
          <trans-unit id="450" xml:space="preserve">
            <source>Azure のデータ センターで実行されている高性能サーバー。</source>
            <target state="new">Azure のデータ センターで実行されている高性能サーバー。</target>
          </trans-unit>
          <trans-unit id="451" xml:space="preserve">
            <source>ただし、このオプションは推奨されません、だけ</source>
            <target state="new">ただし、このオプションは推奨されません、だけ</target>
          </trans-unit>
          <trans-unit id="452" xml:space="preserve">
            <source>構築されている既存のアプリケーションをサポートします。</source>
            <target state="new">構築されている既存のアプリケーションをサポートします。</target>
          </trans-unit>
          <trans-unit id="453" xml:space="preserve">
            <source>それを使用します。すべての新しい開発のため使用する Azure Redis</source>
            <target state="new">それを使用します。すべての新しい開発のため使用する Azure Redis</target>
          </trans-unit>
          <trans-unit id="454" xml:space="preserve">
            <source>代わりにキャッシュします。</source>
            <target state="new">代わりにキャッシュします。</target>
          </trans-unit>
          <trans-unit id="455" xml:space="preserve">
            <source>さらに、Azure は、ロールのキャッシュをサポートしています。この機能</source>
            <target state="new">さらに、Azure は、ロールのキャッシュをサポートしています。この機能</target>
          </trans-unit>
          <trans-unit id="456" xml:space="preserve">
            <source>クラウド サービスに固有のキャッシュを作成できます。</source>
            <target state="new">クラウド サービスに固有のキャッシュを作成できます。</target>
          </trans-unit>
          <trans-unit id="457" xml:space="preserve">
            <source>キャッシュが web またはワーカー ロールのインスタンスによってホストされていると</source>
            <target state="new">キャッシュが web またはワーカー ロールのインスタンスによってホストされていると</target>
          </trans-unit>
          <trans-unit id="458" xml:space="preserve">
            <source>同じの一部として操作の役割によってのみアクセスできます。</source>
            <target state="new">同じの一部として操作の役割によってのみアクセスできます。</target>
          </trans-unit>
          <trans-unit id="459" xml:space="preserve">
            <source>クラウド サービス展開単位 (デプロイメント ユニットがセット</source>
            <target state="new">クラウド サービス展開単位 (デプロイメント ユニットがセット</target>
          </trans-unit>
          <trans-unit id="460" xml:space="preserve">
            <source>ロール インスタンスの特定の提供するクラウド サービスとして展開</source>
            <target state="new">ロール インスタンスの特定の提供するクラウド サービスとして展開</target>
          </trans-unit>
          <trans-unit id="461" xml:space="preserve">
            <source>地域)。キャッシュがクラスター化されると、すべてのインスタンスの</source>
            <target state="new">地域)。キャッシュがクラスター化されると、すべてのインスタンスの</target>
          </trans-unit>
          <trans-unit id="462" xml:space="preserve">
            <source>キャッシュをホストする同一の配置単位内の役割</source>
            <target state="new">キャッシュをホストする同一の配置単位内の役割</target>
          </trans-unit>
          <trans-unit id="463" xml:space="preserve">
            <source>同じキャッシュ クラスターの一部となります。既存のアプリケーション</source>
            <target state="new">同じキャッシュ クラスターの一部となります。既存のアプリケーション</target>
          </trans-unit>
          <trans-unit id="464" xml:space="preserve">
            <source>、そうし続ける役割でキャッシュを使用することができますが、</source>
            <target state="new">、そうし続ける役割でキャッシュを使用することができますが、</target>
          </trans-unit>
          <trans-unit id="465" xml:space="preserve">
            <source>Azure Redis キャッシュへの移行より多くの利益をもたらす可能性があります。</source>
            <target state="new">Azure Redis キャッシュへの移行より多くの利益をもたらす可能性があります。</target>
          </trans-unit>
          <trans-unit id="466" xml:space="preserve">
            <source>Azure Redis キャッシュを使用するかどうかの詳細について</source>
            <target state="new">Azure Redis キャッシュを使用するかどうかの詳細について</target>
          </trans-unit>
          <trans-unit id="467" xml:space="preserve">
            <source>または、ロール内の-キャッシュ、ページをご覧ください</source>
            <target state="new">または、ロール内の-キャッシュ、ページをご覧ください</target>
          </trans-unit>
          <trans-unit id="468" xml:space="preserve">
            <source><bpt id="1CapsExtId1">&lt;link&gt;</bpt><bpt id="1CapsExtId2">&lt;linkText&gt;</bpt>Azure キャッシュ サービスは私にとって正しいですか。<ept id="1CapsExtId2">&lt;/linkText&gt;</ept><bpt id="1CapsExtId3">&lt;title&gt;</bpt><ept id="1CapsExtId3">&lt;/title&gt;</ept><ept id="1CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</source>
            <target state="new"><bpt id="1CapsExtId1">&lt;link&gt;</bpt><bpt id="1CapsExtId2">&lt;linkText&gt;</bpt>Azure キャッシュ サービスは私にとって正しいですか。<ept id="1CapsExtId2">&lt;/linkText&gt;</ept><bpt id="1CapsExtId3">&lt;title&gt;</bpt><ept id="1CapsExtId3">&lt;/title&gt;</ept><ept id="1CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</target>
          </trans-unit>
          <trans-unit id="469" xml:space="preserve">
            <source>Redis の特徴</source>
            <target state="new">Redis の特徴</target>
          </trans-unit>
          <trans-unit id="470" xml:space="preserve">
            <source>Redis は簡単なキャッシュ サーバー; より分散メモリを提供します。</source>
            <target state="new">Redis は簡単なキャッシュ サーバー; より分散メモリを提供します。</target>
          </trans-unit>
          <trans-unit id="471" xml:space="preserve">
            <source>多くの一般的なシナリオをサポートする豊富なコマンド セットを備えたデータベース</source>
            <target state="new">多くの一般的なシナリオをサポートする豊富なコマンド セットを備えたデータベース</target>
          </trans-unit>
          <trans-unit id="472" xml:space="preserve">
            <source>使用例で説明したよう Redis 後述のキャッシュ</source>
            <target state="new">使用例で説明したよう Redis 後述のキャッシュ</target>
          </trans-unit>
          <trans-unit id="473" xml:space="preserve">
            <source>ドキュメント。このセクションは Redis 主要な機能のいくつかをまとめたもの</source>
            <target state="new">ドキュメント。このセクションは Redis 主要な機能のいくつかをまとめたもの</target>
          </trans-unit>
          <trans-unit id="474" xml:space="preserve">
            <source>提供します。</source>
            <target state="new">提供します。</target>
          </trans-unit>
          <trans-unit id="475" xml:space="preserve">
            <source>メモリ内データベースとして redis します。</source>
            <target state="new">メモリ内データベースとして redis します。</target>
          </trans-unit>
          <trans-unit id="476" xml:space="preserve">
            <source>Redis では、読み取りと書き込み操作の両方をサポートしています。(これは一時的なデータ ストアとして考慮されるべき) 多くのキャッシュとは異なり書き込みはいずれかに定期的にローカル スナップショット ファイルまたは追加のみのログ ファイルに格納される、システム障害から保護できます。すべての書き込みは非同期であり、クライアントの読み取りとデータの書き込みをブロックしません。とき Redis 実行を開始、スナップショットまたはログ ファイルからデータを読み取り、使用してメモリ内にキャッシュを構築します。詳細については、次を参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>REDIS の永続性<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</source>
            <target state="new">Redis では、読み取りと書き込み操作の両方をサポートしています。(これは一時的なデータ ストアとして考慮されるべき) 多くのキャッシュとは異なり書き込みはいずれかに定期的にローカル スナップショット ファイルまたは追加のみのログ ファイルに格納される、システム障害から保護できます。すべての書き込みは非同期であり、クライアントの読み取りとデータの書き込みをブロックしません。とき Redis 実行を開始、スナップショットまたはログ ファイルからデータを読み取り、使用してメモリ内にキャッシュを構築します。詳細については、次を参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>REDIS の永続性<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</target>
          </trans-unit>
          <trans-unit id="477" xml:space="preserve">
            <source>[AZURE。メモ] Redis はすべての書き込みがイベントログに保存されることを保証しません</source>
            <target state="new">[AZURE。メモ] Redis はすべての書き込みがイベントログに保存されることを保証しません</target>
          </trans-unit>
          <trans-unit id="478" xml:space="preserve">
            <source>のみいくつかの秒を失う必要があります最悪の時が、致命的な障害の</source>
            <target state="new">のみいくつかの秒を失う必要があります最悪の時が、致命的な障害の</target>
          </trans-unit>
          <trans-unit id="479" xml:space="preserve">
            <source>データの価値があります。キャッシュとして機能する意図しないことを覚えて、</source>
            <target state="new">データの価値があります。キャッシュとして機能する意図しないことを覚えて、</target>
          </trans-unit>
          <trans-unit id="480" xml:space="preserve">
            <source>権限のあるデータ ソース、およびそれがアプリケーションの責任</source>
            <target state="new">権限のあるデータ ソース、およびそれがアプリケーションの責任</target>
          </trans-unit>
          <trans-unit id="481" xml:space="preserve">
            <source>正常に保存が重要なデータを確実にキャッシュを使用して、</source>
            <target state="new">正常に保存が重要なデータを確実にキャッシュを使用して、</target>
          </trans-unit>
          <trans-unit id="482" xml:space="preserve">
            <source>適切なデータ ストア。詳細については、キャッシュ アサイド パターンを参照してください。</source>
            <target state="new">適切なデータ ストア。詳細については、キャッシュ アサイド パターンを参照してください。</target>
          </trans-unit>
          <trans-unit id="483" xml:space="preserve">
            <source>Redis データ型</source>
            <target state="new">Redis データ型</target>
          </trans-unit>
          <trans-unit id="484" xml:space="preserve">
            <source>Redis 値が単純型またはリスト、ハッシュなどの複雑なデータ構造を含めることができますキーおよび値のストア、および設定します。これらのデータ型の分割不可能な操作のセットをサポートしています。キーは永続的またはその時点でキーと対応する値は自動的にキャッシュから削除されますに住む限られた時間でタグ付けすることができます。Redis キーと値の詳細については、ページを参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis データ型および抽象化の導入<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</source>
            <target state="new">Redis 値が単純型またはリスト、ハッシュなどの複雑なデータ構造を含めることができますキーおよび値のストア、および設定します。これらのデータ型の分割不可能な操作のセットをサポートしています。キーは永続的またはその時点でキーと対応する値は自動的にキャッシュから削除されますに住む限られた時間でタグ付けすることができます。Redis キーと値の詳細については、ページを参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis データ型および抽象化の導入<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</target>
          </trans-unit>
          <trans-unit id="485" xml:space="preserve">
            <source>Redis レプリケーションとクラスタ リング</source>
            <target state="new">Redis レプリケーションとクラスタ リング</target>
          </trans-unit>
          <trans-unit id="486" xml:space="preserve">
            <source>Redis は、マスターと下位の可用性を確保し、スループットを維持するためにレプリケーションをサポートしていますRedis マスター ノードへの書き込み操作が 1 つにレプリケートまたはより多くの従属ノード、および読み取り操作は、マスターまたは下位図形のいずれかによって提供できます。ネットワーク パーティションが発生した場合は、部下がデータを提供して、透過的に再同期マスターとの接続が再確立されたときに続行できます。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>レプリケーション<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</source>
            <target state="new">Redis は、マスターと下位の可用性を確保し、スループットを維持するためにレプリケーションをサポートしていますRedis マスター ノードへの書き込み操作が 1 つにレプリケートまたはより多くの従属ノード、および読み取り操作は、マスターまたは下位図形のいずれかによって提供できます。ネットワーク パーティションが発生した場合は、部下がデータを提供して、透過的に再同期マスターとの接続が再確立されたときに続行できます。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>レプリケーション<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="487" xml:space="preserve">
            <source>Redis では、クラスタ リング、透過的に破片にサーバー間でデータを分割し、負荷分散することができる提供しています。この機能は、Redis の新しいサーバーを追加することができ、データ キャッシュのサイズに従って増加のスケーラビリティを向上させます。さらに、クラスター内の各サーバーは、クラスター内の各ノード間で可用性を確保するマスターと下位のレプリケーションを使用してレプリケートできます。クラスタ リングと分割の詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis クラスター チュートリアル ページ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</source>
            <target state="new">Redis では、クラスタ リング、透過的に破片にサーバー間でデータを分割し、負荷分散することができる提供しています。この機能は、Redis の新しいサーバーを追加することができ、データ キャッシュのサイズに従って増加のスケーラビリティを向上させます。さらに、クラスター内の各サーバーは、クラスター内の各ノード間で可用性を確保するマスターと下位のレプリケーションを使用してレプリケートできます。クラスタ リングと分割の詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis クラスター チュートリアル ページ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</target>
          </trans-unit>
          <trans-unit id="488" xml:space="preserve">
            <source>[AZURE。メモ] 紺碧 Redis キャッシュは現在クラスタ リングをサポートしていません。Redis クラスターを作成する場合は、カスタム Redis サーバーを構築できます。詳細については、このドキュメントの後半のカスタム Redis キャッシュを構築を参照してください。</source>
            <target state="new">[AZURE。メモ] 紺碧 Redis キャッシュは現在クラスタ リングをサポートしていません。Redis クラスターを作成する場合は、カスタム Redis サーバーを構築できます。詳細については、このドキュメントの後半のカスタム Redis キャッシュを構築を参照してください。</target>
          </trans-unit>
          <trans-unit id="489" xml:space="preserve">
            <source>メモリの使用量を redis します。</source>
            <target state="new">メモリの使用量を redis します。</target>
          </trans-unit>
          <trans-unit id="490" xml:space="preserve">
            <source>Redis キャッシュは、ホスト コンピューターで利用可能なリソースに応じて有限サイズを持ちます。Redis サーバーを構成するときは、使用できるメモリの最大量を指定できます。Redis キャッシュ内のキーは、有効期間、その後自動的にキャッシュから削除で構成できます。この機能は、メモリ内キャッシュが古いまたは古いデータで満たされているを防ぐことができます。</source>
            <target state="new">Redis キャッシュは、ホスト コンピューターで利用可能なリソースに応じて有限サイズを持ちます。Redis サーバーを構成するときは、使用できるメモリの最大量を指定できます。Redis キャッシュ内のキーは、有効期間、その後自動的にキャッシュから削除で構成できます。この機能は、メモリ内キャッシュが古いまたは古いデータで満たされているを防ぐことができます。</target>
          </trans-unit>
          <trans-unit id="491" xml:space="preserve">
            <source>メモリがいっぱいになりました、Redis できます自動的にポリシーの数に従って、キーとその値を削除します。既定では (少なくとも最近使用)、LRU が選択することも、ランダムにキーを削除または削除をオフにするなど他の政策全体で (その場合、項目をキャッシュに追加するのには失敗しますがいっぱいの場合)。ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>LRU キャッシュとして Redis を使用してください。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 多くの情報を提供します。</source>
            <target state="new">メモリがいっぱいになりました、Redis できます自動的にポリシーの数に従って、キーとその値を削除します。既定では (少なくとも最近使用)、LRU が選択することも、ランダムにキーを削除または削除をオフにするなど他の政策全体で (その場合、項目をキャッシュに追加するのには失敗しますがいっぱいの場合)。ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>LRU キャッシュとして Redis を使用してください。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 多くの情報を提供します。</target>
          </trans-unit>
          <trans-unit id="492" xml:space="preserve">
            <source>Redis トランザクションとバッチ</source>
            <target state="new">Redis トランザクションとバッチ</target>
          </trans-unit>
          <trans-unit id="493" xml:space="preserve">
            <source>Redis enables a client application to submit a series of operations that read and write data in the cache as an atomic transaction.</source>
            <target state="new">Redis enables a client application to submit a series of operations that read and write data in the cache as an atomic transaction.</target>
          </trans-unit>
          <trans-unit id="494" xml:space="preserve">
            <source>All of the commands in the transaction are guaranteed to be executed sequentially and no commands issued by other concurrent clients will be interwoven between them.</source>
            <target state="new">All of the commands in the transaction are guaranteed to be executed sequentially and no commands issued by other concurrent clients will be interwoven between them.</target>
          </trans-unit>
          <trans-unit id="495" xml:space="preserve">
            <source>However, these are not true transactions as a relational database would perform them.</source>
            <target state="new">However, these are not true transactions as a relational database would perform them.</target>
          </trans-unit>
          <trans-unit id="496" xml:space="preserve">
            <source>Transaction processing consists of two stages; command queuing and command execution.</source>
            <target state="new">Transaction processing consists of two stages; command queuing and command execution.</target>
          </trans-unit>
          <trans-unit id="497" xml:space="preserve">
            <source>During the command queuing stage, the commands that comprise the transaction are submitted by the client.</source>
            <target state="new">During the command queuing stage, the commands that comprise the transaction are submitted by the client.</target>
          </trans-unit>
          <trans-unit id="498" xml:space="preserve">
            <source>If some sort of error occurs at this point (such as a syntax error, or the wrong number of parameters) then Redis will refuse to process the entire transaction and discard it.</source>
            <target state="new">If some sort of error occurs at this point (such as a syntax error, or the wrong number of parameters) then Redis will refuse to process the entire transaction and discard it.</target>
          </trans-unit>
          <trans-unit id="499" xml:space="preserve">
            <source>During the execution phase, Redis performs each queued command in sequence.</source>
            <target state="new">During the execution phase, Redis performs each queued command in sequence.</target>
          </trans-unit>
          <trans-unit id="500" xml:space="preserve">
            <source>If a command fails during this phase Redis will continue with the next queued command and it does not roll back the effects of any commands that have already been executed.</source>
            <target state="new">If a command fails during this phase Redis will continue with the next queued command and it does not roll back the effects of any commands that have already been executed.</target>
          </trans-unit>
          <trans-unit id="501" xml:space="preserve">
            <source>This simplified form of transaction helps to maintain performance and avoid performance problems caused by contention.</source>
            <target state="new">This simplified form of transaction helps to maintain performance and avoid performance problems caused by contention.</target>
          </trans-unit>
          <trans-unit id="502" xml:space="preserve">
            <source>Redis does implement a form of optimistic locking to assist in maintaining consistency.</source>
            <target state="new">Redis does implement a form of optimistic locking to assist in maintaining consistency.</target>
          </trans-unit>
          <trans-unit id="503" xml:space="preserve">
            <source>For detailed information about transactions and locking with Redis, visit the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>取引ページ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</source>
            <target state="new">For detailed information about transactions and locking with Redis, visit the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>取引ページ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</target>
          </trans-unit>
          <trans-unit id="504" xml:space="preserve">
            <source>Redis では、要求の非トランザクション バッチ処理もサポートしています。Redis サーバーにコマンドを送信するクライアントを使用して Redis プロトコルでは、同じ要求の一部として一連の操作を送信するクライアントをできます。これは、ネットワーク上のパケットの断片化を減らすために助けることができます。バッチを処理すると、各コマンドが実行されます。トランザクションとは異なり、これらのコマンドのいずれかが不正な場合拒否されますが、残りのコマンドが実行されます。また、バッチ内のコマンドが処理される順序の保証はありません。</source>
            <target state="new">Redis では、要求の非トランザクション バッチ処理もサポートしています。Redis サーバーにコマンドを送信するクライアントを使用して Redis プロトコルでは、同じ要求の一部として一連の操作を送信するクライアントをできます。これは、ネットワーク上のパケットの断片化を減らすために助けることができます。バッチを処理すると、各コマンドが実行されます。トランザクションとは異なり、これらのコマンドのいずれかが不正な場合拒否されますが、残りのコマンドが実行されます。また、バッチ内のコマンドが処理される順序の保証はありません。</target>
          </trans-unit>
          <trans-unit id="505" xml:space="preserve">
            <source>Redis セキュリティ</source>
            <target state="new">Redis セキュリティ</target>
          </trans-unit>
          <trans-unit id="506" xml:space="preserve">
            <source>Redis は、データへの高速アクセスを提供することに取り組むし、信頼された環境内で実行し、信頼されたクライアントのみがアクセスするように設計。Redis (これは推奨されませんが認証を完全に削除することが可能です) パスワード認証に基づいて制限されたセキュリティ モデルのみをサポートします。すべての認証されたクライアントは、同じグローバル パスワードを共有し、同じリソースへのアクセスがあります。包括的なログインのセキュリティが必要な場合 Redis サーバーの前にあなた自身のセキュリティ レイヤーを実装する必要があります、すべてのクライアント要求が通ればこのレイヤーを追加。Redis いない、信頼されていないまたは認証されていないクライアントに直接公開するべき。</source>
            <target state="new">Redis は、データへの高速アクセスを提供することに取り組むし、信頼された環境内で実行し、信頼されたクライアントのみがアクセスするように設計。Redis (これは推奨されませんが認証を完全に削除することが可能です) パスワード認証に基づいて制限されたセキュリティ モデルのみをサポートします。すべての認証されたクライアントは、同じグローバル パスワードを共有し、同じリソースへのアクセスがあります。包括的なログインのセキュリティが必要な場合 Redis サーバーの前にあなた自身のセキュリティ レイヤーを実装する必要があります、すべてのクライアント要求が通ればこのレイヤーを追加。Redis いない、信頼されていないまたは認証されていないクライアントに直接公開するべき。</target>
          </trans-unit>
          <trans-unit id="507" xml:space="preserve">
            <source>コマンドを無効にすることまたは名前を変更して (とだけ新しい名前と特権クライアントを提供する) でアクセスを制限できます。</source>
            <target state="new">コマンドを無効にすることまたは名前を変更して (とだけ新しい名前と特権クライアントを提供する) でアクセスを制限できます。</target>
          </trans-unit>
          <trans-unit id="508" xml:space="preserve">
            <source>Redis は何らかのデータの暗号化、クライアント アプリケーションによってすべてのエンコードを行う必要がありますので直接はサポートしていません。さらに、SSL プロキシを実装する必要がある場合はネットワークを経由するデータを保護する必要がありますので、Redis ではトランスポートのセキュリティの任意のフォームを提供しません。</source>
            <target state="new">Redis は何らかのデータの暗号化、クライアント アプリケーションによってすべてのエンコードを行う必要がありますので直接はサポートしていません。さらに、SSL プロキシを実装する必要がある場合はネットワークを経由するデータを保護する必要がありますので、Redis ではトランスポートのセキュリティの任意のフォームを提供しません。</target>
          </trans-unit>
          <trans-unit id="509" xml:space="preserve">
            <source>詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis セキュリティ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</source>
            <target state="new">詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis セキュリティ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="510" xml:space="preserve">
            <source>[AZURE。メモ] 紺碧 Redis キャッシュ クライアントが接続する際、独自のセキュリティ層を提供します。基になる Redis</source>
            <target state="new">[AZURE。メモ] 紺碧 Redis キャッシュ クライアントが接続する際、独自のセキュリティ層を提供します。基になる Redis</target>
          </trans-unit>
          <trans-unit id="511" xml:space="preserve">
            <source>サーバーはパブリック ネットワークに公開されません。</source>
            <target state="new">サーバーはパブリック ネットワークに公開されません。</target>
          </trans-unit>
          <trans-unit id="512" xml:space="preserve">
            <source>Azure Redis キャッシュを使用</source>
            <target state="new">Azure Redis キャッシュを使用</target>
          </trans-unit>
          <trans-unit id="513" xml:space="preserve">
            <source>Azure Redis キャッシュで Azure のデータ センターにホスト サーバーで実行されている Redis サーバーにアクセスを提供します。それは、アクセス制御とセキュリティ ファサードとして機能します。Azure 管理ポータルを使用して、キャッシュをプロビジョニングすることができます。ポータルは、(プライバシー) の SSL 通信と 250 MB まで、99.9% の可用性の SLA を持つマスターと下位レプリケーション レプリケーション (可用性保証のない) 共有ハードウェア上で実行することがなくキャッシュをサポートする専用のサービスとして実行されている 53 GB キャッシュに至る、定義済みの構成の数を提供します。</source>
            <target state="new">Azure Redis キャッシュで Azure のデータ センターにホスト サーバーで実行されている Redis サーバーにアクセスを提供します。それは、アクセス制御とセキュリティ ファサードとして機能します。Azure 管理ポータルを使用して、キャッシュをプロビジョニングすることができます。ポータルは、(プライバシー) の SSL 通信と 250 MB まで、99.9% の可用性の SLA を持つマスターと下位レプリケーション レプリケーション (可用性保証のない) 共有ハードウェア上で実行することがなくキャッシュをサポートする専用のサービスとして実行されている 53 GB キャッシュに至る、定義済みの構成の数を提供します。</target>
          </trans-unit>
          <trans-unit id="514" xml:space="preserve">
            <source>Azure 管理ポータルを使用しても、キャッシュの削除ポリシーを構成して提供ロールにユーザーを追加するキャッシュへのアクセスを制御所有者、寄稿者、読者。これらのロールのメンバーが実行できる操作を定義します。たとえば、所有者ロールのメンバー (セキュリティを含む) キャッシュとその内容を完全に制御がある、共同作成者ロールのメンバーが、キャッシュ内で情報を読み書きできるし、読者の役割のメンバーのみ、キャッシュからデータを取得できます。</source>
            <target state="new">Azure 管理ポータルを使用しても、キャッシュの削除ポリシーを構成して提供ロールにユーザーを追加するキャッシュへのアクセスを制御所有者、寄稿者、読者。これらのロールのメンバーが実行できる操作を定義します。たとえば、所有者ロールのメンバー (セキュリティを含む) キャッシュとその内容を完全に制御がある、共同作成者ロールのメンバーが、キャッシュ内で情報を読み書きできるし、読者の役割のメンバーのみ、キャッシュからデータを取得できます。</target>
          </trans-unit>
          <trans-unit id="515" xml:space="preserve">
            <source>ほとんどの管理タスクは Azure 管理ポータルを通じて実行され、Redis の標準バージョンで使用できる管理コマンドの多くが利用できない場合は、プログラムを使用して、構成を変更する機能を含むため Redis サーバーをシャット ダウン構成追加の奴隷、または強制的にデータをディスクに保存します。</source>
            <target state="new">ほとんどの管理タスクは Azure 管理ポータルを通じて実行され、Redis の標準バージョンで使用できる管理コマンドの多くが利用できない場合は、プログラムを使用して、構成を変更する機能を含むため Redis サーバーをシャット ダウン構成追加の奴隷、または強制的にデータをディスクに保存します。</target>
          </trans-unit>
          <trans-unit id="516" xml:space="preserve">
            <source>The Azure management portal includes a convenient graphical display that enables you to monitor the performance of the cache.</source>
            <target state="new">The Azure management portal includes a convenient graphical display that enables you to monitor the performance of the cache.</target>
          </trans-unit>
          <trans-unit id="517" xml:space="preserve">
            <source>For example, you can view the number of connections being made, the number of requests performed, the volume of reads and writes, and the number of cache hits versus cache misses.</source>
            <target state="new">For example, you can view the number of connections being made, the number of requests performed, the volume of reads and writes, and the number of cache hits versus cache misses.</target>
          </trans-unit>
          <trans-unit id="518" xml:space="preserve">
            <source>Using this information you can determine the effectiveness of the cache and if necessary switch to a different configuration or change the eviction policy.</source>
            <target state="new">Using this information you can determine the effectiveness of the cache and if necessary switch to a different configuration or change the eviction policy.</target>
          </trans-unit>
          <trans-unit id="519" xml:space="preserve">
            <source>Additionally, you can create alerts that send email messages to an administrator if one or more critical metrics fall outside of an expected range.</source>
            <target state="new">Additionally, you can create alerts that send email messages to an administrator if one or more critical metrics fall outside of an expected range.</target>
          </trans-unit>
          <trans-unit id="520" xml:space="preserve">
            <source>For example, if the number of cache misses exceeds a specified value in the last hour, an administrator could be alerted as the cache may be too small or data may be being evicted too quickly.</source>
            <target state="new">For example, if the number of cache misses exceeds a specified value in the last hour, an administrator could be alerted as the cache may be too small or data may be being evicted too quickly.</target>
          </trans-unit>
          <trans-unit id="521" xml:space="preserve">
            <source>CPU、メモリ、およびキャッシュのネットワーク使用率を監視することも。</source>
            <target state="new">CPU、メモリ、およびキャッシュのネットワーク使用率を監視することも。</target>
          </trans-unit>
          <trans-unit id="522" xml:space="preserve">
            <source>[AZURE。メモ] 紺碧 Redis キャッシュのデータベースではなくキャッシュとして純粋に行動するものです。その結果、現在 Redis の永続化を実装しません。</source>
            <target state="new">[AZURE。メモ] 紺碧 Redis キャッシュのデータベースではなくキャッシュとして純粋に行動するものです。その結果、現在 Redis の永続化を実装しません。</target>
          </trans-unit>
          <trans-unit id="523" xml:space="preserve">
            <source>詳細については、作成し、Azure Redis のキャッシュを構成する方法を示す例を参照してくださいページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧 Redis キャッシュの周りにラップ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 紺碧のブログ。</source>
            <target state="new">詳細については、作成し、Azure Redis のキャッシュを構成する方法を示す例を参照してくださいページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧 Redis キャッシュの周りにラップ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 紺碧のブログ。</target>
          </trans-unit>
          <trans-unit id="524" xml:space="preserve">
            <source>キャッシュ セッション状態と HTML 出力</source>
            <target state="new">キャッシュ セッション状態と HTML 出力</target>
          </trans-unit>
          <trans-unit id="525" xml:space="preserve">
            <source>Azure の web ロールを使用して実行すると、保存できることセッション状態情報と HTML 出力の Azure Redis キャッシュ内のアプリケーションを web ASP.NET を構築するかどうか。Azure Redis キャッシュ セッション状態プロバイダーは、ASP.NET web アプリケーションの異なるインスタンス間でセッション情報を共有することができます、クライアント-サーバ アフィニティが使用できないし、セッション データをメモリ内のキャッシュは適切でない web ファーム場合に非常に便利です。</source>
            <target state="new">Azure の web ロールを使用して実行すると、保存できることセッション状態情報と HTML 出力の Azure Redis キャッシュ内のアプリケーションを web ASP.NET を構築するかどうか。Azure Redis キャッシュ セッション状態プロバイダーは、ASP.NET web アプリケーションの異なるインスタンス間でセッション情報を共有することができます、クライアント-サーバ アフィニティが使用できないし、セッション データをメモリ内のキャッシュは適切でない web ファーム場合に非常に便利です。</target>
          </trans-unit>
          <trans-unit id="526" xml:space="preserve">
            <source>Azure Redis キャッシュ提供のセッション状態プロバイダーを使用してを含むいくつかの利点。</source>
            <target state="new">Azure Redis キャッシュ提供のセッション状態プロバイダーを使用してを含むいくつかの利点。</target>
          </trans-unit>
          <trans-unit id="527" xml:space="preserve">
            <source>それは多数のスケーラビリティの向上を提供する、ASP.NET web アプリケーションのインスタンス間でセッション状態を共有できます。</source>
            <target state="new">それは多数のスケーラビリティの向上を提供する、ASP.NET web アプリケーションのインスタンス間でセッション状態を共有できます。</target>
          </trans-unit>
          <trans-unit id="528" xml:space="preserve">
            <source>複数のリーダーと単一ライターの同じセッション状態データへの制御、同時アクセスをサポートしていて、</source>
            <target state="new">複数のリーダーと単一ライターの同じセッション状態データへの制御、同時アクセスをサポートしていて、</target>
          </trans-unit>
          <trans-unit id="529" xml:space="preserve">
            <source>圧縮を使用してメモリを節約し、ネットワーク パフォーマンスを向上させることできます。</source>
            <target state="new">圧縮を使用してメモリを節約し、ネットワーク パフォーマンスを向上させることできます。</target>
          </trans-unit>
          <trans-unit id="530" xml:space="preserve">
            <source>詳細については"を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の ASP.NET のセッション状態プロバイダーは、キャッシュを Redis します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">詳細については"を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の ASP.NET のセッション状態プロバイダーは、キャッシュを Redis します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="531" xml:space="preserve">
            <source>[AZURE。メモ] Azure 環境の外部で実行する ASP.NET アプリケーションに、Azure Redis キャッシュ セッション状態プロバイダーを使わない。Azure の外部からキャッシュへのアクセスの待機時間は、データ キャッシュのパフォーマンス上の利点をなくすことができます。</source>
            <target state="new">[AZURE。メモ] Azure 環境の外部で実行する ASP.NET アプリケーションに、Azure Redis キャッシュ セッション状態プロバイダーを使わない。Azure の外部からキャッシュへのアクセスの待機時間は、データ キャッシュのパフォーマンス上の利点をなくすことができます。</target>
          </trans-unit>
          <trans-unit id="532" xml:space="preserve">
            <source>同様に、Azure Redis キャッシュに出力キャッシュ プロバイダーは ASP.NET web アプリケーションによって生成される HTTP 応答を保存することができます。複雑な HTML 出力をレンダリングするアプリケーションの応答時間を短縮することができます Azure Redis キャッシュと出力キャッシュ プロバイダーを使用してあらためて出力この HTML を生成するのではなく、キャッシュに共有出力のフラグメントのアプリケーション インスタンスを生成するような反応をすることができますを使用します。 詳細については"を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の ASP.NET 出力キャッシュ プロバイダーは、キャッシュを Redis します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">同様に、Azure Redis キャッシュに出力キャッシュ プロバイダーは ASP.NET web アプリケーションによって生成される HTTP 応答を保存することができます。複雑な HTML 出力をレンダリングするアプリケーションの応答時間を短縮することができます Azure Redis キャッシュと出力キャッシュ プロバイダーを使用してあらためて出力この HTML を生成するのではなく、キャッシュに共有出力のフラグメントのアプリケーション インスタンスを生成するような反応をすることができますを使用します。 詳細については"を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の ASP.NET 出力キャッシュ プロバイダーは、キャッシュを Redis します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="533" xml:space="preserve">
            <source>カスタム Redis キャッシュを構築</source>
            <target state="new">カスタム Redis キャッシュを構築</target>
          </trans-unit>
          <trans-unit id="534" xml:space="preserve">
            <source>The Azure Redis cache acts as a façade to the underlying Redis servers.</source>
            <target state="new">The Azure Redis cache acts as a façade to the underlying Redis servers.</target>
          </trans-unit>
          <trans-unit id="535" xml:space="preserve">
            <source>Currently it supports a fixed set of configurations but does not provide for Redis clustering.</source>
            <target state="new">Currently it supports a fixed set of configurations but does not provide for Redis clustering.</target>
          </trans-unit>
          <trans-unit id="536" xml:space="preserve">
            <source>If you require an advanced configuration that is not covered by the Azure Redis cache (such as a cache bigger than 53GB) you can build and host your own Redis servers by using Azure virtual machines.</source>
            <target state="new">If you require an advanced configuration that is not covered by the Azure Redis cache (such as a cache bigger than 53GB) you can build and host your own Redis servers by using Azure virtual machines.</target>
          </trans-unit>
          <trans-unit id="537" xml:space="preserve">
            <source>This is a potentially complex process as you may need to create several VMs to act as master and subordinate nodes if you want to implement replication.</source>
            <target state="new">This is a potentially complex process as you may need to create several VMs to act as master and subordinate nodes if you want to implement replication.</target>
          </trans-unit>
          <trans-unit id="538" xml:space="preserve">
            <source>Furthermore, if you wish to create a cluster, then you will need multiple masters and subordinate servers; a minimal clustered, replication topology that provides a high degree of availability and scalability comprises at least 6 VMs organized as 3 pairs of master/subordinate servers (a cluster must contain at least 3 master nodes).</source>
            <target state="new">Furthermore, if you wish to create a cluster, then you will need multiple masters and subordinate servers; a minimal clustered, replication topology that provides a high degree of availability and scalability comprises at least 6 VMs organized as 3 pairs of master/subordinate servers (a cluster must contain at least 3 master nodes).</target>
          </trans-unit>
          <trans-unit id="539" xml:space="preserve">
            <source>Each master/subordinate pair should be located close together to minimize latency, but each set of pairs can be running in different Azure datacenters located in different regions if you wish to locate cached data close to the applications that are most likely to use it.</source>
            <target state="new">Each master/subordinate pair should be located close together to minimize latency, but each set of pairs can be running in different Azure datacenters located in different regions if you wish to locate cached data close to the applications that are most likely to use it.</target>
          </trans-unit>
          <trans-unit id="540" xml:space="preserve">
            <source>The page <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CentOS Linux VM 上 Redis で実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトの web サイトの構築し、Azure の VM として実行している Redis ノードを構成する方法を示す例について説明します。</source>
            <target state="new">The page <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CentOS Linux VM 上 Redis で実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトの web サイトの構築し、Azure の VM として実行している Redis ノードを構成する方法を示す例について説明します。</target>
          </trans-unit>
          <trans-unit id="541" xml:space="preserve">
            <source>この方法で Redis キャッシュを実装する場合あなたが監視、管理、およびサービスの保護を担当に注意してください。</source>
            <target state="new">この方法で Redis キャッシュを実装する場合あなたが監視、管理、およびサービスの保護を担当に注意してください。</target>
          </trans-unit>
          <trans-unit id="542" xml:space="preserve">
            <source>Redis キャッシュのパーティション分割</source>
            <target state="new">Redis キャッシュのパーティション分割</target>
          </trans-unit>
          <trans-unit id="543" xml:space="preserve">
            <source>キャッシュをパーティションでは、複数のコンピューターにわたってキャッシュを分割します。この構造体は、いくつかの利点を含む、1 つのキャッシュ サーバーを使用しています。</source>
            <target state="new">キャッシュをパーティションでは、複数のコンピューターにわたってキャッシュを分割します。この構造体は、いくつかの利点を含む、1 つのキャッシュ サーバーを使用しています。</target>
          </trans-unit>
          <trans-unit id="544" xml:space="preserve">
            <source>キャッシュを作成する 1 つのサーバーに格納できるよりもはるかに大きいです。</source>
            <target state="new">キャッシュを作成する 1 つのサーバーに格納できるよりもはるかに大きいです。</target>
          </trans-unit>
          <trans-unit id="545" xml:space="preserve">
            <source>可用性を向上させるサーバ間でデータを配布します。保持するデータのみが利用可能なは 1 つのサーバーが失敗したまたはアクセスできなくなったり、残りのサーバー上のデータをアクセスもできます。キャッシュこのキャッシュされたデータとして重要ななっていないデータの一時的なコピーのみ、データベースに保持されて、アクセスできなくなったサーバー上のキャッシュされたデータを別のサーバーに代わりにキャッシュできます。</source>
            <target state="new">可用性を向上させるサーバ間でデータを配布します。保持するデータのみが利用可能なは 1 つのサーバーが失敗したまたはアクセスできなくなったり、残りのサーバー上のデータをアクセスもできます。キャッシュこのキャッシュされたデータとして重要ななっていないデータの一時的なコピーのみ、データベースに保持されて、アクセスできなくなったサーバー上のキャッシュされたデータを別のサーバーに代わりにキャッシュできます。</target>
          </trans-unit>
          <trans-unit id="546" xml:space="preserve">
            <source>パフォーマンスとスケーラビリティが向上、サーバーに負荷を分散します。</source>
            <target state="new">パフォーマンスとスケーラビリティが向上、サーバーに負荷を分散します。</target>
          </trans-unit>
          <trans-unit id="547" xml:space="preserve">
            <source>Geolocating データ遅延を削減でき、それにアクセスするユーザーの近くに配置。</source>
            <target state="new">Geolocating データ遅延を削減でき、それにアクセスするユーザーの近くに配置。</target>
          </trans-unit>
          <trans-unit id="548" xml:space="preserve">
            <source>パーティション分割の最も一般的な形式は、キャッシュ、シャーディングです。この戦略では、各パーティション (または破片) は、独自の権利で Redis キャッシュです。データは、特定のパーティションにデータを分散するさまざまなアプローチを使用することができます分割ロジックを使用してによって監督されます。、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 分割の実装の詳細を提供します。</source>
            <target state="new">パーティション分割の最も一般的な形式は、キャッシュ、シャーディングです。この戦略では、各パーティション (または破片) は、独自の権利で Redis キャッシュです。データは、特定のパーティションにデータを分散するさまざまなアプローチを使用することができます分割ロジックを使用してによって監督されます。、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 分割の実装の詳細を提供します。</target>
          </trans-unit>
          <trans-unit id="549" xml:space="preserve">
            <source>Redis キャッシュのパーティション分割を実装するには、次の方法のいずれかを採用します。</source>
            <target state="new">Redis キャッシュのパーティション分割を実装するには、次の方法のいずれかを採用します。</target>
          </trans-unit>
          <trans-unit id="550" xml:space="preserve">
            <source><bpt id="1">&lt;em&gt;</bpt>サーバー側のクエリをルーティングします。<ept id="1">&lt;/em&gt;</ept> この手法では、クライアント アプリケーションのいずれかに要求を送信、</source>
            <target state="new"><bpt id="1">&lt;em&gt;</bpt>サーバー側のクエリをルーティングします。<ept id="1">&lt;/em&gt;</ept> この手法では、クライアント アプリケーションのいずれかに要求を送信、</target>
          </trans-unit>
          <trans-unit id="551" xml:space="preserve">
            <source>Redis サーバー キャッシュ (おそらく最も近いサーバー) を構成します。各 Redis サーバー格納します。</source>
            <target state="new">Redis サーバー キャッシュ (おそらく最も近いサーバー) を構成します。各 Redis サーバー格納します。</target>
          </trans-unit>
          <trans-unit id="552" xml:space="preserve">
            <source>それを保持していると、これに関する情報も格納パーティションを記述するメタデータ</source>
            <target state="new">それを保持していると、これに関する情報も格納パーティションを記述するメタデータ</target>
          </trans-unit>
          <trans-unit id="553" xml:space="preserve">
            <source>パーティションは、他のサーバーに配置されます。Redis サーバー クライアント要求を調べ、そして、もしそれ</source>
            <target state="new">パーティションは、他のサーバーに配置されます。Redis サーバー クライアント要求を調べ、そして、もしそれ</target>
          </trans-unit>
          <trans-unit id="554" xml:space="preserve">
            <source>それは要求された操作、それ以外の場合、転送を実行をローカルで解決することができます、</source>
            <target state="new">それは要求された操作、それ以外の場合、転送を実行をローカルで解決することができます、</target>
          </trans-unit>
          <trans-unit id="555" xml:space="preserve">
            <source>適切なサーバーに要求します。このモデルは Redis クラスタ リングによって実装され、</source>
            <target state="new">適切なサーバーに要求します。このモデルは Redis クラスタ リングによって実装され、</target>
          </trans-unit>
          <trans-unit id="556" xml:space="preserve">
            <source>詳細について、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis クラスター チュートリアル<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。Redis クラスタ リング</source>
            <target state="new">詳細について、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis クラスター チュートリアル<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。Redis クラスタ リング</target>
          </trans-unit>
          <trans-unit id="557" xml:space="preserve">
            <source>クライアント アプリケーションは、サーバーをクラスターに追加することができます追加 Redis に対して透過的です。</source>
            <target state="new">クライアント アプリケーションは、サーバーをクラスターに追加することができます追加 Redis に対して透過的です。</target>
          </trans-unit>
          <trans-unit id="558" xml:space="preserve">
            <source>(と再分割データ) クライアントを再構成することを必要とせず。</source>
            <target state="new">(と再分割データ) クライアントを再構成することを必要とせず。</target>
          </trans-unit>
          <trans-unit id="559" xml:space="preserve">
            <source>[AZURE。重要です] 紺碧 Redis キャッシュは現在 Redis のクラスタ リングをサポートしていません。たい場合</source>
            <target state="new">[AZURE。重要です] 紺碧 Redis キャッシュは現在 Redis のクラスタ リングをサポートしていません。たい場合</target>
          </trans-unit>
          <trans-unit id="560" xml:space="preserve">
            <source>このアプローチを実装し、前述のようにカスタム Redis キャッシュを構築する必要があります。</source>
            <target state="new">このアプローチを実装し、前述のようにカスタム Redis キャッシュを構築する必要があります。</target>
          </trans-unit>
          <trans-unit id="561" xml:space="preserve">
            <source><bpt id="1">&lt;em&gt;</bpt>クライアント側のパーティション分割。<ept id="1">&lt;/em&gt;</ept> このモデルでは、クライアント アプリケーションには (おそらくのロジックが含まれています</source>
            <target state="new"><bpt id="1">&lt;em&gt;</bpt>クライアント側のパーティション分割。<ept id="1">&lt;/em&gt;</ept> このモデルでは、クライアント アプリケーションには (おそらくのロジックが含まれています</target>
          </trans-unit>
          <trans-unit id="562" xml:space="preserve">
            <source>ライブラリのフォーム) Redis の適切なサーバーに要求をルーティングします。このアプローチ</source>
            <target state="new">ライブラリのフォーム) Redis の適切なサーバーに要求をルーティングします。このアプローチ</target>
          </trans-unit>
          <trans-unit id="563" xml:space="preserve">
            <source>Azure Redis キャッシュで使用できます。複数 Azure Redis のキャッシュ (1 つ各データの作成します。</source>
            <target state="new">Azure Redis キャッシュで使用できます。複数 Azure Redis のキャッシュ (1 つ各データの作成します。</target>
          </trans-unit>
          <trans-unit id="564" xml:space="preserve">
            <source>パーティション)、要求を適切にルーティング クライアント側ロジックを実装</source>
            <target state="new">パーティション)、要求を適切にルーティング クライアント側ロジックを実装</target>
          </trans-unit>
          <trans-unit id="565" xml:space="preserve">
            <source>キャッシュ。(追加 Azure Redis キャッシュを作成する場合、パーティション構成が変更された場合</source>
            <target state="new">キャッシュ。(追加 Azure Redis キャッシュを作成する場合、パーティション構成が変更された場合</target>
          </trans-unit>
          <trans-unit id="566" xml:space="preserve">
            <source>たとえば)、クライアント アプリケーションを再構成する必要があります。</source>
            <target state="new">たとえば)、クライアント アプリケーションを再構成する必要があります。</target>
          </trans-unit>
          <trans-unit id="567" xml:space="preserve">
            <source><bpt id="1">&lt;em&gt;</bpt>プロキシによる分割します。<ept id="1">&lt;/em&gt;</ept> この方式では、クライアント アプリケーションは、要求を送信します。</source>
            <target state="new"><bpt id="1">&lt;em&gt;</bpt>プロキシによる分割します。<ept id="1">&lt;/em&gt;</ept> この方式では、クライアント アプリケーションは、要求を送信します。</target>
          </trans-unit>
          <trans-unit id="568" xml:space="preserve">
            <source>仲介プロキシ サービス データのパーティション分割方法を理解して、ルート</source>
            <target state="new">仲介プロキシ サービス データのパーティション分割方法を理解して、ルート</target>
          </trans-unit>
          <trans-unit id="569" xml:space="preserve">
            <source>Redis の適切なサーバーに要求します。このアプローチは、Azure で使用もできます。</source>
            <target state="new">Redis の適切なサーバーに要求します。このアプローチは、Azure で使用もできます。</target>
          </trans-unit>
          <trans-unit id="570" xml:space="preserve">
            <source>Redis キャッシュ;プロキシ サービスは、Azure クラウド サービスとして実装することができます。これ</source>
            <target state="new">Redis キャッシュ;プロキシ サービスは、Azure クラウド サービスとして実装することができます。これ</target>
          </trans-unit>
          <trans-unit id="571" xml:space="preserve">
            <source>アプローチはサービスの導入における複雑さの追加レベルを必要とし、</source>
            <target state="new">アプローチはサービスの導入における複雑さの追加レベルを必要とし、</target>
          </trans-unit>
          <trans-unit id="572" xml:space="preserve">
            <source>要求は、クライアント側のパーティション分割を使用するよりも実行に時間がかかります。</source>
            <target state="new">要求は、クライアント側のパーティション分割を使用するよりも実行に時間がかかります。</target>
          </trans-unit>
          <trans-unit id="573" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis の複数のインスタンス間でデータを分割する方法の分割。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept></source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis の複数のインスタンス間でデータを分割する方法の分割。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept></target>
          </trans-unit>
          <trans-unit id="574" xml:space="preserve">
            <source>Redis のウェブサイトは Redis でパーティショニングの実装に関する詳細を提供します。</source>
            <target state="new">Redis のウェブサイトは Redis でパーティショニングの実装に関する詳細を提供します。</target>
          </trans-unit>
          <trans-unit id="575" xml:space="preserve">
            <source>Redis キャッシュ クライアント アプリケーションを実装します。</source>
            <target state="new">Redis キャッシュ クライアント アプリケーションを実装します。</target>
          </trans-unit>
          <trans-unit id="576" xml:space="preserve">
            <source>Redis 多数のプログラミング言語で記述されたクライアント アプリケーションをサポートします。.NET Framework を使用して、新しいアプリケーションを構築する場合は、StackExchange.Redis クライアント ライブラリを使用することをお勧めします。このライブラリは、Redis サーバーへの接続、コマンドの送信と応答の受信の詳細を抽象化する .NET Framework オブジェクト モデルを提供します。NuGet パッケージと Visual Studio で利用可能です。この同じライブラリを使用すると、Azure Redis キャッシュまたは Redis のカスタム キャッシュの vm ホストに接続できます。</source>
            <target state="new">Redis 多数のプログラミング言語で記述されたクライアント アプリケーションをサポートします。.NET Framework を使用して、新しいアプリケーションを構築する場合は、StackExchange.Redis クライアント ライブラリを使用することをお勧めします。このライブラリは、Redis サーバーへの接続、コマンドの送信と応答の受信の詳細を抽象化する .NET Framework オブジェクト モデルを提供します。NuGet パッケージと Visual Studio で利用可能です。この同じライブラリを使用すると、Azure Redis キャッシュまたは Redis のカスタム キャッシュの vm ホストに接続できます。</target>
          </trans-unit>
          <trans-unit id="577" xml:space="preserve">
            <source>静的に使用する Redis サーバーに接続するには <bpt id="2">&lt;code&gt;</bpt>Connect<ept id="2">&lt;/code&gt;</ept> 法、 <bpt id="4">&lt;code&gt;</bpt>ConnectionMultiplexer<ept id="4">&lt;/code&gt;</ept> クラスです。このメソッドが作成する接続は、クライアント アプリケーションの有効期間全体にわたる使用設計されていますおよび複数の並行スレッドで同じ接続を使用することができます。再接続しないし、切断するたび Redis 操作を実行すると、パフォーマンスが低下することができます。アドレス Redis ホストおよび、パスワードなどの接続パラメーターを指定できます。Azure Redis キャッシュを使用する場合はこれがどちらかはパスワード プライマリまたはセカンダリ キーを生成 Azure Redis キャッシュの Azure 管理ポータルを使用しています。</source>
            <target state="new">静的に使用する Redis サーバーに接続するには <bpt id="2">&lt;code&gt;</bpt>Connect<ept id="2">&lt;/code&gt;</ept> 法、 <bpt id="4">&lt;code&gt;</bpt>ConnectionMultiplexer<ept id="4">&lt;/code&gt;</ept> クラスです。このメソッドが作成する接続は、クライアント アプリケーションの有効期間全体にわたる使用設計されていますおよび複数の並行スレッドで同じ接続を使用することができます。再接続しないし、切断するたび Redis 操作を実行すると、パフォーマンスが低下することができます。アドレス Redis ホストおよび、パスワードなどの接続パラメーターを指定できます。Azure Redis キャッシュを使用する場合はこれがどちらかはパスワード プライマリまたはセカンダリ キーを生成 Azure Redis キャッシュの Azure 管理ポータルを使用しています。</target>
          </trans-unit>
          <trans-unit id="578" xml:space="preserve">
            <source>Redis サーバーに接続すると、キャッシュとして機能する Redis データベースのハンドルを取得できます。Redis 接続を提供します、 <bpt id="2">&lt;code&gt;</bpt>GetDatabase<ept id="2">&lt;/code&gt;</ept> これを行う方法。キャッシュから項目を取得し、キャッシュを使用してデータを格納、 <bpt id="4">&lt;code&gt;</bpt>StringGet<ept id="4">&lt;/code&gt;</ept> と <bpt id="6">&lt;code&gt;</bpt>StringSet<ept id="6">&lt;/code&gt;</ept> メソッド。これらのメソッドが要求するパラメーターとしてキーと一致する値 (キャッシュで項目を返すか<bpt id="8">&lt;code&gt;</bpt>StringGet<ept id="8">&lt;/code&gt;</ept>) このキー (キャッシュに項目を追加または<bpt id="10">&lt;code&gt;</bpt>StringSet<ept id="10">&lt;/code&gt;</ept>).</source>
            <target state="new">Redis サーバーに接続すると、キャッシュとして機能する Redis データベースのハンドルを取得できます。Redis 接続を提供します、 <bpt id="2">&lt;code&gt;</bpt>GetDatabase<ept id="2">&lt;/code&gt;</ept> これを行う方法。キャッシュから項目を取得し、キャッシュを使用してデータを格納、 <bpt id="4">&lt;code&gt;</bpt>StringGet<ept id="4">&lt;/code&gt;</ept> と <bpt id="6">&lt;code&gt;</bpt>StringSet<ept id="6">&lt;/code&gt;</ept> メソッド。これらのメソッドが要求するパラメーターとしてキーと一致する値 (キャッシュで項目を返すか<bpt id="8">&lt;code&gt;</bpt>StringGet<ept id="8">&lt;/code&gt;</ept>) このキー (キャッシュに項目を追加または<bpt id="10">&lt;code&gt;</bpt>StringSet<ept id="10">&lt;/code&gt;</ept>).</target>
          </trans-unit>
          <trans-unit id="579" xml:space="preserve">
            <source>Redis サーバーの場所、によって多くの操作がサーバーに要求を送信し、応答がクライアントに返される、いくつかの遅延を負うかもしれない。StackExchange ライブラリは、多くのクライアント アプリケーションの応答性を維持に役立つに公開するメソッドの非同期バージョンを提供します。これらのメソッドをサポートします <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>タスク ベースの非同期パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> .NET framework。</source>
            <target state="new">Redis サーバーの場所、によって多くの操作がサーバーに要求を送信し、応答がクライアントに返される、いくつかの遅延を負うかもしれない。StackExchange ライブラリは、多くのクライアント アプリケーションの応答性を維持に役立つに公開するメソッドの非同期バージョンを提供します。これらのメソッドをサポートします <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>タスク ベースの非同期パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> .NET framework。</target>
          </trans-unit>
          <trans-unit id="580" xml:space="preserve">
            <source>次のコード スニペットは、という名前のメソッドを示しています。 <bpt id="2">&lt;code&gt;</bpt>RetrieveItem<ept id="2">&lt;/code&gt;</ept> Redis と StackExchange ライブラリに基づくキャッシュ アサイド パターンの実装例を示します。メソッドは文字列キー値を受け取り、呼び出して Redis キャッシュから対応する項目を取得しようとすると、 <bpt id="4">&lt;code&gt;</bpt>StringGetAsync<ept id="4">&lt;/code&gt;</ept> メソッド (非同期バージョン <bpt id="6">&lt;code&gt;</bpt>StringGet<ept id="6">&lt;/code&gt;</ept>).使用して基になるデータ ソースからフェッチされる項目がない場合、 <bpt id="8">&lt;code&gt;</bpt>GetItemFromDataSourceAsync<ept id="8">&lt;/code&gt;</ept> (これはローカル メソッドと StackExchange ライブラリの一部ではない) メソッドを使用してキャッシュに追加した、 <bpt id="10">&lt;code&gt;</bpt>StringSetAsync<ept id="10">&lt;/code&gt;</ept> メソッドをそれを取得できますより迅速に次の時間。</source>
            <target state="new">次のコード スニペットは、という名前のメソッドを示しています。 <bpt id="2">&lt;code&gt;</bpt>RetrieveItem<ept id="2">&lt;/code&gt;</ept> Redis と StackExchange ライブラリに基づくキャッシュ アサイド パターンの実装例を示します。メソッドは文字列キー値を受け取り、呼び出して Redis キャッシュから対応する項目を取得しようとすると、 <bpt id="4">&lt;code&gt;</bpt>StringGetAsync<ept id="4">&lt;/code&gt;</ept> メソッド (非同期バージョン <bpt id="6">&lt;code&gt;</bpt>StringGet<ept id="6">&lt;/code&gt;</ept>).使用して基になるデータ ソースからフェッチされる項目がない場合、 <bpt id="8">&lt;code&gt;</bpt>GetItemFromDataSourceAsync<ept id="8">&lt;/code&gt;</ept> (これはローカル メソッドと StackExchange ライブラリの一部ではない) メソッドを使用してキャッシュに追加した、 <bpt id="10">&lt;code&gt;</bpt>StringSetAsync<ept id="10">&lt;/code&gt;</ept> メソッドをそれを取得できますより迅速に次の時間。</target>
          </trans-unit>
          <trans-unit id="581" xml:space="preserve">
            <source>、 <bpt id="2">&lt;code&gt;</bpt>StringGet<ept id="2">&lt;/code&gt;</ept> と <bpt id="4">&lt;code&gt;</bpt>StringSet<ept id="4">&lt;/code&gt;</ept> メソッドで取得または文字列値を格納に制限はありません。任意の項目のバイトの配列としてシリアル化をとることができます。.NET オブジェクトを保存する必要がある場合は、バイト ストリームとしてシリアル化し、キャッシュへの書き込みに StringSet メソッドを使用できます。同様に、StringGet メソッドを使用して、キャッシュからオブジェクトを読み取るし、.NET オブジェクトとしてシリアル化できます。次のコードは、IDatabase インターフェイスの拡張メソッドのセットを示しています (Redis 接続の GetDatabase メソッドを返します、 <bpt id="6">&lt;code&gt;</bpt>IDatabase<ept id="6">&lt;/code&gt;</ept> オブジェクト) とキャッシュに BlogPost オブジェクトを読み書きするこれらのメソッドを使用していくつかのサンプル コード。</source>
            <target state="new">、 <bpt id="2">&lt;code&gt;</bpt>StringGet<ept id="2">&lt;/code&gt;</ept> と <bpt id="4">&lt;code&gt;</bpt>StringSet<ept id="4">&lt;/code&gt;</ept> メソッドで取得または文字列値を格納に制限はありません。任意の項目のバイトの配列としてシリアル化をとることができます。.NET オブジェクトを保存する必要がある場合は、バイト ストリームとしてシリアル化し、キャッシュへの書き込みに StringSet メソッドを使用できます。同様に、StringGet メソッドを使用して、キャッシュからオブジェクトを読み取るし、.NET オブジェクトとしてシリアル化できます。次のコードは、IDatabase インターフェイスの拡張メソッドのセットを示しています (Redis 接続の GetDatabase メソッドを返します、 <bpt id="6">&lt;code&gt;</bpt>IDatabase<ept id="6">&lt;/code&gt;</ept> オブジェクト) とキャッシュに BlogPost オブジェクトを読み書きするこれらのメソッドを使用していくつかのサンプル コード。</target>
          </trans-unit>
          <trans-unit id="582" xml:space="preserve">
            <source>次のコードは、という名前のメソッドを示しています。 <bpt id="2">&lt;code&gt;</bpt>RetrieveBlogPost<ept id="2">&lt;/code&gt;</ept> 読み取りと書き込み、シリアル化可能なこれらの拡張メソッドを使用します。 <bpt id="4">&lt;code&gt;</bpt>BlogPost<ept id="4">&lt;/code&gt;</ept> キャッシュ アサイド パターンに従ってキャッシュするオブジェクト:</source>
            <target state="new">次のコードは、という名前のメソッドを示しています。 <bpt id="2">&lt;code&gt;</bpt>RetrieveBlogPost<ept id="2">&lt;/code&gt;</ept> 読み取りと書き込み、シリアル化可能なこれらの拡張メソッドを使用します。 <bpt id="4">&lt;code&gt;</bpt>BlogPost<ept id="4">&lt;/code&gt;</ept> キャッシュ アサイド パターンに従ってキャッシュするオブジェクト:</target>
          </trans-unit>
          <trans-unit id="583" xml:space="preserve">
            <source>Redis サポート コマンド パイプ ラインの場合、クライアント アプリケーションは、複数の非同期要求を送信します。Redis は、同じ接続を使用してよりもむしろ受信および厳密な順序でコマンドに応答して要求を多重することができます。この方法は、ネットワークをより効率的に使用することによって遅延を減らすのに役立ちます。次のコード スニペットは、同時に 2 人の顧客の詳細を取得する例を示します。このコードは 2 つの要求を送信し、いくつか他の処理を実行 (表示されていません) 結果の受信を待機する前に。キャッシュ オブジェクトの待機メソッドは .NET Framework Task.Wait メソッドに似ています。</source>
            <target state="new">Redis サポート コマンド パイプ ラインの場合、クライアント アプリケーションは、複数の非同期要求を送信します。Redis は、同じ接続を使用してよりもむしろ受信および厳密な順序でコマンドに応答して要求を多重することができます。この方法は、ネットワークをより効率的に使用することによって遅延を減らすのに役立ちます。次のコード スニペットは、同時に 2 人の顧客の詳細を取得する例を示します。このコードは 2 つの要求を送信し、いくつか他の処理を実行 (表示されていません) 結果の受信を待機する前に。キャッシュ オブジェクトの待機メソッドは .NET Framework Task.Wait メソッドに似ています。</target>
          </trans-unit>
          <trans-unit id="584" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧 Redis キャッシュのための開発します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトでは、ウェブサイトは、Azure Redis キャッシュを使用できるクライアント アプリケーションを作成する方法の詳細についてを提供します。追加情報は、 <bpt id="4CapsExtId1">&lt;link&gt;</bpt><bpt id="4CapsExtId2">&lt;linkText&gt;</bpt>基本的な使い方のページ<ept id="4CapsExtId2">&lt;/linkText&gt;</ept><bpt id="4CapsExtId3">&lt;title&gt;</bpt><ept id="4CapsExtId3">&lt;/title&gt;</ept><ept id="4CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis のウェブサイトのページ <bpt id="6CapsExtId1">&lt;link&gt;</bpt><bpt id="6CapsExtId2">&lt;linkText&gt;</bpt>パイプラインおよびマルチプレクサー<ept id="6CapsExtId2">&lt;/linkText&gt;</ept><bpt id="6CapsExtId3">&lt;title&gt;</bpt><ept id="6CapsExtId3">&lt;/title&gt;</ept><ept id="6CapsExtId1">&lt;/link&gt;</ept> 同じ web サイトに非同期操作および Redis StackExchange ライブラリとパイプライン処理の詳細についてを提供します。 このガイダンスで後キャッシュ Redis でユース ケースは、Redis キャッシュで保持されるデータに適用することができますより高度な技術のいくつかの例を説明します。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧 Redis キャッシュのための開発します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトでは、ウェブサイトは、Azure Redis キャッシュを使用できるクライアント アプリケーションを作成する方法の詳細についてを提供します。追加情報は、 <bpt id="4CapsExtId1">&lt;link&gt;</bpt><bpt id="4CapsExtId2">&lt;linkText&gt;</bpt>基本的な使い方のページ<ept id="4CapsExtId2">&lt;/linkText&gt;</ept><bpt id="4CapsExtId3">&lt;title&gt;</bpt><ept id="4CapsExtId3">&lt;/title&gt;</ept><ept id="4CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis のウェブサイトのページ <bpt id="6CapsExtId1">&lt;link&gt;</bpt><bpt id="6CapsExtId2">&lt;linkText&gt;</bpt>パイプラインおよびマルチプレクサー<ept id="6CapsExtId2">&lt;/linkText&gt;</ept><bpt id="6CapsExtId3">&lt;title&gt;</bpt><ept id="6CapsExtId3">&lt;/title&gt;</ept><ept id="6CapsExtId1">&lt;/link&gt;</ept> 同じ web サイトに非同期操作および Redis StackExchange ライブラリとパイプライン処理の詳細についてを提供します。 このガイダンスで後キャッシュ Redis でユース ケースは、Redis キャッシュで保持されるデータに適用することができますより高度な技術のいくつかの例を説明します。</target>
          </trans-unit>
          <trans-unit id="585" xml:space="preserve">
            <source>Redis キャッシュの使用例</source>
            <target state="new">Redis キャッシュの使用例</target>
          </trans-unit>
          <trans-unit id="586" xml:space="preserve">
            <source>The simplest use of Redis for caching concerns storing key/value pairs where the value is an uninterpreted string of arbitrary length that can contain any binary data (it is essentially  an array of bytes that can be treated as a string).</source>
            <target state="new">The simplest use of Redis for caching concerns storing key/value pairs where the value is an uninterpreted string of arbitrary length that can contain any binary data (it is essentially  an array of bytes that can be treated as a string).</target>
          </trans-unit>
          <trans-unit id="587" xml:space="preserve">
            <source>This scenario was illustrated in the section Implementing Redis Cache Client Applications earlier in this guidance.</source>
            <target state="new">This scenario was illustrated in the section Implementing Redis Cache Client Applications earlier in this guidance.</target>
          </trans-unit>
          <trans-unit id="588" xml:space="preserve">
            <source>You should note that keys also contain uninterpreted data, so you can use any binary information as the key, although the longer the key is the more space it will take to store, and the longer it will take to perform lookup operations.</source>
            <target state="new">You should note that keys also contain uninterpreted data, so you can use any binary information as the key, although the longer the key is the more space it will take to store, and the longer it will take to perform lookup operations.</target>
          </trans-unit>
          <trans-unit id="589" xml:space="preserve">
            <source>For usability and ease of maintenance design your keyspace carefully and use meaningful (but not verbose) keys.</source>
            <target state="new">For usability and ease of maintenance design your keyspace carefully and use meaningful (but not verbose) keys.</target>
          </trans-unit>
          <trans-unit id="590" xml:space="preserve">
            <source>For example, use structured keys such as "customer:100" to represent the key for the customer with ID 100 rather than simply "100".</source>
            <target state="new">For example, use structured keys such as "customer:100" to represent the key for the customer with ID 100 rather than simply "100".</target>
          </trans-unit>
          <trans-unit id="591" xml:space="preserve">
            <source>This scheme enables you to easily distinguish between values that store different data types.</source>
            <target state="new">This scheme enables you to easily distinguish between values that store different data types.</target>
          </trans-unit>
          <trans-unit id="592" xml:space="preserve">
            <source>For example, you could also use the key "orders:100" to represent the key for the order with ID 100.</source>
            <target state="new">For example, you could also use the key "orders:100" to represent the key for the order with ID 100.</target>
          </trans-unit>
          <trans-unit id="593" xml:space="preserve">
            <source>バイナリ文字列は 1 次元から離れて Redis のキー/値ペア内の値はより構造化されたリストを含む情報 (ソートし、ソートなし) を設定しますとハッシュも保持できます。これらのコマンドの多くは redis これらのタイプを操作することができます包括的なコマンド セットを提供します、StackExchange などのクライアント ライブラリを .NET Framework アプリケーションで使用できます。ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis データ型および抽象化の導入<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイトは、これらの種類とそれらを操作するために使用できるコマンドの詳細な概要を提供します。</source>
            <target state="new">バイナリ文字列は 1 次元から離れて Redis のキー/値ペア内の値はより構造化されたリストを含む情報 (ソートし、ソートなし) を設定しますとハッシュも保持できます。これらのコマンドの多くは redis これらのタイプを操作することができます包括的なコマンド セットを提供します、StackExchange などのクライアント ライブラリを .NET Framework アプリケーションで使用できます。ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis データ型および抽象化の導入<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイトは、これらの種類とそれらを操作するために使用できるコマンドの詳細な概要を提供します。</target>
          </trans-unit>
          <trans-unit id="594" xml:space="preserve">
            <source>このセクションでは、これらのデータ型やコマンドのいくつかの一般的な使用例をまとめたものです。</source>
            <target state="new">このセクションでは、これらのデータ型やコマンドのいくつかの一般的な使用例をまとめたものです。</target>
          </trans-unit>
          <trans-unit id="595" xml:space="preserve">
            <source>アトミック実行とバッチ処理</source>
            <target state="new">アトミック実行とバッチ処理</target>
          </trans-unit>
          <trans-unit id="596" xml:space="preserve">
            <source>Redis では、文字列の値を取得および設定しますアトミックオペレーションのシリーズをサポートしています。これらの操作は別を使用するときに発生する可能性があります可能なレースの危険性を削除します。 <bpt id="2">&lt;code&gt;</bpt>GET<ept id="2">&lt;/code&gt;</ept> と <bpt id="4">&lt;code&gt;</bpt>SET<ept id="4">&lt;/code&gt;</ept> コマンド。使用可能な操作が含まれます。</source>
            <target state="new">Redis では、文字列の値を取得および設定しますアトミックオペレーションのシリーズをサポートしています。これらの操作は別を使用するときに発生する可能性があります可能なレースの危険性を削除します。 <bpt id="2">&lt;code&gt;</bpt>GET<ept id="2">&lt;/code&gt;</ept> と <bpt id="4">&lt;code&gt;</bpt>SET<ept id="4">&lt;/code&gt;</ept> コマンド。使用可能な操作が含まれます。</target>
          </trans-unit>
          <trans-unit id="597" xml:space="preserve">
            <source><bpt id="1">&lt;code&gt;</bpt>INCR<ept id="1">&lt;/code&gt;</ept>, <bpt id="3">&lt;code&gt;</bpt>INCRBY<ept id="3">&lt;/code&gt;</ept>, <bpt id="5">&lt;code&gt;</bpt>DECR<ept id="5">&lt;/code&gt;</ept>、と <bpt id="7">&lt;code&gt;</bpt>DECRBY<ept id="7">&lt;/code&gt;</ept> インクリメントを実行し操作をデクリメント</source>
            <target state="new"><bpt id="1">&lt;code&gt;</bpt>INCR<ept id="1">&lt;/code&gt;</ept>, <bpt id="3">&lt;code&gt;</bpt>INCRBY<ept id="3">&lt;/code&gt;</ept>, <bpt id="5">&lt;code&gt;</bpt>DECR<ept id="5">&lt;/code&gt;</ept>、と <bpt id="7">&lt;code&gt;</bpt>DECRBY<ept id="7">&lt;/code&gt;</ept> インクリメントを実行し操作をデクリメント</target>
          </trans-unit>
          <trans-unit id="598" xml:space="preserve">
            <source>整数の数値データの値。StackExchange ライブラリのオーバー ロードされたバージョンを提供します、</source>
            <target state="new">整数の数値データの値。StackExchange ライブラリのオーバー ロードされたバージョンを提供します、</target>
          </trans-unit>
          <trans-unit id="599" xml:space="preserve">
            <source><bpt id="1">&lt;code&gt;</bpt>IDatabase.StringIncrementAsync<ept id="1">&lt;/code&gt;</ept> と <bpt id="3">&lt;code&gt;</bpt>IDatabase.StringDecrementAsync<ept id="3">&lt;/code&gt;</ept> 実行するメソッド</source>
            <target state="new"><bpt id="1">&lt;code&gt;</bpt>IDatabase.StringIncrementAsync<ept id="1">&lt;/code&gt;</ept> と <bpt id="3">&lt;code&gt;</bpt>IDatabase.StringDecrementAsync<ept id="3">&lt;/code&gt;</ept> 実行するメソッド</target>
          </trans-unit>
          <trans-unit id="600" xml:space="preserve">
            <source>これらの操作と、キャッシュに格納されている結果値を返します。次のコード</source>
            <target state="new">これらの操作と、キャッシュに格納されている結果値を返します。次のコード</target>
          </trans-unit>
          <trans-unit id="601" xml:space="preserve">
            <source>スニペットは、これらのメソッドを使用する方法を示しています。</source>
            <target state="new">スニペットは、これらのメソッドを使用する方法を示しています。</target>
          </trans-unit>
          <trans-unit id="602" xml:space="preserve">
            <source><bpt id="1">&lt;code&gt;</bpt>GETSET<ept id="1">&lt;/code&gt;</ept> キーに関連付けられている値を取得し、新しい値に変更します。、</source>
            <target state="new"><bpt id="1">&lt;code&gt;</bpt>GETSET<ept id="1">&lt;/code&gt;</ept> キーに関連付けられている値を取得し、新しい値に変更します。、</target>
          </trans-unit>
          <trans-unit id="603" xml:space="preserve">
            <source>StackExchange ライブラリ、この操作を利用できるように、 <bpt id="2">&lt;code&gt;</bpt>IDatabase.StringGetSetAsync<ept id="2">&lt;/code&gt;</ept></source>
            <target state="new">StackExchange ライブラリ、この操作を利用できるように、 <bpt id="2">&lt;code&gt;</bpt>IDatabase.StringGetSetAsync<ept id="2">&lt;/code&gt;</ept></target>
          </trans-unit>
          <trans-unit id="604" xml:space="preserve">
            <source>メソッドです。次のコード スニペットでは、このメソッドの例を示します。このコードを返します現在</source>
            <target state="new">メソッドです。次のコード スニペットでは、このメソッドの例を示します。このコードを返します現在</target>
          </trans-unit>
          <trans-unit id="605" xml:space="preserve">
            <source>値「データ: カウンター」は、前の例のキーに関連付けられている、値をリセットします</source>
            <target state="new">値「データ: カウンター」は、前の例のキーに関連付けられている、値をリセットします</target>
          </trans-unit>
          <trans-unit id="606" xml:space="preserve">
            <source>同じ操作の一部としてすべてのゼロに戻ってこのキー。</source>
            <target state="new">同じ操作の一部としてすべてのゼロに戻ってこのキー。</target>
          </trans-unit>
          <trans-unit id="607" xml:space="preserve">
            <source><bpt id="1">&lt;code&gt;</bpt>MGET<ept id="1">&lt;/code&gt;</ept> と <bpt id="3">&lt;code&gt;</bpt>MSET<ept id="3">&lt;/code&gt;</ept>、返すまたは単一の操作として文字列値のセットを変更できます。、</source>
            <target state="new"><bpt id="1">&lt;code&gt;</bpt>MGET<ept id="1">&lt;/code&gt;</ept> と <bpt id="3">&lt;code&gt;</bpt>MSET<ept id="3">&lt;/code&gt;</ept>、返すまたは単一の操作として文字列値のセットを変更できます。、</target>
          </trans-unit>
          <trans-unit id="608" xml:space="preserve">
            <source><bpt id="1">&lt;code&gt;</bpt>IDatabase.StringGetAsync<ept id="1">&lt;/code&gt;</ept> と <bpt id="3">&lt;code&gt;</bpt>IDatabase.StringSetAsync<ept id="3">&lt;/code&gt;</ept> メソッドはオーバー ロードをサポートするには</source>
            <target state="new"><bpt id="1">&lt;code&gt;</bpt>IDatabase.StringGetAsync<ept id="1">&lt;/code&gt;</ept> と <bpt id="3">&lt;code&gt;</bpt>IDatabase.StringSetAsync<ept id="3">&lt;/code&gt;</ept> メソッドはオーバー ロードをサポートするには</target>
          </trans-unit>
          <trans-unit id="609" xml:space="preserve">
            <source>この機能を使用すると、次の例に示すように:</source>
            <target state="new">この機能を使用すると、次の例に示すように:</target>
          </trans-unit>
          <trans-unit id="610" xml:space="preserve">
            <source>このガイドで Redis トランザクションとバッチのセクションの説明に従っても単一 Redis トランザクションに複数の操作を組み合わせることができます。StackExchange ライブラリは、取引をサポートします <bpt id="2">&lt;code&gt;</bpt>ITransaction<ept id="2">&lt;/code&gt;</ept> インターフェイス。IDatabase.CreateTransaction メソッドを使用して ITransaction オブジェクトを作成でき、提供されるメソッドを使用して、トランザクションにコマンドを呼び出す <bpt id="4">&lt;code&gt;</bpt>ITransaction<ept id="4">&lt;/code&gt;</ept> オブジェクト。、 <bpt id="6">&lt;code&gt;</bpt>ITransaction<ept id="6">&lt;/code&gt;</ept> インターフェイスは、メソッドとしての同じようなセットへのアクセスを提供します、 <bpt id="8">&lt;code&gt;</bpt>IDatabase<ept id="8">&lt;/code&gt;</ept> インターフェイスのすべてのメソッドが非同期です。彼らは、のみ実行、 <bpt id="10">&lt;code&gt;</bpt>ITransaction.Execute<ept id="10">&lt;/code&gt;</ept> メソッドが呼び出されます。Execute メソッドによって返される値は、トランザクションが正常に作成されたかどうかを示す (true) または失敗 (false)。</source>
            <target state="new">このガイドで Redis トランザクションとバッチのセクションの説明に従っても単一 Redis トランザクションに複数の操作を組み合わせることができます。StackExchange ライブラリは、取引をサポートします <bpt id="2">&lt;code&gt;</bpt>ITransaction<ept id="2">&lt;/code&gt;</ept> インターフェイス。IDatabase.CreateTransaction メソッドを使用して ITransaction オブジェクトを作成でき、提供されるメソッドを使用して、トランザクションにコマンドを呼び出す <bpt id="4">&lt;code&gt;</bpt>ITransaction<ept id="4">&lt;/code&gt;</ept> オブジェクト。、 <bpt id="6">&lt;code&gt;</bpt>ITransaction<ept id="6">&lt;/code&gt;</ept> インターフェイスは、メソッドとしての同じようなセットへのアクセスを提供します、 <bpt id="8">&lt;code&gt;</bpt>IDatabase<ept id="8">&lt;/code&gt;</ept> インターフェイスのすべてのメソッドが非同期です。彼らは、のみ実行、 <bpt id="10">&lt;code&gt;</bpt>ITransaction.Execute<ept id="10">&lt;/code&gt;</ept> メソッドが呼び出されます。Execute メソッドによって返される値は、トランザクションが正常に作成されたかどうかを示す (true) または失敗 (false)。</target>
          </trans-unit>
          <trans-unit id="611" xml:space="preserve">
            <source>次のコード スニペットは同じトランザクションの一部としてインクリメントおよびデクリメントします 2 つのカウンターの例を示します。</source>
            <target state="new">次のコード スニペットは同じトランザクションの一部としてインクリメントおよびデクリメントします 2 つのカウンターの例を示します。</target>
          </trans-unit>
          <trans-unit id="612" xml:space="preserve">
            <source>Redis トランザクションがリレーショナル データベースでのトランザクションとは異なりことを覚えてください。Execute メソッドは単に、実行するためのトランザクションを構成するすべてのコマンドをキューし、それらのいずれかが正しくない場合は、トランザクションは中止されます。すべてのコマンドは正常にキューに置かれたが、各コマンドは非同期的に実行されます。任意のコマンドが失敗した場合、他の人はまだ、処理を続行しますコマンドが正常に完了したことを確認する必要がある場合は、上記の例で示すように、対応するタスクの Result プロパティを使用してコマンドの結果をフェッチしなければなりません。プロパティは、タスクが完了するまでブロックされます結果を読み取る。</source>
            <target state="new">Redis トランザクションがリレーショナル データベースでのトランザクションとは異なりことを覚えてください。Execute メソッドは単に、実行するためのトランザクションを構成するすべてのコマンドをキューし、それらのいずれかが正しくない場合は、トランザクションは中止されます。すべてのコマンドは正常にキューに置かれたが、各コマンドは非同期的に実行されます。任意のコマンドが失敗した場合、他の人はまだ、処理を続行しますコマンドが正常に完了したことを確認する必要がある場合は、上記の例で示すように、対応するタスクの Result プロパティを使用してコマンドの結果をフェッチしなければなりません。プロパティは、タスクが完了するまでブロックされます結果を読み取る。</target>
          </trans-unit>
          <trans-unit id="613" xml:space="preserve">
            <source>詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis のトランザクション<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis のウェブサイトのページ。</source>
            <target state="new">詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis のトランザクション<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis のウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="614" xml:space="preserve">
            <source>バッチ操作を実行すると、StackExchange ライブラリの IBatch インタ フェースを使用できます。このインターフェイスは、ことを除いてすべてのメソッドが非同期 IDatabase インターフェイスとして同じような一連のメソッドへのアクセスを提供します。IDatabase.CreateBatch メソッドを使用して、IBatch オブジェクトを作成し、次の例に示すように、IBatch.Execute メソッドを使用して、バッチを実行します。このコードは、単に文字列値とインクリメントおよびデクリメントします前の例で使用される同じカウンターを設定し、結果が表示されます。</source>
            <target state="new">バッチ操作を実行すると、StackExchange ライブラリの IBatch インタ フェースを使用できます。このインターフェイスは、ことを除いてすべてのメソッドが非同期 IDatabase インターフェイスとして同じような一連のメソッドへのアクセスを提供します。IDatabase.CreateBatch メソッドを使用して、IBatch オブジェクトを作成し、次の例に示すように、IBatch.Execute メソッドを使用して、バッチを実行します。このコードは、単に文字列値とインクリメントおよびデクリメントします前の例で使用される同じカウンターを設定し、結果が表示されます。</target>
          </trans-unit>
          <trans-unit id="615" xml:space="preserve">
            <source>それは、トランザクションとは異なり不正な形式だから、バッチ内のコマンドが失敗した場合は他のコマンドがまだ実行を理解することが重要IBatch.Execute メソッドは、成功または失敗の兆候を返しません。</source>
            <target state="new">それは、トランザクションとは異なり不正な形式だから、バッチ内のコマンドが失敗した場合は他のコマンドがまだ実行を理解することが重要IBatch.Execute メソッドは、成功または失敗の兆候を返しません。</target>
          </trans-unit>
          <trans-unit id="616" xml:space="preserve">
            <source>火災を忘れてキャッシュ操作を実行します。</source>
            <target state="new">火災を忘れてキャッシュ操作を実行します。</target>
          </trans-unit>
          <trans-unit id="617" xml:space="preserve">
            <source>Redis は、コマンドのフラグを使用して、火災を忘れて操作をサポートしています。このような状況でクライアントだけ操作を開始、結果に興味を持たないし、コマンドの完了を待機しません。次の例は、火災を忘れて操作として INCR コマンドを実行する方法を示しています。</source>
            <target state="new">Redis は、コマンドのフラグを使用して、火災を忘れて操作をサポートしています。このような状況でクライアントだけ操作を開始、結果に興味を持たないし、コマンドの完了を待機しません。次の例は、火災を忘れて操作として INCR コマンドを実行する方法を示しています。</target>
          </trans-unit>
          <trans-unit id="618" xml:space="preserve">
            <source>自動的にキーの有効期限</source>
            <target state="new">自動的にキーの有効期限</target>
          </trans-unit>
          <trans-unit id="619" xml:space="preserve">
            <source>Redis キャッシュに項目を保存すると、アイテムを後キャッシュから自動的に削除されますがタイムアウトを指定できます。どのように多くの時間、キーを使用して期限切れになる前に検索することも、 <bpt id="2">&lt;code&gt;</bpt>TTL<ept id="2">&lt;/code&gt;</ept> コマンド;このコマンドは、IDatabase.KeyTimeToLive メソッドを使用して StackExchange アプリケーションで利用可能です。</source>
            <target state="new">Redis キャッシュに項目を保存すると、アイテムを後キャッシュから自動的に削除されますがタイムアウトを指定できます。どのように多くの時間、キーを使用して期限切れになる前に検索することも、 <bpt id="2">&lt;code&gt;</bpt>TTL<ept id="2">&lt;/code&gt;</ept> コマンド;このコマンドは、IDatabase.KeyTimeToLive メソッドを使用して StackExchange アプリケーションで利用可能です。</target>
          </trans-unit>
          <trans-unit id="620" xml:space="preserve">
            <source>次のコード スニペットは、キーに 20 秒の有効期限を設定し、キーの残りの有効期間を照会する例を示します。</source>
            <target state="new">次のコード スニペットは、キーに 20 秒の有効期限を設定し、キーの残りの有効期間を照会する例を示します。</target>
          </trans-unit>
          <trans-unit id="621" xml:space="preserve">
            <source>KeyExpireAsync メソッドと StackExchange ライブラリで利用できる有効期限コマンドを使用して特定の日付と時刻に有効期限を設定することもできます。</source>
            <target state="new">KeyExpireAsync メソッドと StackExchange ライブラリで利用できる有効期限コマンドを使用して特定の日付と時刻に有効期限を設定することもできます。</target>
          </trans-unit>
          <trans-unit id="622" xml:space="preserve">
            <source><bpt id="1">&lt;em&gt;</bpt>ヒント:<ept id="1">&lt;/em&gt;</ept> IDatabase.KeyDeleteAsync メソッドと StackExchange ライブラリを介して入手可能です・ デル ・ コマンドを使用してキャッシュからアイテムを手動で削除することができます。</source>
            <target state="new"><bpt id="1">&lt;em&gt;</bpt>ヒント:<ept id="1">&lt;/em&gt;</ept> IDatabase.KeyDeleteAsync メソッドと StackExchange ライブラリを介して入手可能です・ デル ・ コマンドを使用してキャッシュからアイテムを手動で削除することができます。</target>
          </trans-unit>
          <trans-unit id="623" xml:space="preserve">
            <source>タグを使用して、キャッシュされたアイテムを相互に関連付け</source>
            <target state="new">タグを使用して、キャッシュされたアイテムを相互に関連付け</target>
          </trans-unit>
          <trans-unit id="624" xml:space="preserve">
            <source>Redis セットは、1 つのキーを共有する複数の項目のコレクションです。・ サッド コマンドを使用してセットを作成できます。SMEMBERS コマンドを使用して、セット内の項目を取得できます。StackExchange ライブラリは、IDatabase.SetMembersAsync メソッドと IDatabase.SetAddAsync メソッドを介してサッド コマンドと SMEMBERS コマンドを実装します。また SDIFF (差集合)、焼結 (積集合)、および SUNION (和集合) コマンドを使用して新しいセットを作成する既存のセットを組み合わせることができます。StackExchange ライブラリは、IDatabase.SetCombineAsync メソッドでこれらの操作を統一します。このメソッドの最初のパラメーターは、設定操作を実行するを指定します。</source>
            <target state="new">Redis セットは、1 つのキーを共有する複数の項目のコレクションです。・ サッド コマンドを使用してセットを作成できます。SMEMBERS コマンドを使用して、セット内の項目を取得できます。StackExchange ライブラリは、IDatabase.SetMembersAsync メソッドと IDatabase.SetAddAsync メソッドを介してサッド コマンドと SMEMBERS コマンドを実装します。また SDIFF (差集合)、焼結 (積集合)、および SUNION (和集合) コマンドを使用して新しいセットを作成する既存のセットを組み合わせることができます。StackExchange ライブラリは、IDatabase.SetCombineAsync メソッドでこれらの操作を統一します。このメソッドの最初のパラメーターは、設定操作を実行するを指定します。</target>
          </trans-unit>
          <trans-unit id="625" xml:space="preserve">
            <source>次のコード スニペットは、セットが迅速に格納および関連項目のコレクションを取得する便利なことができる方法を表示します。このコードは、セクション Redis キャッシュ クライアント アプリケーションの実装に記述された BlogPost タイプを使用します。BlogPost オブジェクトには、4 つのフィールドが含まれています-ID、タイトル、ランキング スコア、およびタグのコレクション。次の最初のコード スニペットは、BlogPost オブジェクトの c# 一覧の作成に使用するサンプル データを示しています。</source>
            <target state="new">次のコード スニペットは、セットが迅速に格納および関連項目のコレクションを取得する便利なことができる方法を表示します。このコードは、セクション Redis キャッシュ クライアント アプリケーションの実装に記述された BlogPost タイプを使用します。BlogPost オブジェクトには、4 つのフィールドが含まれています-ID、タイトル、ランキング スコア、およびタグのコレクション。次の最初のコード スニペットは、BlogPost オブジェクトの c# 一覧の作成に使用するサンプル データを示しています。</target>
          </trans-unit>
          <trans-unit id="626" xml:space="preserve">
            <source>Redis キャッシュのセットとして BlogPost オブジェクトごとにタグを格納し、BlogPost の ID 各セットに関連付けることができます。これにより、迅速に特定のブログ記事に属するすべてのタグを検索するアプリケーション。逆方向で検索を有効にして、特定のタグを共有しているすべてのブログの記事を検索、ブログの記事を参照キーにタグ ID を保持している別のセットを作成します。</source>
            <target state="new">Redis キャッシュのセットとして BlogPost オブジェクトごとにタグを格納し、BlogPost の ID 各セットに関連付けることができます。これにより、迅速に特定のブログ記事に属するすべてのタグを検索するアプリケーション。逆方向で検索を有効にして、特定のタグを共有しているすべてのブログの記事を検索、ブログの記事を参照キーにタグ ID を保持している別のセットを作成します。</target>
          </trans-unit>
          <trans-unit id="627" xml:space="preserve">
            <source>これらの構造は、多くの一般的なクエリを非常に効率的に実行することができます。たとえば、検索およびすべてのこのようなブログの記事 1 のタグを表示できます。</source>
            <target state="new">これらの構造は、多くの一般的なクエリを非常に効率的に実行することができます。たとえば、検索およびすべてのこのようなブログの記事 1 のタグを表示できます。</target>
          </trans-unit>
          <trans-unit id="628" xml:space="preserve">
            <source>積集合演算を次のように実行することによって 1、ブログ記事 2 を投稿ブログに共通するすべてのタグを検索できます。</source>
            <target state="new">積集合演算を次のように実行することによって 1、ブログ記事 2 を投稿ブログに共通するすべてのタグを検索できます。</target>
          </trans-unit>
          <trans-unit id="629" xml:space="preserve">
            <source>特定のタグが含まれているすべてのブログの記事を見つけることができます。</source>
            <target state="new">特定のタグが含まれているすべてのブログの記事を見つけることができます。</target>
          </trans-unit>
          <trans-unit id="630" xml:space="preserve">
            <source>最近アクセスしたアイテム</source>
            <target state="new">最近アクセスしたアイテム</target>
          </trans-unit>
          <trans-unit id="631" xml:space="preserve">
            <source>A common problem required by many applications is to find the most recently accessed items.</source>
            <target state="new">A common problem required by many applications is to find the most recently accessed items.</target>
          </trans-unit>
          <trans-unit id="632" xml:space="preserve">
            <source>For example, a blogging site might want to display information about the most recently read blog posts.</source>
            <target state="new">For example, a blogging site might want to display information about the most recently read blog posts.</target>
          </trans-unit>
          <trans-unit id="633" xml:space="preserve">
            <source>You can implement this functionality by using a Redis list.</source>
            <target state="new">You can implement this functionality by using a Redis list.</target>
          </trans-unit>
          <trans-unit id="634" xml:space="preserve">
            <source>A Redis list contains multiple items that share the same key, but the list acts as a double-ended queue.</source>
            <target state="new">A Redis list contains multiple items that share the same key, but the list acts as a double-ended queue.</target>
          </trans-unit>
          <trans-unit id="635" xml:space="preserve">
            <source>You can push items on to either end of the list by using the LPUSH (left push) and RPUSH (right push) commands.</source>
            <target state="new">You can push items on to either end of the list by using the LPUSH (left push) and RPUSH (right push) commands.</target>
          </trans-unit>
          <trans-unit id="636" xml:space="preserve">
            <source>You can retrieve items from either end of the list by using the LPOP and RPOP commands.</source>
            <target state="new">You can retrieve items from either end of the list by using the LPOP and RPOP commands.</target>
          </trans-unit>
          <trans-unit id="637" xml:space="preserve">
            <source>You can also return a set of elements by using the LRANGE and RRANGE commands.</source>
            <target state="new">You can also return a set of elements by using the LRANGE and RRANGE commands.</target>
          </trans-unit>
          <trans-unit id="638" xml:space="preserve">
            <source>The code snippets below show how you can perform these operations by using the StackExchange library.</source>
            <target state="new">The code snippets below show how you can perform these operations by using the StackExchange library.</target>
          </trans-unit>
          <trans-unit id="639" xml:space="preserve">
            <source>This code uses the BlogPost type from the previous examples.</source>
            <target state="new">This code uses the BlogPost type from the previous examples.</target>
          </trans-unit>
          <trans-unit id="640" xml:space="preserve">
            <source>As a blog post is read by a user, the title of the blog post is pushed onto a list associated with the key "blog:recent_IDatabase.ListLeftPushAsync 法を用いた Redis キャッシュ"を投稿します。</source>
            <target state="new">As a blog post is read by a user, the title of the blog post is pushed onto a list associated with the key "blog:recent_IDatabase.ListLeftPushAsync 法を用いた Redis キャッシュ"を投稿します。</target>
          </trans-unit>
          <trans-unit id="641" xml:space="preserve">
            <source>多くのブログの記事を読んで、そのタイトルが同じリストにプッシュされます。リストの順序は、追加されていない; 順最も最近のブログ投稿は、リストの左の端の方 (1 回、それ以上は一覧に複数のエントリを持っている同じブログの記事を読む) を読みます。IDatabase.ListRange メソッドを使用して、最も最近読まれた記事のタイトルを表示できます。このメソッドは、リスト、開始点と終了点を含むキーを受け取ります。次のコードは、リストの一番左の端に 10 のブログ記事 (項目 0 から 9 に) のタイトルを取得します。</source>
            <target state="new">多くのブログの記事を読んで、そのタイトルが同じリストにプッシュされます。リストの順序は、追加されていない; 順最も最近のブログ投稿は、リストの左の端の方 (1 回、それ以上は一覧に複数のエントリを持っている同じブログの記事を読む) を読みます。IDatabase.ListRange メソッドを使用して、最も最近読まれた記事のタイトルを表示できます。このメソッドは、リスト、開始点と終了点を含むキーを受け取ります。次のコードは、リストの一番左の端に 10 のブログ記事 (項目 0 から 9 に) のタイトルを取得します。</target>
          </trans-unit>
          <trans-unit id="642" xml:space="preserve">
            <source>ListRangeAsync はリストから項目を削除することに注意してください。これを行うには、IDatabase.ListLeftPopAsync および IDatabase.ListRightPopAsync メソッドを使用できます。</source>
            <target state="new">ListRangeAsync はリストから項目を削除することに注意してください。これを行うには、IDatabase.ListLeftPopAsync および IDatabase.ListRightPopAsync メソッドを使用できます。</target>
          </trans-unit>
          <trans-unit id="643" xml:space="preserve">
            <source>一覧が無限に増大するを防ぐため一覧をトリミングすることによってアイテムを定期的に処分することができます。、下記のコード スニペットは、すべてを削除しますが、5 の一番左のアイテム一覧から。</source>
            <target state="new">一覧が無限に増大するを防ぐため一覧をトリミングすることによってアイテムを定期的に処分することができます。、下記のコード スニペットは、すべてを削除しますが、5 の一番左のアイテム一覧から。</target>
          </trans-unit>
          <trans-unit id="644" xml:space="preserve">
            <source>リーダー ボードの実装</source>
            <target state="new">リーダー ボードの実装</target>
          </trans-unit>
          <trans-unit id="645" xml:space="preserve">
            <source>既定では、セット内のアイテムは任意の特定の順序で保持されません。ZADD コマンド (StackExchange ライブラリ内の IDatabase.SortedSetAdd メソッド) を使用して、順序付けされたセットを作成できます。コマンドへのパラメーターとして提供されるスコアと呼ばれる数値を使用してのオーダーです。次のコード スニペットは、順序付きリストにブログ記事のタイトルを追加します。例では、各ブログの記事は、ブログの記事のランキングを含むスコア フィールドに記入しています。</source>
            <target state="new">既定では、セット内のアイテムは任意の特定の順序で保持されません。ZADD コマンド (StackExchange ライブラリ内の IDatabase.SortedSetAdd メソッド) を使用して、順序付けされたセットを作成できます。コマンドへのパラメーターとして提供されるスコアと呼ばれる数値を使用してのオーダーです。次のコード スニペットは、順序付きリストにブログ記事のタイトルを追加します。例では、各ブログの記事は、ブログの記事のランキングを含むスコア フィールドに記入しています。</target>
          </trans-unit>
          <trans-unit id="646" xml:space="preserve">
            <source>ブログ記事のタイトルと IDatabase.SortedSetRangeByRankWithScores メソッドを使用してスコアを昇順でスコアを取得できます。</source>
            <target state="new">ブログ記事のタイトルと IDatabase.SortedSetRangeByRankWithScores メソッドを使用してスコアを昇順でスコアを取得できます。</target>
          </trans-unit>
          <trans-unit id="647" xml:space="preserve">
            <source>[AZURE。メモ] StackExchange ライブラリには、スコア順にデータを返しますが、スコアを返さない IDatabase.SortedSetRangeByRankAsync メソッドも提供します。</source>
            <target state="new">[AZURE。メモ] StackExchange ライブラリには、スコア順にデータを返しますが、スコアを返さない IDatabase.SortedSetRangeByRankAsync メソッドも提供します。</target>
          </trans-unit>
          <trans-unit id="648" xml:space="preserve">
            <source>またスコアの降順でアイテムを取得し、IDatabase.SortedSetRangeByRankWithScoresAsync メソッドに追加のパラメーターを提供することによって返されるアイテムの数を制限できます。次の例は、タイトルとスコアのトップ 10 ランク付けされたブログの記事を表示します。</source>
            <target state="new">またスコアの降順でアイテムを取得し、IDatabase.SortedSetRangeByRankWithScoresAsync メソッドに追加のパラメーターを提供することによって返されるアイテムの数を制限できます。次の例は、タイトルとスコアのトップ 10 ランク付けされたブログの記事を表示します。</target>
          </trans-unit>
          <trans-unit id="649" xml:space="preserve">
            <source>次の例は、与えられたスコア内に返される項目数を制限するために使用できる IDatabase.SortedSetRangeByScoreWithScoresAsync メソッドを使用して範囲。</source>
            <target state="new">次の例は、与えられたスコア内に返される項目数を制限するために使用できる IDatabase.SortedSetRangeByScoreWithScoresAsync メソッドを使用して範囲。</target>
          </trans-unit>
          <trans-unit id="650" xml:space="preserve">
            <source>チャネルを使用するメッセージング</source>
            <target state="new">チャネルを使用するメッセージング</target>
          </trans-unit>
          <trans-unit id="651" xml:space="preserve">
            <source>データ キャッシュとして機能する高性能パブリッシャー/サブスクライバー メカニズムを介したメッセージング Redis サーバーを提供します。クライアント アプリケーションが、チャネルをサブスクライブすることができ、他のアプリケーションまたはサービスがチャネルにメッセージをパブリッシュできます。サブスクライブしているアプリケーションは、これらのメッセージを受信し、それらを処理できます。</source>
            <target state="new">データ キャッシュとして機能する高性能パブリッシャー/サブスクライバー メカニズムを介したメッセージング Redis サーバーを提供します。クライアント アプリケーションが、チャネルをサブスクライブすることができ、他のアプリケーションまたはサービスがチャネルにメッセージをパブリッシュできます。サブスクライブしているアプリケーションは、これらのメッセージを受信し、それらを処理できます。</target>
          </trans-unit>
          <trans-unit id="652" xml:space="preserve">
            <source>Redis のチャネルにサブスクライブ SUBSCRIBE コマンドを提供します。このコマンドは、1 つ以上のチャネルをアプリケーションで受け入れるメッセージの名を見込んでいます。StackExchange ライブラリには、購読してチャネルにパブリッシュする .NET Framework アプリケーションを可能にする ISubscription インターフェイスが含まれています。Redis サーバーへの接続の GetSubscriber メソッドを使用して、ISubscription オブジェクトを作成し、このオブジェクトの SubscribeAsync メソッドを使用してチャネル メッセージをリッスンし。次のコード例は、「メッセージ: ブログ記事」という名前のチャネルにサブスクライブする方法を示しています。</source>
            <target state="new">Redis のチャネルにサブスクライブ SUBSCRIBE コマンドを提供します。このコマンドは、1 つ以上のチャネルをアプリケーションで受け入れるメッセージの名を見込んでいます。StackExchange ライブラリには、購読してチャネルにパブリッシュする .NET Framework アプリケーションを可能にする ISubscription インターフェイスが含まれています。Redis サーバーへの接続の GetSubscriber メソッドを使用して、ISubscription オブジェクトを作成し、このオブジェクトの SubscribeAsync メソッドを使用してチャネル メッセージをリッスンし。次のコード例は、「メッセージ: ブログ記事」という名前のチャネルにサブスクライブする方法を示しています。</target>
          </trans-unit>
          <trans-unit id="653" xml:space="preserve">
            <source>Subscribe メソッドの最初のパラメーターは、チャネルの名前です。この名前は、キャッシュにあるキーで使用されるのと同じ規則に従います、良好なパフォーマンスと保守性を確保するために比較的短い、意味のある文字列を使用することをお勧めは、任意のバイナリ データを含めることができます。また、チャネルによって使用される名前空間は別に維持するために難しく、アプリケーション コードになるが、チャネルと同じ名前を持つキーを持つことができますので、キー、によって使用されるあることを注意してください。</source>
            <target state="new">Subscribe メソッドの最初のパラメーターは、チャネルの名前です。この名前は、キャッシュにあるキーで使用されるのと同じ規則に従います、良好なパフォーマンスと保守性を確保するために比較的短い、意味のある文字列を使用することをお勧めは、任意のバイナリ データを含めることができます。また、チャネルによって使用される名前空間は別に維持するために難しく、アプリケーション コードになるが、チャネルと同じ名前を持つキーを持つことができますので、キー、によって使用されるあることを注意してください。</target>
          </trans-unit>
          <trans-unit id="654" xml:space="preserve">
            <source>2 番目のパラメーターは、アクション デリゲートです。このデリゲートは、チャネルに新しいメッセージが表示されるたびに非同期的に実行されます。この例は単に (メッセージのブログ投稿のタイトルが含まれます) コンソールにメッセージを表示します。</source>
            <target state="new">2 番目のパラメーターは、アクション デリゲートです。このデリゲートは、チャネルに新しいメッセージが表示されるたびに非同期的に実行されます。この例は単に (メッセージのブログ投稿のタイトルが含まれます) コンソールにメッセージを表示します。</target>
          </trans-unit>
          <trans-unit id="655" xml:space="preserve">
            <source>チャネルにパブリッシュするには、アプリケーションは Redis の発行コマンドを使用できます。StackExchange ライブラリは、この操作を実行するには、IServer.PublishAsync メソッドを提供します。次のコード スニペットは、「メッセージ: ブログ記事"チャネル メッセージをパブリッシュする方法を示しています。</source>
            <target state="new">チャネルにパブリッシュするには、アプリケーションは Redis の発行コマンドを使用できます。StackExchange ライブラリは、この操作を実行するには、IServer.PublishAsync メソッドを提供します。次のコード スニペットは、「メッセージ: ブログ記事"チャネル メッセージをパブリッシュする方法を示しています。</target>
          </trans-unit>
          <trans-unit id="656" xml:space="preserve">
            <source>パブリッシュ/サブスクライブ メカニズムについて理解する必要がありますいくつかのポイントがあります。</source>
            <target state="new">パブリッシュ/サブスクライブ メカニズムについて理解する必要がありますいくつかのポイントがあります。</target>
          </trans-unit>
          <trans-unit id="657" xml:space="preserve">
            <source>複数のサブスクライバーが同じチャネルに購読することができます、彼らはすべてのチャネルにパブリッシュされたメッセージを受け取ります。</source>
            <target state="new">複数のサブスクライバーが同じチャネルに購読することができます、彼らはすべてのチャネルにパブリッシュされたメッセージを受け取ります。</target>
          </trans-unit>
          <trans-unit id="658" xml:space="preserve">
            <source>加入者は、彼らを購読するが後に公開されているメッセージのみを受信します。チャンネルは、バッファリングされていないと Redis インフラストラクチャ メッセージを各サブスクライバーにプッシュし、削除するメッセージを発行します。</source>
            <target state="new">加入者は、彼らを購読するが後に公開されているメッセージのみを受信します。チャンネルは、バッファリングされていないと Redis インフラストラクチャ メッセージを各サブスクライバーにプッシュし、削除するメッセージを発行します。</target>
          </trans-unit>
          <trans-unit id="659" xml:space="preserve">
            <source>既定では、メッセージは送信される順序でサブスクライバーによって受信されます。数が多いと非常にアクティブなシステムで</source>
            <target state="new">既定では、メッセージは送信される順序でサブスクライバーによって受信されます。数が多いと非常にアクティブなシステムで</target>
          </trans-unit>
          <trans-unit id="660" xml:space="preserve">
            <source>メッセージ、多くのサブスクライバーとパブリッシャーの保証されたシーケンシャル メッセージ配信システムのパフォーマンスが低下することができます。場合</source>
            <target state="new">メッセージ、多くのサブスクライバーとパブリッシャーの保証されたシーケンシャル メッセージ配信システムのパフォーマンスが低下することができます。場合</target>
          </trans-unit>
          <trans-unit id="661" xml:space="preserve">
            <source>各メッセージは独立しており、順序が材料 Redis システムを助けることができる並行処理を有効にできます</source>
            <target state="new">各メッセージは独立しており、順序が材料 Redis システムを助けることができる並行処理を有効にできます</target>
          </trans-unit>
          <trans-unit id="662" xml:space="preserve">
            <source>応答性を向上させます。StackExchange クライアントによって使用される接続の PreserveAsyncOrder を設定することによってこれを実現できます。</source>
            <target state="new">応答性を向上させます。StackExchange クライアントによって使用される接続の PreserveAsyncOrder を設定することによってこれを実現できます。</target>
          </trans-unit>
          <trans-unit id="663" xml:space="preserve">
            <source>false にサブスクライバー:</source>
            <target state="new">false にサブスクライバー:</target>
          </trans-unit>
          <trans-unit id="664" xml:space="preserve">
            <source>関連するパターンと指導</source>
            <target state="new">関連するパターンと指導</target>
          </trans-unit>
          <trans-unit id="665" xml:space="preserve">
            <source>次のパターンは、アプリケーションでキャッシュを実装する際のシナリオに関連あります。</source>
            <target state="new">次のパターンは、アプリケーションでキャッシュを実装する際のシナリオに関連あります。</target>
          </trans-unit>
          <trans-unit id="666" xml:space="preserve">
            <source><bpt id="1CapsExtId1">&lt;link&gt;</bpt><bpt id="1CapsExtId2">&lt;linkText&gt;</bpt>キャッシュ アサイド パターン<ept id="1CapsExtId2">&lt;/linkText&gt;</ept><bpt id="1CapsExtId3">&lt;title&gt;</bpt><ept id="1CapsExtId3">&lt;/title&gt;</ept><ept id="1CapsExtId1">&lt;/link&gt;</ept>: このパターンでは、データ ストアからキャッシュに読み込んで、データを要求する方法について説明します。このパターンは、キャッシュに保持されているデータと元のデータ ストア内のデータ間の一貫性を維持するためにも役立ちます。</source>
            <target state="new"><bpt id="1CapsExtId1">&lt;link&gt;</bpt><bpt id="1CapsExtId2">&lt;linkText&gt;</bpt>キャッシュ アサイド パターン<ept id="1CapsExtId2">&lt;/linkText&gt;</ept><bpt id="1CapsExtId3">&lt;title&gt;</bpt><ept id="1CapsExtId3">&lt;/title&gt;</ept><ept id="1CapsExtId1">&lt;/link&gt;</ept>: このパターンでは、データ ストアからキャッシュに読み込んで、データを要求する方法について説明します。このパターンは、キャッシュに保持されているデータと元のデータ ストア内のデータ間の一貫性を維持するためにも役立ちます。</target>
          </trans-unit>
          <trans-unit id="667" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 格納して、大量のデータにアクセスするときのスケーラビリティを向上させる水平パーティション分割の実装について説明します。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 格納して、大量のデータにアクセスするときのスケーラビリティを向上させる水平パーティション分割の実装について説明します。</target>
          </trans-unit>
          <trans-unit id="668" xml:space="preserve">
            <source>詳細については</source>
            <target state="new">詳細については</target>
          </trans-unit>
          <trans-unit id="669" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>MemoryCache クラス<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>MemoryCache クラス<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="670" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Microsoft Azure キャッシュ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Microsoft Azure キャッシュ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="671" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure キャッシュ サービスは私にとって正しいですか。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure キャッシュ サービスは私にとって正しいですか。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="672" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>構成モデル<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>構成モデル<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="673" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>タスク ベースの非同期パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>タスク ベースの非同期パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="674" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>パイプラインおよびマルチプレクサー<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis GitHub レポのページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>パイプラインおよびマルチプレクサー<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis GitHub レポのページ。</target>
          </trans-unit>
          <trans-unit id="675" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>REDIS の永続性<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>REDIS の永続性<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="676" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>レプリケーション ページ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>レプリケーション ページ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</target>
          </trans-unit>
          <trans-unit id="677" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis クラスター チュートリアル<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis クラスター チュートリアル<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="678" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis の複数のインスタンス間でデータを分割する方法の分割。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis の複数のインスタンス間でデータを分割する方法の分割。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="679" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>LRU キャッシュとして Redis を使用してください。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>LRU キャッシュとして Redis を使用してください。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</target>
          </trans-unit>
          <trans-unit id="680" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>取引ページ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>取引ページ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</target>
          </trans-unit>
          <trans-unit id="681" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis セキュリティ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis セキュリティ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="682" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧 Redis キャッシュの周りにラップ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 紺碧のブログ。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧 Redis キャッシュの周りにラップ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 紺碧のブログ。</target>
          </trans-unit>
          <trans-unit id="683" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis CentOS Linux VM 上で実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイトに azure。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis CentOS Linux VM 上で実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイトに azure。</target>
          </trans-unit>
          <trans-unit id="684" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の ASP.NET のセッション状態プロバイダーは、キャッシュを Redis します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の ASP.NET のセッション状態プロバイダーは、キャッシュを Redis します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="685" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の ASP.NET 出力キャッシュ プロバイダーは、キャッシュを Redis します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の ASP.NET 出力キャッシュ プロバイダーは、キャッシュを Redis します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="686" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧 Redis キャッシュのための開発します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 紺碧のサイトです。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧 Redis キャッシュのための開発します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 紺碧のサイトです。</target>
          </trans-unit>
          <trans-unit id="687" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis データ型および抽象化の導入<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis データ型および抽象化の導入<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイト。</target>
          </trans-unit>
          <trans-unit id="688" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>基本的な使用法<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis のウェブサイトのページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>基本的な使用法<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis のウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="689" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis のトランザクション<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis レポのページ。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis のトランザクション<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> StackExchange.Redis レポのページ。</target>
          </trans-unit>
          <trans-unit id="690" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データ パーティション分割ガイド<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データ パーティション分割ガイド<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>