<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="pl-pl" original="2/20/2016 10:03:56 PM" tool-id="MarkdownTransformer" product-name="N/A" product-version="N/A" build-num="1">
    <header>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">38d08d5f0777c92425e4a083fce57a802fbb42d5</xliffext:olfilehash>
      <tool tool-id="MarkdownTransformer" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
    </header>
    <body>
      <group extype="content">
        <group id="101">
          <trans-unit id="101" xml:space="preserve">
            <source>Table design in SQL Data Warehouse | Microsoft Azure</source>
            <target state="new">Table design in SQL Data Warehouse | Microsoft Azure</target>
          </trans-unit>
          <trans-unit id="102" xml:space="preserve">
            <source>Tips for designing tables in Azure SQL Data Warehouse for developing solutions.</source>
            <target state="new">Tips for designing tables in Azure SQL Data Warehouse for developing solutions.</target>
          </trans-unit>
          <trans-unit id="103" xml:space="preserve">
            <source>Table design in SQL Data Warehouse</source>
            <target state="new">Table design in SQL Data Warehouse</target>
          </trans-unit>
          <trans-unit id="104" xml:space="preserve">
            <source>SQL Data Warehouse is a massively parallel processing (MPP) distributed database system.</source>
            <target state="new">SQL Data Warehouse is a massively parallel processing (MPP) distributed database system.</target>
          </trans-unit>
          <trans-unit id="105" xml:space="preserve">
            <source>Consequently, it stores data across many different locations known as <bpt id="2">&lt;strong&gt;</bpt>distributions<ept id="2">&lt;/strong&gt;</ept>.</source>
            <target state="new">Consequently, it stores data across many different locations known as <bpt id="2">&lt;strong&gt;</bpt>distributions<ept id="2">&lt;/strong&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="106" xml:space="preserve">
            <source>Each <bpt id="2">&lt;strong&gt;</bpt>distribution<ept id="2">&lt;/strong&gt;</ept> is like a bucket; storing a unique subset of the data in the data warehouse.</source>
            <target state="new">Each <bpt id="2">&lt;strong&gt;</bpt>distribution<ept id="2">&lt;/strong&gt;</ept> is like a bucket; storing a unique subset of the data in the data warehouse.</target>
          </trans-unit>
          <trans-unit id="107" xml:space="preserve">
            <source>By spreading the data and processing capability across multiple nodes SQL Data Warehouse is able to offer huge scalability - far beyond any single system.</source>
            <target state="new">By spreading the data and processing capability across multiple nodes SQL Data Warehouse is able to offer huge scalability - far beyond any single system.</target>
          </trans-unit>
          <trans-unit id="108" xml:space="preserve">
            <source>When a table is created in SQL Data Warehouse, it is actually spread across all of the the distributions.</source>
            <target state="new">When a table is created in SQL Data Warehouse, it is actually spread across all of the the distributions.</target>
          </trans-unit>
          <trans-unit id="109" xml:space="preserve">
            <source>This article will cover the following topics:</source>
            <target state="new">This article will cover the following topics:</target>
          </trans-unit>
          <trans-unit id="110" xml:space="preserve">
            <source>Supported data types</source>
            <target state="new">Supported data types</target>
          </trans-unit>
          <trans-unit id="111" xml:space="preserve">
            <source>Principles of data distribution</source>
            <target state="new">Principles of data distribution</target>
          </trans-unit>
          <trans-unit id="112" xml:space="preserve">
            <source>Round Robin Distribution</source>
            <target state="new">Round Robin Distribution</target>
          </trans-unit>
          <trans-unit id="113" xml:space="preserve">
            <source>Hash Distribution</source>
            <target state="new">Hash Distribution</target>
          </trans-unit>
          <trans-unit id="114" xml:space="preserve">
            <source>Table Partitioning</source>
            <target state="new">Table Partitioning</target>
          </trans-unit>
          <trans-unit id="115" xml:space="preserve">
            <source>Statistics</source>
            <target state="new">Statistics</target>
          </trans-unit>
          <trans-unit id="116" xml:space="preserve">
            <source>Unsupported features</source>
            <target state="new">Unsupported features</target>
          </trans-unit>
          <trans-unit id="117" xml:space="preserve">
            <source>Supported data types</source>
            <target state="new">Supported data types</target>
          </trans-unit>
          <trans-unit id="118" xml:space="preserve">
            <source>SQL Data Warehouse supports the common business data types:</source>
            <target state="new">SQL Data Warehouse supports the common business data types:</target>
          </trans-unit>
          <trans-unit id="119" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>bigint<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>bigint<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="120" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>binary<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>binary<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="121" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>bit<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>bit<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="122" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>char<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>char<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="123" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>date<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>date<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="124" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>datetime<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>datetime<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="125" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>datetime2<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>datetime2<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="126" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>datetimeoffset<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>datetimeoffset<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="127" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>decimal<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>decimal<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="128" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>float<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>float<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="129" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>int<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>int<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="130" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>money<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>money<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="131" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>nchar<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>nchar<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="132" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>nvarchar<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>nvarchar<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="133" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>real<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>real<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="134" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>smalldatetime<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>smalldatetime<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="135" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>smallint<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>smallint<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="136" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>smallmoney<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>smallmoney<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="137" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>time<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>time<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="138" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>tinyint<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>tinyint<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="139" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>varbinary<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>varbinary<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="140" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>varchar<ept id="1">&lt;/strong&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>varchar<ept id="1">&lt;/strong&gt;</ept></target>
          </trans-unit>
          <trans-unit id="141" xml:space="preserve">
            <source>You can identify columns in your data warehouse that contain incompatible types using the following query:</source>
            <target state="new">You can identify columns in your data warehouse that contain incompatible types using the following query:</target>
          </trans-unit>
          <trans-unit id="142" xml:space="preserve">
            <source>The query includes any user defined data types which are also not supported.</source>
            <target state="new">The query includes any user defined data types which are also not supported.</target>
          </trans-unit>
          <trans-unit id="143" xml:space="preserve">
            <source>If you have unsupported types in your database do not worry.</source>
            <target state="new">If you have unsupported types in your database do not worry.</target>
          </trans-unit>
          <trans-unit id="144" xml:space="preserve">
            <source>Some alternatives you can use instead are proposed below.</source>
            <target state="new">Some alternatives you can use instead are proposed below.</target>
          </trans-unit>
          <trans-unit id="145" xml:space="preserve">
            <source>Instead of:</source>
            <target state="new">Instead of:</target>
          </trans-unit>
          <trans-unit id="146" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>geometry<ept id="1">&lt;/strong&gt;</ept>, use a varbinary type</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>geometry<ept id="1">&lt;/strong&gt;</ept>, use a varbinary type</target>
          </trans-unit>
          <trans-unit id="147" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>geography<ept id="1">&lt;/strong&gt;</ept>, use a varbinary type</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>geography<ept id="1">&lt;/strong&gt;</ept>, use a varbinary type</target>
          </trans-unit>
          <trans-unit id="148" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>hierarchyid<ept id="1">&lt;/strong&gt;</ept>, CLR type not native</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>hierarchyid<ept id="1">&lt;/strong&gt;</ept>, CLR type not native</target>
          </trans-unit>
          <trans-unit id="149" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>image<ept id="1">&lt;/strong&gt;</ept>, <bpt id="3">&lt;strong&gt;</bpt>text<ept id="3">&lt;/strong&gt;</ept>, <bpt id="5">&lt;strong&gt;</bpt>ntext<ept id="5">&lt;/strong&gt;</ept> when text based use varchar/nvarchar (smaller the better)</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>image<ept id="1">&lt;/strong&gt;</ept>, <bpt id="3">&lt;strong&gt;</bpt>text<ept id="3">&lt;/strong&gt;</ept>, <bpt id="5">&lt;strong&gt;</bpt>ntext<ept id="5">&lt;/strong&gt;</ept> when text based use varchar/nvarchar (smaller the better)</target>
          </trans-unit>
          <trans-unit id="150" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>nvarchar(max)<ept id="1">&lt;/strong&gt;</ept>, use varchar(4000) or smaller for better performance</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>nvarchar(max)<ept id="1">&lt;/strong&gt;</ept>, use varchar(4000) or smaller for better performance</target>
          </trans-unit>
          <trans-unit id="151" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>numeric<ept id="1">&lt;/strong&gt;</ept>, use decimal</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>numeric<ept id="1">&lt;/strong&gt;</ept>, use decimal</target>
          </trans-unit>
          <trans-unit id="152" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>sql_variant<ept id="1">&lt;/strong&gt;</ept>, split column into several strongly typed columns</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>sql_variant<ept id="1">&lt;/strong&gt;</ept>, split column into several strongly typed columns</target>
          </trans-unit>
          <trans-unit id="153" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>sysname<ept id="1">&lt;/strong&gt;</ept>, use nvarchar(128)</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>sysname<ept id="1">&lt;/strong&gt;</ept>, use nvarchar(128)</target>
          </trans-unit>
          <trans-unit id="154" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>table<ept id="1">&lt;/strong&gt;</ept>, convert to temporary tables</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>table<ept id="1">&lt;/strong&gt;</ept>, convert to temporary tables</target>
          </trans-unit>
          <trans-unit id="155" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>timestamp<ept id="1">&lt;/strong&gt;</ept>, re-work code to use datetime2 and <bpt id="3">&lt;code&gt;</bpt>CURRENT_TIMESTAMP<ept id="3">&lt;/code&gt;</ept> function.</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>timestamp<ept id="1">&lt;/strong&gt;</ept>, re-work code to use datetime2 and <bpt id="3">&lt;code&gt;</bpt>CURRENT_TIMESTAMP<ept id="3">&lt;/code&gt;</ept> function.</target>
          </trans-unit>
          <trans-unit id="156" xml:space="preserve">
            <source>Note you cannot have current_timestamp as a default constraint and the value will not automatically update.</source>
            <target state="new">Note you cannot have current_timestamp as a default constraint and the value will not automatically update.</target>
          </trans-unit>
          <trans-unit id="157" xml:space="preserve">
            <source>If you need to migrate rowversion values from a timestamp typed column then use BINARY(8) or VARBINARY(8) for NOT NULL or NULL row version values.</source>
            <target state="new">If you need to migrate rowversion values from a timestamp typed column then use BINARY(8) or VARBINARY(8) for NOT NULL or NULL row version values.</target>
          </trans-unit>
          <trans-unit id="158" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>varchar(max)<ept id="1">&lt;/strong&gt;</ept>, use varchar(8000) or smaller for better performance</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>varchar(max)<ept id="1">&lt;/strong&gt;</ept>, use varchar(8000) or smaller for better performance</target>
          </trans-unit>
          <trans-unit id="159" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>uniqueidentifier<ept id="1">&lt;/strong&gt;</ept>, use varbinary(8)</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>uniqueidentifier<ept id="1">&lt;/strong&gt;</ept>, use varbinary(8)</target>
          </trans-unit>
          <trans-unit id="160" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>user defined types<ept id="1">&lt;/strong&gt;</ept>, convert back to their native types where possible</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>user defined types<ept id="1">&lt;/strong&gt;</ept>, convert back to their native types where possible</target>
          </trans-unit>
          <trans-unit id="161" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>xml<ept id="1">&lt;/strong&gt;</ept>, use a varchar(8000) or smaller for better performance - split across columns if needed</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>xml<ept id="1">&lt;/strong&gt;</ept>, use a varchar(8000) or smaller for better performance - split across columns if needed</target>
          </trans-unit>
          <trans-unit id="162" xml:space="preserve">
            <source>Partial support:</source>
            <target state="new">Partial support:</target>
          </trans-unit>
          <trans-unit id="163" xml:space="preserve">
            <source>Default constraints support literals and constants only.</source>
            <target state="new">Default constraints support literals and constants only.</target>
          </trans-unit>
          <trans-unit id="164" xml:space="preserve">
            <source>Non-deterministic expressions or functions, such as <bpt id="2">&lt;code&gt;</bpt>GETDATE()<ept id="2">&lt;/code&gt;</ept> or <bpt id="4">&lt;code&gt;</bpt>CURRENT_TIMESTAMP<ept id="4">&lt;/code&gt;</ept>, are not supported.</source>
            <target state="new">Non-deterministic expressions or functions, such as <bpt id="2">&lt;code&gt;</bpt>GETDATE()<ept id="2">&lt;/code&gt;</ept> or <bpt id="4">&lt;code&gt;</bpt>CURRENT_TIMESTAMP<ept id="4">&lt;/code&gt;</ept>, are not supported.</target>
          </trans-unit>
          <trans-unit id="165" xml:space="preserve">
            <source>Define your tables so that the maximum possible row size, including the full length of variable length columns, does not exceed 32,767 bytes.</source>
            <target state="new">Define your tables so that the maximum possible row size, including the full length of variable length columns, does not exceed 32,767 bytes.</target>
          </trans-unit>
          <trans-unit id="166" xml:space="preserve">
            <source>While you can define a row with variable length data that can exceed this figure, you will not be be able to insert data into the table.</source>
            <target state="new">While you can define a row with variable length data that can exceed this figure, you will not be be able to insert data into the table.</target>
          </trans-unit>
          <trans-unit id="167" xml:space="preserve">
            <source>Also, try to limit the size of your variable length columns for even better throughput for running queries.</source>
            <target state="new">Also, try to limit the size of your variable length columns for even better throughput for running queries.</target>
          </trans-unit>
          <trans-unit id="168" xml:space="preserve">
            <source>Principles of data distribution</source>
            <target state="new">Principles of data distribution</target>
          </trans-unit>
          <trans-unit id="169" xml:space="preserve">
            <source>There are two choices for distributing data in SQL Data Warehouse:</source>
            <target state="new">There are two choices for distributing data in SQL Data Warehouse:</target>
          </trans-unit>
          <trans-unit id="170" xml:space="preserve">
            <source>Distribute data based on hashing values from a single column</source>
            <target state="new">Distribute data based on hashing values from a single column</target>
          </trans-unit>
          <trans-unit id="171" xml:space="preserve">
            <source>Distribute data evenly but randomly</source>
            <target state="new">Distribute data evenly but randomly</target>
          </trans-unit>
          <trans-unit id="172" xml:space="preserve">
            <source>Data distribution is decided at the table level.</source>
            <target state="new">Data distribution is decided at the table level.</target>
          </trans-unit>
          <trans-unit id="173" xml:space="preserve">
            <source>All tables are distributed so you will have the opportunity to make this decision for each table in your SQL Data Warehouse database.</source>
            <target state="new">All tables are distributed so you will have the opportunity to make this decision for each table in your SQL Data Warehouse database.</target>
          </trans-unit>
          <trans-unit id="174" xml:space="preserve">
            <source>The first option is known as <bpt id="2">&lt;strong&gt;</bpt>round-robin<ept id="2">&lt;/strong&gt;</ept> distribution - sometimes known as the random hash.</source>
            <target state="new">The first option is known as <bpt id="2">&lt;strong&gt;</bpt>round-robin<ept id="2">&lt;/strong&gt;</ept> distribution - sometimes known as the random hash.</target>
          </trans-unit>
          <trans-unit id="175" xml:space="preserve">
            <source>You can think of this as the default or fail safe option.</source>
            <target state="new">You can think of this as the default or fail safe option.</target>
          </trans-unit>
          <trans-unit id="176" xml:space="preserve">
            <source>The second option is known as the <bpt id="2">&lt;strong&gt;</bpt>hash<ept id="2">&lt;/strong&gt;</ept> distribution.</source>
            <target state="new">The second option is known as the <bpt id="2">&lt;strong&gt;</bpt>hash<ept id="2">&lt;/strong&gt;</ept> distribution.</target>
          </trans-unit>
          <trans-unit id="177" xml:space="preserve">
            <source>You can consider it an optimized form of data distribution.</source>
            <target state="new">You can consider it an optimized form of data distribution.</target>
          </trans-unit>
          <trans-unit id="178" xml:space="preserve">
            <source>It is preferred where clusters of tables share common joining and/or aggregation criteria.</source>
            <target state="new">It is preferred where clusters of tables share common joining and/or aggregation criteria.</target>
          </trans-unit>
          <trans-unit id="179" xml:space="preserve">
            <source>Round-robin distribution</source>
            <target state="new">Round-robin distribution</target>
          </trans-unit>
          <trans-unit id="180" xml:space="preserve">
            <source>Round-Robin distribution is a method of spreading data as evenly as possible across all distributions.</source>
            <target state="new">Round-Robin distribution is a method of spreading data as evenly as possible across all distributions.</target>
          </trans-unit>
          <trans-unit id="181" xml:space="preserve">
            <source>Buffers containing rows of data are allocated in turn (hence the name round robin) to each distribution.</source>
            <target state="new">Buffers containing rows of data are allocated in turn (hence the name round robin) to each distribution.</target>
          </trans-unit>
          <trans-unit id="182" xml:space="preserve">
            <source>The process is repeated until all data buffers have been allocated.</source>
            <target state="new">The process is repeated until all data buffers have been allocated.</target>
          </trans-unit>
          <trans-unit id="183" xml:space="preserve">
            <source>At no stage is the data sorted or ordered in a round robin distributed table.</source>
            <target state="new">At no stage is the data sorted or ordered in a round robin distributed table.</target>
          </trans-unit>
          <trans-unit id="184" xml:space="preserve">
            <source>A round robin distribution is sometimes called a random hash for this reason.</source>
            <target state="new">A round robin distribution is sometimes called a random hash for this reason.</target>
          </trans-unit>
          <trans-unit id="185" xml:space="preserve">
            <source>The data is simply spread as evenly as possible across the distributions.</source>
            <target state="new">The data is simply spread as evenly as possible across the distributions.</target>
          </trans-unit>
          <trans-unit id="186" xml:space="preserve">
            <source>Below is an example of round robin distributed table:</source>
            <target state="new">Below is an example of round robin distributed table:</target>
          </trans-unit>
          <trans-unit id="187" xml:space="preserve">
            <source>This is also an example of a round robin distributed table:</source>
            <target state="new">This is also an example of a round robin distributed table:</target>
          </trans-unit>
          <trans-unit id="188" xml:space="preserve">
            <source>Notice that the second example above makes no mention of the distribution key.</source>
            <target state="new">Notice that the second example above makes no mention of the distribution key.</target>
          </trans-unit>
          <trans-unit id="189" xml:space="preserve">
            <source>Round Robin is the default and so it is not absolutely required.</source>
            <target state="new">Round Robin is the default and so it is not absolutely required.</target>
          </trans-unit>
          <trans-unit id="190" xml:space="preserve">
            <source>Being explicit however, is considered to be a good practice as ensures that your peers are aware of your intentions when reviewing the table design.</source>
            <target state="new">Being explicit however, is considered to be a good practice as ensures that your peers are aware of your intentions when reviewing the table design.</target>
          </trans-unit>
          <trans-unit id="191" xml:space="preserve">
            <source>This table type is commonly used when there is no obvious key column to hash the data by.</source>
            <target state="new">This table type is commonly used when there is no obvious key column to hash the data by.</target>
          </trans-unit>
          <trans-unit id="192" xml:space="preserve">
            <source>It can also be used by smaller or less significant tables where the movement cost may not be so great.</source>
            <target state="new">It can also be used by smaller or less significant tables where the movement cost may not be so great.</target>
          </trans-unit>
          <trans-unit id="193" xml:space="preserve">
            <source>Loading data into a round robin distributed table tends to be faster than loading into a hash distributed table.</source>
            <target state="new">Loading data into a round robin distributed table tends to be faster than loading into a hash distributed table.</target>
          </trans-unit>
          <trans-unit id="194" xml:space="preserve">
            <source>With a round-robin distributed table there is no need to understand the data or perform the hash prior to loading.</source>
            <target state="new">With a round-robin distributed table there is no need to understand the data or perform the hash prior to loading.</target>
          </trans-unit>
          <trans-unit id="195" xml:space="preserve">
            <source>For this reason Round-Robin tables often make good good loading targets.</source>
            <target state="new">For this reason Round-Robin tables often make good good loading targets.</target>
          </trans-unit>
          <trans-unit id="196" xml:space="preserve">
            <source>When data is round robin distributed the data is allocated to the distribution at the <bpt id="2">&lt;em&gt;</bpt>buffer<ept id="2">&lt;/em&gt;</ept> level.</source>
            <target state="new">When data is round robin distributed the data is allocated to the distribution at the <bpt id="2">&lt;em&gt;</bpt>buffer<ept id="2">&lt;/em&gt;</ept> level.</target>
          </trans-unit>
          <trans-unit id="197" xml:space="preserve">
            <source>Recommendations</source>
            <target state="new">Recommendations</target>
          </trans-unit>
          <trans-unit id="198" xml:space="preserve">
            <source>Consider using Round Robin distribution for your table in the following scenarios:</source>
            <target state="new">Consider using Round Robin distribution for your table in the following scenarios:</target>
          </trans-unit>
          <trans-unit id="199" xml:space="preserve">
            <source>When there is no obvious joining key</source>
            <target state="new">When there is no obvious joining key</target>
          </trans-unit>
          <trans-unit id="200" xml:space="preserve">
            <source>If a candidate hash distribution key is not known</source>
            <target state="new">If a candidate hash distribution key is not known</target>
          </trans-unit>
          <trans-unit id="201" xml:space="preserve">
            <source>If the table does not share a common joining key with other tables</source>
            <target state="new">If the table does not share a common joining key with other tables</target>
          </trans-unit>
          <trans-unit id="202" xml:space="preserve">
            <source>If the join is less significant than other joins in the query</source>
            <target state="new">If the join is less significant than other joins in the query</target>
          </trans-unit>
          <trans-unit id="203" xml:space="preserve">
            <source>When the table is an initial loading table</source>
            <target state="new">When the table is an initial loading table</target>
          </trans-unit>
          <trans-unit id="204" xml:space="preserve">
            <source>Hash distribution</source>
            <target state="new">Hash distribution</target>
          </trans-unit>
          <trans-unit id="205" xml:space="preserve">
            <source>Hash distribution uses an internal function to spread a dataset across the distributions by hashing a single column.</source>
            <target state="new">Hash distribution uses an internal function to spread a dataset across the distributions by hashing a single column.</target>
          </trans-unit>
          <trans-unit id="206" xml:space="preserve">
            <source>When data is hashed there is no explicit order to the data being allocated to a distribution.</source>
            <target state="new">When data is hashed there is no explicit order to the data being allocated to a distribution.</target>
          </trans-unit>
          <trans-unit id="207" xml:space="preserve">
            <source>However, the hash itself is a deterministic process.</source>
            <target state="new">However, the hash itself is a deterministic process.</target>
          </trans-unit>
          <trans-unit id="208" xml:space="preserve">
            <source>This makes the results of the hash predictable.</source>
            <target state="new">This makes the results of the hash predictable.</target>
          </trans-unit>
          <trans-unit id="209" xml:space="preserve">
            <source>For example, hashing an integer column containing the value 10 will always yield the same hash value.</source>
            <target state="new">For example, hashing an integer column containing the value 10 will always yield the same hash value.</target>
          </trans-unit>
          <trans-unit id="210" xml:space="preserve">
            <source>This means that <bpt id="2">&lt;strong&gt;</bpt>*any*<ept id="2">&lt;/strong&gt;</ept> hashed integer column  containing the value 10 would end up being allocated to the same distribution.</source>
            <target state="new">This means that <bpt id="2">&lt;strong&gt;</bpt>*any*<ept id="2">&lt;/strong&gt;</ept> hashed integer column  containing the value 10 would end up being allocated to the same distribution.</target>
          </trans-unit>
          <trans-unit id="211" xml:space="preserve">
            <source>This is true even across tables.</source>
            <target state="new">This is true even across tables.</target>
          </trans-unit>
          <trans-unit id="212" xml:space="preserve">
            <source>The predictability of the hash is extremely important.</source>
            <target state="new">The predictability of the hash is extremely important.</target>
          </trans-unit>
          <trans-unit id="213" xml:space="preserve">
            <source>It means that hash distributing the data can lead to performance improvements when reading data and joining tables together.</source>
            <target state="new">It means that hash distributing the data can lead to performance improvements when reading data and joining tables together.</target>
          </trans-unit>
          <trans-unit id="214" xml:space="preserve">
            <source>As you will see below, hash distribution can be very effective for query optimization.</source>
            <target state="new">As you will see below, hash distribution can be very effective for query optimization.</target>
          </trans-unit>
          <trans-unit id="215" xml:space="preserve">
            <source>This is why it is considered to be an optimized form of data distribution.</source>
            <target state="new">This is why it is considered to be an optimized form of data distribution.</target>
          </trans-unit>
          <trans-unit id="216" xml:space="preserve">
            <source>Remember!</source>
            <target state="new">Remember!</target>
          </trans-unit>
          <trans-unit id="217" xml:space="preserve">
            <source>The hash is not based on the value of the data but rather on the type of the data being hashed.</source>
            <target state="new">The hash is not based on the value of the data but rather on the type of the data being hashed.</target>
          </trans-unit>
          <trans-unit id="218" xml:space="preserve">
            <source>Below is a table that has been hash distributed by ProductKey.</source>
            <target state="new">Below is a table that has been hash distributed by ProductKey.</target>
          </trans-unit>
          <trans-unit id="219" xml:space="preserve">
            <source>When data is hash distributed the data is allocated to the distribution at the row level.</source>
            <target state="new">When data is hash distributed the data is allocated to the distribution at the row level.</target>
          </trans-unit>
          <trans-unit id="220" xml:space="preserve">
            <source>Table partitions</source>
            <target state="new">Table partitions</target>
          </trans-unit>
          <trans-unit id="221" xml:space="preserve">
            <source>Table partitions are supported and easy to define.</source>
            <target state="new">Table partitions are supported and easy to define.</target>
          </trans-unit>
          <trans-unit id="222" xml:space="preserve">
            <source>Example SQL Data Warehouse partitioned <bpt id="2">&lt;code&gt;</bpt>CREATE TABLE<ept id="2">&lt;/code&gt;</ept> command:</source>
            <target state="new">Example SQL Data Warehouse partitioned <bpt id="2">&lt;code&gt;</bpt>CREATE TABLE<ept id="2">&lt;/code&gt;</ept> command:</target>
          </trans-unit>
          <trans-unit id="223" xml:space="preserve">
            <source>Notice that there is no partitioning function or scheme in the definition.</source>
            <target state="new">Notice that there is no partitioning function or scheme in the definition.</target>
          </trans-unit>
          <trans-unit id="224" xml:space="preserve">
            <source>All that is taken care of when the table is created.</source>
            <target state="new">All that is taken care of when the table is created.</target>
          </trans-unit>
          <trans-unit id="225" xml:space="preserve">
            <source>All you have to do is identify the boundary points for the column that is going to be the partitioning key.</source>
            <target state="new">All you have to do is identify the boundary points for the column that is going to be the partitioning key.</target>
          </trans-unit>
          <trans-unit id="226" xml:space="preserve">
            <source>Statistics</source>
            <target state="new">Statistics</target>
          </trans-unit>
          <trans-unit id="227" xml:space="preserve">
            <source>SQL Data Warehouse uses a distributed query optimizer to create the appropriate query plan when users query tables.</source>
            <target state="new">SQL Data Warehouse uses a distributed query optimizer to create the appropriate query plan when users query tables.</target>
          </trans-unit>
          <trans-unit id="228" xml:space="preserve">
            <source>Once created, the query plan provides the strategy and method used by the database to access the data and fulfill the user request.</source>
            <target state="new">Once created, the query plan provides the strategy and method used by the database to access the data and fulfill the user request.</target>
          </trans-unit>
          <trans-unit id="229" xml:space="preserve">
            <source>SQL Data Warehouse's query optimizer is based on cost.</source>
            <target state="new">SQL Data Warehouse's query optimizer is based on cost.</target>
          </trans-unit>
          <trans-unit id="230" xml:space="preserve">
            <source>In other words it compares various options (plans) based on their relative cost and chooses the most efficient plan available to it.</source>
            <target state="new">In other words it compares various options (plans) based on their relative cost and chooses the most efficient plan available to it.</target>
          </trans-unit>
          <trans-unit id="231" xml:space="preserve">
            <source>Consequently, SQL Data Warehouse needs a lot of information to make informed, cost based decisions.</source>
            <target state="new">Consequently, SQL Data Warehouse needs a lot of information to make informed, cost based decisions.</target>
          </trans-unit>
          <trans-unit id="232" xml:space="preserve">
            <source>It holds statistics information about the table (for table size) and in database objects known as <bpt id="2">&lt;code&gt;</bpt>STATISTICS<ept id="2">&lt;/code&gt;</ept>.</source>
            <target state="new">It holds statistics information about the table (for table size) and in database objects known as <bpt id="2">&lt;code&gt;</bpt>STATISTICS<ept id="2">&lt;/code&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="233" xml:space="preserve">
            <source>Statistics are held against single or multiple columns of indexes or tables.</source>
            <target state="new">Statistics are held against single or multiple columns of indexes or tables.</target>
          </trans-unit>
          <trans-unit id="234" xml:space="preserve">
            <source>They provide the cost-based optimizer with important information concerning cardinality and selectivity of values.</source>
            <target state="new">They provide the cost-based optimizer with important information concerning cardinality and selectivity of values.</target>
          </trans-unit>
          <trans-unit id="235" xml:space="preserve">
            <source>This is of particular interest when the optimizer needs to evaluate JOINs, GROUP BY, HAVING and WHERE clauses in a query.</source>
            <target state="new">This is of particular interest when the optimizer needs to evaluate JOINs, GROUP BY, HAVING and WHERE clauses in a query.</target>
          </trans-unit>
          <trans-unit id="236" xml:space="preserve">
            <source>It is therefore very important that the information contained in these statistics objects <bpt id="2">&lt;em&gt;</bpt>accurately<ept id="2">&lt;/em&gt;</ept> reflects the current state of the table.</source>
            <target state="new">It is therefore very important that the information contained in these statistics objects <bpt id="2">&lt;em&gt;</bpt>accurately<ept id="2">&lt;/em&gt;</ept> reflects the current state of the table.</target>
          </trans-unit>
          <trans-unit id="237" xml:space="preserve">
            <source>It is vital to understand that it is the accuracy of the cost that is important.</source>
            <target state="new">It is vital to understand that it is the accuracy of the cost that is important.</target>
          </trans-unit>
          <trans-unit id="238" xml:space="preserve">
            <source>If the statistics accurately reflect the state of the table then plans can be compared for lowest cost.</source>
            <target state="new">If the statistics accurately reflect the state of the table then plans can be compared for lowest cost.</target>
          </trans-unit>
          <trans-unit id="239" xml:space="preserve">
            <source>If they aren't accurate then SQL Data Warehouse may choose the wrong plan.</source>
            <target state="new">If they aren't accurate then SQL Data Warehouse may choose the wrong plan.</target>
          </trans-unit>
          <trans-unit id="240" xml:space="preserve">
            <source>Column-level statistics in SQL Data Warehouse are user-defined.</source>
            <target state="new">Column-level statistics in SQL Data Warehouse are user-defined.</target>
          </trans-unit>
          <trans-unit id="241" xml:space="preserve">
            <source>In other words we have to create them ourselves.</source>
            <target state="new">In other words we have to create them ourselves.</target>
          </trans-unit>
          <trans-unit id="242" xml:space="preserve">
            <source>As we have just learned, this is not something to overlook.</source>
            <target state="new">As we have just learned, this is not something to overlook.</target>
          </trans-unit>
          <trans-unit id="243" xml:space="preserve">
            <source>This is an important difference between SQL Server and SQL Data Warehouse.</source>
            <target state="new">This is an important difference between SQL Server and SQL Data Warehouse.</target>
          </trans-unit>
          <trans-unit id="244" xml:space="preserve">
            <source>SQL Server will automatically create statistics when columns are queried.</source>
            <target state="new">SQL Server will automatically create statistics when columns are queried.</target>
          </trans-unit>
          <trans-unit id="245" xml:space="preserve">
            <source>By default, SQL Server will also automatically update those statistics.</source>
            <target state="new">By default, SQL Server will also automatically update those statistics.</target>
          </trans-unit>
          <trans-unit id="246" xml:space="preserve">
            <source>However, in SQL Data Warehouse statistics need to be created manually and managed manually.</source>
            <target state="new">However, in SQL Data Warehouse statistics need to be created manually and managed manually.</target>
          </trans-unit>
          <trans-unit id="247" xml:space="preserve">
            <source>Recommendations</source>
            <target state="new">Recommendations</target>
          </trans-unit>
          <trans-unit id="248" xml:space="preserve">
            <source>Apply the following recommendations for generating statistics:</source>
            <target state="new">Apply the following recommendations for generating statistics:</target>
          </trans-unit>
          <trans-unit id="249" xml:space="preserve">
            <source>Create Single column statistics on columns used in <bpt id="2">&lt;code&gt;</bpt>WHERE<ept id="2">&lt;/code&gt;</ept>, <bpt id="4">&lt;code&gt;</bpt>JOIN<ept id="4">&lt;/code&gt;</ept>, <bpt id="6">&lt;code&gt;</bpt>GROUP BY<ept id="6">&lt;/code&gt;</ept>, <bpt id="8">&lt;code&gt;</bpt>ORDER BY<ept id="8">&lt;/code&gt;</ept> and <bpt id="10">&lt;code&gt;</bpt>DISTINCT<ept id="10">&lt;/code&gt;</ept> clauses</source>
            <target state="new">Create Single column statistics on columns used in <bpt id="2">&lt;code&gt;</bpt>WHERE<ept id="2">&lt;/code&gt;</ept>, <bpt id="4">&lt;code&gt;</bpt>JOIN<ept id="4">&lt;/code&gt;</ept>, <bpt id="6">&lt;code&gt;</bpt>GROUP BY<ept id="6">&lt;/code&gt;</ept>, <bpt id="8">&lt;code&gt;</bpt>ORDER BY<ept id="8">&lt;/code&gt;</ept> and <bpt id="10">&lt;code&gt;</bpt>DISTINCT<ept id="10">&lt;/code&gt;</ept> clauses</target>
          </trans-unit>
          <trans-unit id="250" xml:space="preserve">
            <source>Generate multi-column statistics on composite clauses</source>
            <target state="new">Generate multi-column statistics on composite clauses</target>
          </trans-unit>
          <trans-unit id="251" xml:space="preserve">
            <source>Update statistics periodically.</source>
            <target state="new">Update statistics periodically.</target>
          </trans-unit>
          <trans-unit id="252" xml:space="preserve">
            <source>Remember that this is not done automatically!</source>
            <target state="new">Remember that this is not done automatically!</target>
          </trans-unit>
          <trans-unit id="253" xml:space="preserve">
            <source>It is common for SQL Server Data Warehouse to rely solely on <bpt id="2">&lt;code&gt;</bpt>AUTOSTATS<ept id="2">&lt;/code&gt;</ept> to keep the column statistics up to date.</source>
            <target state="new">It is common for SQL Server Data Warehouse to rely solely on <bpt id="2">&lt;code&gt;</bpt>AUTOSTATS<ept id="2">&lt;/code&gt;</ept> to keep the column statistics up to date.</target>
          </trans-unit>
          <trans-unit id="254" xml:space="preserve">
            <source>This is not a best practice even for SQL Server data warehouses.</source>
            <target state="new">This is not a best practice even for SQL Server data warehouses.</target>
          </trans-unit>
          <trans-unit id="255" xml:space="preserve">
            <source><bpt id="1">&lt;code&gt;</bpt>AUTOSTATS<ept id="1">&lt;/code&gt;</ept> are triggered by a 20% rate of change which for large fact tables containing millions or billions of rows may not be sufficient.</source>
            <target state="new"><bpt id="1">&lt;code&gt;</bpt>AUTOSTATS<ept id="1">&lt;/code&gt;</ept> are triggered by a 20% rate of change which for large fact tables containing millions or billions of rows may not be sufficient.</target>
          </trans-unit>
          <trans-unit id="256" xml:space="preserve">
            <source>It is therefore always a good idea to keep on top of statistics updates to ensure that the statistics accurately reflect the cardinality of the table.</source>
            <target state="new">It is therefore always a good idea to keep on top of statistics updates to ensure that the statistics accurately reflect the cardinality of the table.</target>
          </trans-unit>
          <trans-unit id="257" xml:space="preserve">
            <source>Unsupported features</source>
            <target state="new">Unsupported features</target>
          </trans-unit>
          <trans-unit id="258" xml:space="preserve">
            <source>SQL Data Warehouse does not use or support these features:</source>
            <target state="new">SQL Data Warehouse does not use or support these features:</target>
          </trans-unit>
          <trans-unit id="259" xml:space="preserve">
            <source>primary keys</source>
            <target state="new">primary keys</target>
          </trans-unit>
          <trans-unit id="260" xml:space="preserve">
            <source>foreign keys</source>
            <target state="new">foreign keys</target>
          </trans-unit>
          <trans-unit id="261" xml:space="preserve">
            <source>check constraints</source>
            <target state="new">check constraints</target>
          </trans-unit>
          <trans-unit id="262" xml:space="preserve">
            <source>unique constraints</source>
            <target state="new">unique constraints</target>
          </trans-unit>
          <trans-unit id="263" xml:space="preserve">
            <source>unique indexes</source>
            <target state="new">unique indexes</target>
          </trans-unit>
          <trans-unit id="264" xml:space="preserve">
            <source>computed columns</source>
            <target state="new">computed columns</target>
          </trans-unit>
          <trans-unit id="265" xml:space="preserve">
            <source>sparse columns</source>
            <target state="new">sparse columns</target>
          </trans-unit>
          <trans-unit id="266" xml:space="preserve">
            <source>user-defined types</source>
            <target state="new">user-defined types</target>
          </trans-unit>
          <trans-unit id="267" xml:space="preserve">
            <source>indexed views</source>
            <target state="new">indexed views</target>
          </trans-unit>
          <trans-unit id="268" xml:space="preserve">
            <source>identities</source>
            <target state="new">identities</target>
          </trans-unit>
          <trans-unit id="269" xml:space="preserve">
            <source>sequences</source>
            <target state="new">sequences</target>
          </trans-unit>
          <trans-unit id="270" xml:space="preserve">
            <source>triggers</source>
            <target state="new">triggers</target>
          </trans-unit>
          <trans-unit id="271" xml:space="preserve">
            <source>synonyms</source>
            <target state="new">synonyms</target>
          </trans-unit>
          <trans-unit id="272" xml:space="preserve">
            <source>Next steps</source>
            <target state="new">Next steps</target>
          </trans-unit>
          <trans-unit id="273" xml:space="preserve">
            <source>For more development tips, see <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>development overview[]<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</source>
            <target state="new">For more development tips, see <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>development overview[]<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>