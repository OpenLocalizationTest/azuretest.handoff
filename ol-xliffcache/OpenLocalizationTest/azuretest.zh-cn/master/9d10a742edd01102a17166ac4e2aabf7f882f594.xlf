<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-cn" original="2/19/2016 5:20:14 PM" tool-id="MarkdownTransformer" product-name="N/A" product-version="N/A" build-num="1">
    <header>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9d10a742edd01102a17166ac4e2aabf7f882f594</xliffext:olfilehash>
      <tool tool-id="MarkdownTransformer" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
    </header>
    <body>
      <group extype="content">
        <group id="101">
          <trans-unit id="101" xml:space="preserve">
            <source>Create table as select (CTAS) in SQL Data Warehouse | Microsoft Azure</source>
            <target state="new">Create table as select (CTAS) in SQL Data Warehouse | Microsoft Azure</target>
          </trans-unit>
          <trans-unit id="102" xml:space="preserve">
            <source>Tips for coding with the create table as select (CTAS) statement in Azure SQL Data Warehouse for developing solutions.</source>
            <target state="new">Tips for coding with the create table as select (CTAS) statement in Azure SQL Data Warehouse for developing solutions.</target>
          </trans-unit>
          <trans-unit id="103" xml:space="preserve">
            <source>Create Table As Select (CTAS) in SQL Data Warehouse</source>
            <target state="new">Create Table As Select (CTAS) in SQL Data Warehouse</target>
          </trans-unit>
          <trans-unit id="104" xml:space="preserve">
            <source>Create table as select or CTAS is one of the most important T-SQL features available.</source>
            <target state="new">Create table as select or CTAS is one of the most important T-SQL features available.</target>
          </trans-unit>
          <trans-unit id="105" xml:space="preserve">
            <source>It is a fully parallelized operation that creates a new table based on the output of a Select statement.</source>
            <target state="new">It is a fully parallelized operation that creates a new table based on the output of a Select statement.</target>
          </trans-unit>
          <trans-unit id="106" xml:space="preserve">
            <source>You can consider it to be a supercharged version of SELECT..INTO if you would like.</source>
            <target state="new">You can consider it to be a supercharged version of SELECT..INTO if you would like.</target>
          </trans-unit>
          <trans-unit id="107" xml:space="preserve">
            <source>CTAS can also be used to work around a number of the unsupported features listed above.</source>
            <target state="new">CTAS can also be used to work around a number of the unsupported features listed above.</target>
          </trans-unit>
          <trans-unit id="108" xml:space="preserve">
            <source>This can often prove to be a win/win situation as not only will your code be compliant but it will often execute faster on SQL Data Warehouse.</source>
            <target state="new">This can often prove to be a win/win situation as not only will your code be compliant but it will often execute faster on SQL Data Warehouse.</target>
          </trans-unit>
          <trans-unit id="109" xml:space="preserve">
            <source>This is as a result of its fully parallelized design.</source>
            <target state="new">This is as a result of its fully parallelized design.</target>
          </trans-unit>
          <trans-unit id="110" xml:space="preserve">
            <source>Try to think "CTAS first".</source>
            <target state="new">Try to think "CTAS first".</target>
          </trans-unit>
          <trans-unit id="111" xml:space="preserve">
            <source>If you think you can solve a problem using CTAS then that is generally the best way to approach it - even if you are writing more data as a result.</source>
            <target state="new">If you think you can solve a problem using CTAS then that is generally the best way to approach it - even if you are writing more data as a result.</target>
          </trans-unit>
          <trans-unit id="112" xml:space="preserve">
            <source>Scenarios that can be worked around with CTAS include:</source>
            <target state="new">Scenarios that can be worked around with CTAS include:</target>
          </trans-unit>
          <trans-unit id="113" xml:space="preserve">
            <source>SELECT..INTO</source>
            <target state="new">SELECT..INTO</target>
          </trans-unit>
          <trans-unit id="114" xml:space="preserve">
            <source>ANSI JOINS on UPDATEs</source>
            <target state="new">ANSI JOINS on UPDATEs</target>
          </trans-unit>
          <trans-unit id="115" xml:space="preserve">
            <source>ANSI JOINs on DELETEs</source>
            <target state="new">ANSI JOINs on DELETEs</target>
          </trans-unit>
          <trans-unit id="116" xml:space="preserve">
            <source>MERGE statement</source>
            <target state="new">MERGE statement</target>
          </trans-unit>
          <trans-unit id="117" xml:space="preserve">
            <source>This document also includes some best practices for when coding with CTAS.</source>
            <target state="new">This document also includes some best practices for when coding with CTAS.</target>
          </trans-unit>
          <trans-unit id="118" xml:space="preserve">
            <source>SELECT..INTO</source>
            <target state="new">SELECT..INTO</target>
          </trans-unit>
          <trans-unit id="119" xml:space="preserve">
            <source>You may find SELECT..INTO appears in a number of places in your solution.</source>
            <target state="new">You may find SELECT..INTO appears in a number of places in your solution.</target>
          </trans-unit>
          <trans-unit id="120" xml:space="preserve">
            <source>An SELECT..INTO example is below:</source>
            <target state="new">An SELECT..INTO example is below:</target>
          </trans-unit>
          <trans-unit id="121" xml:space="preserve">
            <source>To convert this to CTAS is quite straight-forward:</source>
            <target state="new">To convert this to CTAS is quite straight-forward:</target>
          </trans-unit>
          <trans-unit id="122" xml:space="preserve">
            <source>Using CTAS means you can also specify a data distribution preference and optional index the table as well.</source>
            <target state="new">Using CTAS means you can also specify a data distribution preference and optional index the table as well.</target>
          </trans-unit>
          <trans-unit id="123" xml:space="preserve">
            <source>ANSI join replacement for update statements</source>
            <target state="new">ANSI join replacement for update statements</target>
          </trans-unit>
          <trans-unit id="124" xml:space="preserve">
            <source>You may find you have a complex update that joins more than two tables together using ANSI joining syntax to perform the UPDATE or DELETE.</source>
            <target state="new">You may find you have a complex update that joins more than two tables together using ANSI joining syntax to perform the UPDATE or DELETE.</target>
          </trans-unit>
          <trans-unit id="125" xml:space="preserve">
            <source>Imagine you had to update this table:</source>
            <target state="new">Imagine you had to update this table:</target>
          </trans-unit>
          <trans-unit id="126" xml:space="preserve">
            <source>The original query might have looked something like this:</source>
            <target state="new">The original query might have looked something like this:</target>
          </trans-unit>
          <trans-unit id="127" xml:space="preserve">
            <source>As SQL Data Warehouse does not support ANSI joins you cannot copy this code over without changing it slightly.</source>
            <target state="new">As SQL Data Warehouse does not support ANSI joins you cannot copy this code over without changing it slightly.</target>
          </trans-unit>
          <trans-unit id="128" xml:space="preserve">
            <source>You can use a combination of a CTAS and an implicit join to replace this code:</source>
            <target state="new">You can use a combination of a CTAS and an implicit join to replace this code:</target>
          </trans-unit>
          <trans-unit id="129" xml:space="preserve">
            <source>ANSI join replacement for delete statements</source>
            <target state="new">ANSI join replacement for delete statements</target>
          </trans-unit>
          <trans-unit id="130" xml:space="preserve">
            <source>Sometimes the best approach for deleting data is to use CTAS.</source>
            <target state="new">Sometimes the best approach for deleting data is to use CTAS.</target>
          </trans-unit>
          <trans-unit id="131" xml:space="preserve">
            <source>Rather than deleting the data simply select the data you want to keep.</source>
            <target state="new">Rather than deleting the data simply select the data you want to keep.</target>
          </trans-unit>
          <trans-unit id="132" xml:space="preserve">
            <source>This especially true for DELETE statements that use ansi joining syntax as this is not supported on SQL Data Warehouse.</source>
            <target state="new">This especially true for DELETE statements that use ansi joining syntax as this is not supported on SQL Data Warehouse.</target>
          </trans-unit>
          <trans-unit id="133" xml:space="preserve">
            <source>An example of a converted DELETE statement is available below:</source>
            <target state="new">An example of a converted DELETE statement is available below:</target>
          </trans-unit>
          <trans-unit id="134" xml:space="preserve">
            <source>Replace merge statements</source>
            <target state="new">Replace merge statements</target>
          </trans-unit>
          <trans-unit id="135" xml:space="preserve">
            <source>Merge statements can be replaced, at least in part, by using CTAS.</source>
            <target state="new">Merge statements can be replaced, at least in part, by using CTAS.</target>
          </trans-unit>
          <trans-unit id="136" xml:space="preserve">
            <source>You can consolidate the <bpt id="2">&lt;code&gt;</bpt>INSERT<ept id="2">&lt;/code&gt;</ept> and the <bpt id="4">&lt;code&gt;</bpt>UPDATE<ept id="4">&lt;/code&gt;</ept> into a single statement.</source>
            <target state="new">You can consolidate the <bpt id="2">&lt;code&gt;</bpt>INSERT<ept id="2">&lt;/code&gt;</ept> and the <bpt id="4">&lt;code&gt;</bpt>UPDATE<ept id="4">&lt;/code&gt;</ept> into a single statement.</target>
          </trans-unit>
          <trans-unit id="137" xml:space="preserve">
            <source>Any deleted records would need to be closed off in a second statement.</source>
            <target state="new">Any deleted records would need to be closed off in a second statement.</target>
          </trans-unit>
          <trans-unit id="138" xml:space="preserve">
            <source>An example of an <bpt id="2">&lt;code&gt;</bpt>UPSERT<ept id="2">&lt;/code&gt;</ept> is available below:</source>
            <target state="new">An example of an <bpt id="2">&lt;code&gt;</bpt>UPSERT<ept id="2">&lt;/code&gt;</ept> is available below:</target>
          </trans-unit>
          <trans-unit id="139" xml:space="preserve">
            <source>CTAS recommendation: Explicitly state data type and nullability of output</source>
            <target state="new">CTAS recommendation: Explicitly state data type and nullability of output</target>
          </trans-unit>
          <trans-unit id="140" xml:space="preserve">
            <source>When migrating code you might find you run across this type of coding pattern:</source>
            <target state="new">When migrating code you might find you run across this type of coding pattern:</target>
          </trans-unit>
          <trans-unit id="141" xml:space="preserve">
            <source>Instinctively you might think you should migrate this code to a CTAS and you would be correct.</source>
            <target state="new">Instinctively you might think you should migrate this code to a CTAS and you would be correct.</target>
          </trans-unit>
          <trans-unit id="142" xml:space="preserve">
            <source>However, their is a hidden issue here.</source>
            <target state="new">However, their is a hidden issue here.</target>
          </trans-unit>
          <trans-unit id="143" xml:space="preserve">
            <source>The following code does NOT yield the same result:</source>
            <target state="new">The following code does NOT yield the same result:</target>
          </trans-unit>
          <trans-unit id="144" xml:space="preserve">
            <source>Notice that the column "result" carries forward the data type and nullability values of the expression.</source>
            <target state="new">Notice that the column "result" carries forward the data type and nullability values of the expression.</target>
          </trans-unit>
          <trans-unit id="145" xml:space="preserve">
            <source>This can lead to subtle variances in values if you aren't careful.</source>
            <target state="new">This can lead to subtle variances in values if you aren't careful.</target>
          </trans-unit>
          <trans-unit id="146" xml:space="preserve">
            <source>Try the following as an example:</source>
            <target state="new">Try the following as an example:</target>
          </trans-unit>
          <trans-unit id="147" xml:space="preserve">
            <source>The value stored for result is different.</source>
            <target state="new">The value stored for result is different.</target>
          </trans-unit>
          <trans-unit id="148" xml:space="preserve">
            <source>As the persisted value in the result column is used in other expressions the error becomes even more significant.</source>
            <target state="new">As the persisted value in the result column is used in other expressions the error becomes even more significant.</target>
          </trans-unit>
          <trans-unit id="149" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="150" xml:space="preserve">
            <source>This is particularly important for data migrations.</source>
            <target state="new">This is particularly important for data migrations.</target>
          </trans-unit>
          <trans-unit id="151" xml:space="preserve">
            <source>Even though the second query is arguably more accurate there is a problem.</source>
            <target state="new">Even though the second query is arguably more accurate there is a problem.</target>
          </trans-unit>
          <trans-unit id="152" xml:space="preserve">
            <source>The data would be different compared to the source system and that leads to questions of integrity in the migration.</source>
            <target state="new">The data would be different compared to the source system and that leads to questions of integrity in the migration.</target>
          </trans-unit>
          <trans-unit id="153" xml:space="preserve">
            <source>This is one of those rare cases where the "wrong" answer is actually the right one!</source>
            <target state="new">This is one of those rare cases where the "wrong" answer is actually the right one!</target>
          </trans-unit>
          <trans-unit id="154" xml:space="preserve">
            <source>The reason we see this disparity between the two results is down to implicit type casting.</source>
            <target state="new">The reason we see this disparity between the two results is down to implicit type casting.</target>
          </trans-unit>
          <trans-unit id="155" xml:space="preserve">
            <source>In the first example the table defines the column definition.</source>
            <target state="new">In the first example the table defines the column definition.</target>
          </trans-unit>
          <trans-unit id="156" xml:space="preserve">
            <source>When the row is inserted an implicit type conversion occurs.</source>
            <target state="new">When the row is inserted an implicit type conversion occurs.</target>
          </trans-unit>
          <trans-unit id="157" xml:space="preserve">
            <source>In the second example there is no implicit type conversion as the expression defines data type of the column.</source>
            <target state="new">In the second example there is no implicit type conversion as the expression defines data type of the column.</target>
          </trans-unit>
          <trans-unit id="158" xml:space="preserve">
            <source>Notice also that the column in the second example has been defined as a NULLable column whereas in the first example it has not.</source>
            <target state="new">Notice also that the column in the second example has been defined as a NULLable column whereas in the first example it has not.</target>
          </trans-unit>
          <trans-unit id="159" xml:space="preserve">
            <source>When the table was created in the first example column nullability was explicitly defined.</source>
            <target state="new">When the table was created in the first example column nullability was explicitly defined.</target>
          </trans-unit>
          <trans-unit id="160" xml:space="preserve">
            <source>In the second example it was just left to the expression and by default this would result in a NULL definition.</source>
            <target state="new">In the second example it was just left to the expression and by default this would result in a NULL definition.</target>
          </trans-unit>
          <trans-unit id="161" xml:space="preserve">
            <source>To resolve these issues you must explicitly set the type conversion and nullability in the SELECT portion of the CTAS statement.</source>
            <target state="new">To resolve these issues you must explicitly set the type conversion and nullability in the SELECT portion of the CTAS statement.</target>
          </trans-unit>
          <trans-unit id="162" xml:space="preserve">
            <source>You cannot set these properties in the create table part.</source>
            <target state="new">You cannot set these properties in the create table part.</target>
          </trans-unit>
          <trans-unit id="163" xml:space="preserve">
            <source>The example below demonstrates how to fix the code:</source>
            <target state="new">The example below demonstrates how to fix the code:</target>
          </trans-unit>
          <trans-unit id="164" xml:space="preserve">
            <source>Note the following:</source>
            <target state="new">Note the following:</target>
          </trans-unit>
          <trans-unit id="165" xml:space="preserve">
            <source>CAST or CONVERT could have been used</source>
            <target state="new">CAST or CONVERT could have been used</target>
          </trans-unit>
          <trans-unit id="166" xml:space="preserve">
            <source>ISNULL is used to force NULLability not COALESCE</source>
            <target state="new">ISNULL is used to force NULLability not COALESCE</target>
          </trans-unit>
          <trans-unit id="167" xml:space="preserve">
            <source>ISNULL is the outermost function</source>
            <target state="new">ISNULL is the outermost function</target>
          </trans-unit>
          <trans-unit id="168" xml:space="preserve">
            <source>The second part of the ISNULL is a constant i.e. 0</source>
            <target state="new">The second part of the ISNULL is a constant i.e. 0</target>
          </trans-unit>
          <trans-unit id="169" xml:space="preserve">
            <source>For the nullability to be correctly set it is vital to use ISNULL and not COALESCE.</source>
            <target state="new">For the nullability to be correctly set it is vital to use ISNULL and not COALESCE.</target>
          </trans-unit>
          <trans-unit id="170" xml:space="preserve">
            <source>COALESCE is not a deterministic function and so the result of the expression will always be NULLable.</source>
            <target state="new">COALESCE is not a deterministic function and so the result of the expression will always be NULLable.</target>
          </trans-unit>
          <trans-unit id="171" xml:space="preserve">
            <source>ISNULL is different.</source>
            <target state="new">ISNULL is different.</target>
          </trans-unit>
          <trans-unit id="172" xml:space="preserve">
            <source>It is deterministic.</source>
            <target state="new">It is deterministic.</target>
          </trans-unit>
          <trans-unit id="173" xml:space="preserve">
            <source>Therefore when the second part of the ISNULL function is a constant or a literal then the resulting value will be NOT NULL.</source>
            <target state="new">Therefore when the second part of the ISNULL function is a constant or a literal then the resulting value will be NOT NULL.</target>
          </trans-unit>
          <trans-unit id="174" xml:space="preserve">
            <source>This tip is not just useful for ensuring the integrity of your calculations.</source>
            <target state="new">This tip is not just useful for ensuring the integrity of your calculations.</target>
          </trans-unit>
          <trans-unit id="175" xml:space="preserve">
            <source>It is also important for table partition switching.</source>
            <target state="new">It is also important for table partition switching.</target>
          </trans-unit>
          <trans-unit id="176" xml:space="preserve">
            <source>Imagine you have this table defined as your fact:</source>
            <target state="new">Imagine you have this table defined as your fact:</target>
          </trans-unit>
          <trans-unit id="177" xml:space="preserve">
            <source>However, the value field is a calculated expression it is not part of the source data.</source>
            <target state="new">However, the value field is a calculated expression it is not part of the source data.</target>
          </trans-unit>
          <trans-unit id="178" xml:space="preserve">
            <source>To create your partitioned dataset you might want to do this:</source>
            <target state="new">To create your partitioned dataset you might want to do this:</target>
          </trans-unit>
          <trans-unit id="179" xml:space="preserve">
            <source>The query would run perfectly fine.</source>
            <target state="new">The query would run perfectly fine.</target>
          </trans-unit>
          <trans-unit id="180" xml:space="preserve">
            <source>The problem comes when you try to perform the partition switch.</source>
            <target state="new">The problem comes when you try to perform the partition switch.</target>
          </trans-unit>
          <trans-unit id="181" xml:space="preserve">
            <source>The table definitions do not match.</source>
            <target state="new">The table definitions do not match.</target>
          </trans-unit>
          <trans-unit id="182" xml:space="preserve">
            <source>To make the table definitions match the CTAS needs to be modified.</source>
            <target state="new">To make the table definitions match the CTAS needs to be modified.</target>
          </trans-unit>
          <trans-unit id="183" xml:space="preserve">
            <source>You can see therefore that type consistency and maintaining nullability properties on a CTAS is a good engineering best practice.</source>
            <target state="new">You can see therefore that type consistency and maintaining nullability properties on a CTAS is a good engineering best practice.</target>
          </trans-unit>
          <trans-unit id="184" xml:space="preserve">
            <source>It helps to maintain integrity in your calculations and also ensures that partition switching is possible.</source>
            <target state="new">It helps to maintain integrity in your calculations and also ensures that partition switching is possible.</target>
          </trans-unit>
          <trans-unit id="185" xml:space="preserve">
            <source>Please refer to MSDN for more information on using <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>CTAS[]<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</source>
            <target state="new">Please refer to MSDN for more information on using <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>CTAS[]<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="186" xml:space="preserve">
            <source>It is one of the most important statements in Azure SQL Data Warehouse.</source>
            <target state="new">It is one of the most important statements in Azure SQL Data Warehouse.</target>
          </trans-unit>
          <trans-unit id="187" xml:space="preserve">
            <source>Make sure you thoroughly understand it.</source>
            <target state="new">Make sure you thoroughly understand it.</target>
          </trans-unit>
          <trans-unit id="188" xml:space="preserve">
            <source>Next steps</source>
            <target state="new">Next steps</target>
          </trans-unit>
          <trans-unit id="189" xml:space="preserve">
            <source>For more development tips, see <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>development overview[]<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</source>
            <target state="new">For more development tips, see <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>development overview[]<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>