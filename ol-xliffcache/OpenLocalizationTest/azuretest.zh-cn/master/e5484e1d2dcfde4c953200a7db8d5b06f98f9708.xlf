<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-cn" original="2/18/2016 5:27:39 PM" tool-id="MarkdownTransformer" product-name="N/A" product-version="N/A" build-num="1">
    <header>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e5484e1d2dcfde4c953200a7db8d5b06f98f9708</xliffext:olfilehash>
      <tool tool-id="MarkdownTransformer" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
    </header>
    <body>
      <group extype="content">
        <group id="101">
          <trans-unit id="101" xml:space="preserve">
            <source>Group by options in SQL Data Warehouse | Microsoft Azure</source>
            <target state="new">Group by options in SQL Data Warehouse | Microsoft Azure</target>
          </trans-unit>
          <trans-unit id="102" xml:space="preserve">
            <source>Tips for implementing group by options in Azure SQL Data Warehouse for developing solutions.</source>
            <target state="new">Tips for implementing group by options in Azure SQL Data Warehouse for developing solutions.</target>
          </trans-unit>
          <trans-unit id="103" xml:space="preserve">
            <source>Group by options in SQL Data Warehouse</source>
            <target state="new">Group by options in SQL Data Warehouse</target>
          </trans-unit>
          <trans-unit id="104" xml:space="preserve">
            <source>The [GROUP BY] clause is used to aggregate data to a summary set of rows.</source>
            <target state="new">The [GROUP BY] clause is used to aggregate data to a summary set of rows.</target>
          </trans-unit>
          <trans-unit id="105" xml:space="preserve">
            <source>It also has a few options that extend it's functionality that need to be worked around as they are not directly supported by Azure SQL Data Warehouse.</source>
            <target state="new">It also has a few options that extend it's functionality that need to be worked around as they are not directly supported by Azure SQL Data Warehouse.</target>
          </trans-unit>
          <trans-unit id="106" xml:space="preserve">
            <source>These options are</source>
            <target state="new">These options are</target>
          </trans-unit>
          <trans-unit id="107" xml:space="preserve">
            <source>GROUP BY with ROLLUP</source>
            <target state="new">GROUP BY with ROLLUP</target>
          </trans-unit>
          <trans-unit id="108" xml:space="preserve">
            <source>GROUPING SETS</source>
            <target state="new">GROUPING SETS</target>
          </trans-unit>
          <trans-unit id="109" xml:space="preserve">
            <source>GROUP BY with CUBE</source>
            <target state="new">GROUP BY with CUBE</target>
          </trans-unit>
          <trans-unit id="110" xml:space="preserve">
            <source>Rollup and grouping sets options</source>
            <target state="new">Rollup and grouping sets options</target>
          </trans-unit>
          <trans-unit id="111" xml:space="preserve">
            <source>The simplest option here is to use <bpt id="2">&lt;code&gt;</bpt>UNION ALL<ept id="2">&lt;/code&gt;</ept> instead to perform the rollup rather than relying on the explicit syntax.</source>
            <target state="new">The simplest option here is to use <bpt id="2">&lt;code&gt;</bpt>UNION ALL<ept id="2">&lt;/code&gt;</ept> instead to perform the rollup rather than relying on the explicit syntax.</target>
          </trans-unit>
          <trans-unit id="112" xml:space="preserve">
            <source>The result is exactly the same</source>
            <target state="new">The result is exactly the same</target>
          </trans-unit>
          <trans-unit id="113" xml:space="preserve">
            <source>Below is an example of a group by statement using the <bpt id="2">&lt;code&gt;</bpt>ROLLUP<ept id="2">&lt;/code&gt;</ept> option:</source>
            <target state="new">Below is an example of a group by statement using the <bpt id="2">&lt;code&gt;</bpt>ROLLUP<ept id="2">&lt;/code&gt;</ept> option:</target>
          </trans-unit>
          <trans-unit id="114" xml:space="preserve">
            <source>By using ROLLUP we have requested the following aggregations:</source>
            <target state="new">By using ROLLUP we have requested the following aggregations:</target>
          </trans-unit>
          <trans-unit id="115" xml:space="preserve">
            <source>Country and Region</source>
            <target state="new">Country and Region</target>
          </trans-unit>
          <trans-unit id="116" xml:space="preserve">
            <source>Country</source>
            <target state="new">Country</target>
          </trans-unit>
          <trans-unit id="117" xml:space="preserve">
            <source>Grand Total</source>
            <target state="new">Grand Total</target>
          </trans-unit>
          <trans-unit id="118" xml:space="preserve">
            <source>To replace this you will need to use <bpt id="2">&lt;code&gt;</bpt>UNION ALL<ept id="2">&lt;/code&gt;</ept>; specifying the aggregations required explicitly to return the same results:</source>
            <target state="new">To replace this you will need to use <bpt id="2">&lt;code&gt;</bpt>UNION ALL<ept id="2">&lt;/code&gt;</ept>; specifying the aggregations required explicitly to return the same results:</target>
          </trans-unit>
          <trans-unit id="119" xml:space="preserve">
            <source>For GROUPING SETS all we need to do is adopt the same principal but only create UNION ALL sections for the aggregation levels we want to see</source>
            <target state="new">For GROUPING SETS all we need to do is adopt the same principal but only create UNION ALL sections for the aggregation levels we want to see</target>
          </trans-unit>
          <trans-unit id="120" xml:space="preserve">
            <source>Cube options</source>
            <target state="new">Cube options</target>
          </trans-unit>
          <trans-unit id="121" xml:space="preserve">
            <source>It is possible to create a GROUP BY WITH CUBE using the UNION ALL approach.</source>
            <target state="new">It is possible to create a GROUP BY WITH CUBE using the UNION ALL approach.</target>
          </trans-unit>
          <trans-unit id="122" xml:space="preserve">
            <source>The problem is that the code can quickly become cumbersome and unwieldy.</source>
            <target state="new">The problem is that the code can quickly become cumbersome and unwieldy.</target>
          </trans-unit>
          <trans-unit id="123" xml:space="preserve">
            <source>To mitigate this you can use this more advanced approach.</source>
            <target state="new">To mitigate this you can use this more advanced approach.</target>
          </trans-unit>
          <trans-unit id="124" xml:space="preserve">
            <source>Let's use the example above.</source>
            <target state="new">Let's use the example above.</target>
          </trans-unit>
          <trans-unit id="125" xml:space="preserve">
            <source>The first step is to define the 'cube' that defines all the levels of aggregation that we want to create.</source>
            <target state="new">The first step is to define the 'cube' that defines all the levels of aggregation that we want to create.</target>
          </trans-unit>
          <trans-unit id="126" xml:space="preserve">
            <source>It is important to take note of the CROSS JOIN of the two derived tables.</source>
            <target state="new">It is important to take note of the CROSS JOIN of the two derived tables.</target>
          </trans-unit>
          <trans-unit id="127" xml:space="preserve">
            <source>This generates all the levels for us.</source>
            <target state="new">This generates all the levels for us.</target>
          </trans-unit>
          <trans-unit id="128" xml:space="preserve">
            <source>The rest of the code is really there for formatting.</source>
            <target state="new">The rest of the code is really there for formatting.</target>
          </trans-unit>
          <trans-unit id="129" xml:space="preserve">
            <source>The results of the CTAS can be seen below:</source>
            <target state="new">The results of the CTAS can be seen below:</target>
          </trans-unit>
          <trans-unit id="130" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="131" xml:space="preserve">
            <source>The second step is to specify a target table to store interim results:</source>
            <target state="new">The second step is to specify a target table to store interim results:</target>
          </trans-unit>
          <trans-unit id="132" xml:space="preserve">
            <source>The third step is to loop over our cube of columns performing the aggregation.</source>
            <target state="new">The third step is to loop over our cube of columns performing the aggregation.</target>
          </trans-unit>
          <trans-unit id="133" xml:space="preserve">
            <source>The query will run once for every row in the #Cube temporary table and store the results in the #Results temp table</source>
            <target state="new">The query will run once for every row in the #Cube temporary table and store the results in the #Results temp table</target>
          </trans-unit>
          <trans-unit id="134" xml:space="preserve">
            <source>Lastly we can return the results by simply reading from the #Results temporary table</source>
            <target state="new">Lastly we can return the results by simply reading from the #Results temporary table</target>
          </trans-unit>
          <trans-unit id="135" xml:space="preserve">
            <source>By breaking the code up into sections and generating a looping construct the code becomes more manageable and maintainable.</source>
            <target state="new">By breaking the code up into sections and generating a looping construct the code becomes more manageable and maintainable.</target>
          </trans-unit>
          <trans-unit id="136" xml:space="preserve">
            <source>Next steps</source>
            <target state="new">Next steps</target>
          </trans-unit>
          <trans-unit id="137" xml:space="preserve">
            <source>For more development tips, see <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>development overview[]<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</source>
            <target state="new">For more development tips, see <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>development overview[]<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>