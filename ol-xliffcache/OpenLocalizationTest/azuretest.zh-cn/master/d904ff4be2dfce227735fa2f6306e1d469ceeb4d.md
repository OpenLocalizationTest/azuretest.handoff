<properties
   pageTitle="Background jobs guidance | Microsoft Azure"
   description="Guidance on background tasks that run independently of the user interface."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# バック グラウンド ジョブ ガイダンス

![](media/best-practices-background-jobs/pnp-logo.png)


## 概要

多くの種類のアプリケーションでは、ユーザー インターフェイス (UI) とは独立して実行されるバック グラウンド タスクを必要とします。集中処理タスクとワークフローなどのプロセスを長時間実行のバッチ ジョブがあります。バック グラウンド ジョブは、ユーザーとの対話を必要とせず実行できます。アプリケーションは、ジョブを開始することができます、ユーザーから対話型の要求を処理する進みます。これはアプリケーションの可用性が向上し、レスポンス時間を短縮する UI 上の負荷を最小限に抑えることができます。

たとえば、アプリケーションは、ユーザーがアップロードした画像のサムネイルを生成する必要がある場合バック グラウンド ジョブとしてこれを行うまたはを完了するプロセスを待機する必要があるユーザーに完全なときにストレージにサムネイルを保存します。同じ方法で注文するユーザーは、UI により、ユーザーが web サイトの閲覧を続行しながら、注文を処理するバック グラウンド ワークフローを開始できます。バック グラウンド ジョブが完了したら、それストアド注文データを更新し、ユーザーの注文を確認する電子メールを送信できます。

主な基準は、バック グラウンド ジョブとしてのタスクを実装するかどうかは検討する際かどうかタスクを実行ユーザーの操作と UI なしジョブが完了するを待つ必要があります。彼らが完了するまで待機します、ユーザーまたは UI を必要とするタスクは、バック グラウンド ジョブとして適さない場合があります。

## バック グラウンド ジョブの種類

バック グラウンド ジョブは、次の特性の 1 つ以上に通常あります。

- 数学的な計算、構造解析など CPU 集約的な仕事。
- 一連のストレージ トランザクションの実行、ファイルのインデックス作成など I/O 集約的な仕事。
- 夜間のデータの更新またはスケジュールされた処理などのバッチ ジョブ。
- 注文処理などのワークフローを長時間実行したり、サービスやシステムを準備します。
- 機密性の高いデータ処理タスクを処理するためのより安全な場所に渡します。たとえば、web ロール内で機密性の高いデータを処理したくないし、代わりに示すようなパターンを使用可能性があります。 [ゲートキーパー](http://msdn.microsoft.com/library/dn589793.aspx) アクセスを持つ分離背景ロールにデータを転送するには、ストレージを保護されています。

## トリガー

バック グラウンド ジョブは、さまざまな方法で開始できます。効果的に、それらのすべては次のカテゴリのいずれかに分類されます。

- [**イベント駆動型のトリガー**](#event-driven-triggers).タスクは、イベント、ユーザーまたはワークフローのステップによって行われる動作の通常の応答で開始されます。
- [**スケジュール トリガーを駆動**](#schedule-driven-triggers).タスクは、スケジュール タイマーに基づいて呼び出されます。これは定期的なスケジュール、または一時の呼び出し後に指定された可能性があります。

### イベント駆動型のトリガー

イベント駆動型の呼び出しは、バック グラウンド タスクを開始するのにトリガーを使用します。イベント ドリブン トリガーを使用しての例を示します。

- UI または別のジョブは、キューにメッセージを配置します。メッセージには、ユーザーからの注文など、場所をとっているアクションについてのデータが含まれています。バック グラウンド タスクは、このキューをリッスンし、新しいメッセージの到着を検出します。それは、メッセージを読み取り、バック グラウンド ジョブの入力としてデータを使用します。
- UI または別のジョブを保存またはストレージの値を更新します。バック グラウンド タスクは、ストレージを監視し、変更を検出します。それは、データを読み取り、バック グラウンド ジョブへの入力として使用します。
- UI または別の仕事は、HTTPS URI など、エンドポイントの要求または API は、web サービスとして公開します。要求の一部としてバック グラウンド タスクを完了に必要なデータを渡します。エンドポイントまたは web サービスは、その入力としてデータを使用してバック グラウンド タスクを起動します。

イベント駆動型の呼び出しに適したタスクの典型的な例としてには画像処理、ワークフロー、マルチ テナント アプリケーションで新しいユーザーのプロビジョニング、電子メール メッセージを送信するリモート サービスに情報を送信が含まれます。

### スケジュール トリガーを駆動

スケジュール駆動呼び出しは、バック グラウンド タスクを開始するのにタイマーを使用します。スケジュール トリガーを駆動を使用しての例を示します。

- アプリケーション内、またはアプリケーションのオペレーティング システムの一部として、ローカルで実行されているタイマーは、定期的にバック グラウンド タスクを呼び出します。
- 別のアプリケーションまたは Azure スケジューラなどのタイマー サービスで実行されているタイマーは、定期的に API または web サービスに要求を送信します。API または web サービスは、バック グラウンド タスクを起動します。
- 別のプロセスまたはアプリケーションは、遅延指定した時間後に一度または特定の時間に起動するバック グラウンド タスクによって、タイマーを開始します。

タスク駆動型スケジュールの呼び出しに適していますの典型的な例は、自分の最近の行動は、インデックスの更新などを生成するルーチンのデータ処理タスクに基づいてユーザーの更新関連製品リスト蓄積の毎日のレポート、データ保持のクリーンアップ、データ整合性チェック、データの分析結果などのバッチ処理ルーチンを含まれます。

次の単一のインスタンスとして実行する必要がありますタスク駆動型スケジュールを使用する場合があります。

- (Windows のスケジュールされたタスクを使用して仮想マシン) などスケジューラを実行するコンピューティング インスタンスをスケールすると、実行スケジューラの複数のインスタンスがあり、これらはタスクの複数のインスタンスを開始可能性があります。
- スケジューラのイベントの期間よりも長く実行されたタスクは、以前のものが実行されている間にスケジューラがタスクの別のインスタンスを起動可能性があります。

## 結果を返す

バック グラウンド ジョブは、別個のプロセスまたは UI またはバック グラウンド タスクを起動したプロセスから、別の場所でもで非同期的に実行されます。理想的には、バック グラウンド タスクは「ファイア アンド フォーゲット」の操作を彼らの実行の進行状況は、UI または呼び出し元のプロセスに影響を与えません。つまり、呼び出し元のプロセスしたがって、タスクが終了したときを検出できません自動的に、タスクの完了を待機しません。
進行中または完了を示す呼び出し元のタスクと通信するバック グラウンド タスクを必要とする場合は、このメカニズムを実装しなければなりません。いくつかの例は次のとおりです。

- UI または呼び出し元タスクを監視したり、必要な場合、この値はチェックにアクセス可能なストレージにステータス インジケーターの値を書き込みます。バック グラウンド タスクは、呼び出し元に返す必要があるその他のデータは、同じストレージに配置できます。
- UI または呼び出し元がリッスンする応答キューを確立します。バック グラウンド タスクは、ステータスと完了度を示すキューにメッセージを送信できます。バック グラウンド タスクは、呼び出し元に返す必要があるデータは、メッセージに配置できます。Azure サービス バスを使用する場合を使用できます、 **ReplyTo** と **CorrelationId** この機能を実装するプロパティ。詳細については、次を参照してください。 [相関サービス バスの仲介型メッセージング](http://www.cloudcasts.net/devguide/Default.aspx?id=13029).
- API または UI または呼び出し元がステータス情報を取得するアクセスできるバック グラウンド タスクからエンドポイントを公開します。バック グラウンド タスクは、呼び出し元に返す必要があるデータは、応答に含めることができます。
- あらかじめ定義されたポイントでまたは完了の状態を示すための UI または API を介して呼び出し元にコールバックするバック グラウンド タスクを持っています。これは、ため、ローカルで発生したイベントまたは発行。 し、サブスクライブ メカニズム。バック グラウンド タスクは、呼び出し元に返す必要があるデータは、要求やイベントのペイロードに含めることができます。

## ホスティング環境

別の Azure プラットフォーム サービスの範囲を使用してバック グラウンド タスクをホストできます。

- [**Azure の Web サイト**](#azure-web-sites-and-webjobs).WebJobs を使用して、スクリプトや web サイトのコンテキスト内で実行可能なプログラムの種類の範囲に基づいてカスタム ジョブを実行できます。
- [**Azure クラウド サービス web ロールおよびワーカー ロール**](#azure-cloud-services-web-and-worker-roles).バック グラウンド タスクとして実行するロール内のコードを記述できます。
- [**Azure バーチャル マシン**](#azure-virtual-machines).Windows サービスがあるか、Windows タスク スケジューラを使用するには場合、は、専用の仮想マシン内でバック グラウンド タスクをホストする一般的です。

次のセクションは、各これらのオプションの詳細については、について説明し、適切なオプションを選択するための考慮事項が含まれます。

### Azure の Web サイトと WebJobs

Azure WebJobs を使用すると、Azure Web サイトがホストされているアプリケーション内でバック グラウンド タスクとしてカスタム ジョブを実行できます。WebJobs は、ストレージ blob およびメッセージ キュー、スクリプトまたはあなたのウェブサイトのコンテキスト内で実行可能なプログラムを継続的なプロセスとして Azure スケジューラまたは変更などの外部要因からトリガー イベントに応答または実行できます。ジョブは、開始し需要で停止し、正常にシャット ダウンすることができます。継続的に実行、WebJob が失敗すると、自動的に再起動します。再試行およびエラーのアクションは設定可能です。

ときに、WebJob を構成します。

- イベント駆動のトリガーに応答するジョブの場合、それとして構成する必要があります。 **継続的に実行します。**.スクリプトまたはプログラムは、サイト/wwwroot/アプリをという名前のフォルダーに格納されています。_データ/ジョブ/連続。
- トリガーを駆動型スケジュールに対応するジョブの場合に、それとして構成する必要があります。 **スケジュールで実行します。**.スクリプトまたはプログラムは、サイト/wwwroot/アプリをという名前のフォルダーに格納されています。_データ/ジョブ/トリガーです。
- 選択したかどうか、 **要求時に実行します。** オプション ジョブを構成すると、同じコードを実行します **スケジュールで実行します。** 起動するときのオプション。

紺碧の WebJobs を意味する環境変数にアクセスして接続文字列などの情報を web サイトと共有 web サイトのサンド ボックス内で実行します。ジョブには、ジョブを実行しているコンピューターの一意の識別子へのアクセス。名前付きの接続文字列 **AzureJobsStorage** メッセージング、およびコミュニケーションのためのアプリケーション データとサービス バスの Azure ストレージ キュー、blob、およびテーブルへのアクセスを提供します。名前付きの接続文字列 **AzureJobsDashboard** ジョブ アクションのログ ファイルへのアクセスを提供します。

紺碧の WebJobs には、次の特性があります。

- **セキュリティ**: WebJobs は、web サイトの展開資格情報によって保護されます。
- **サポートされているファイルの種類**: WebJobs コマンド スクリプト (.cmd)、バッチ ファイル (.bat)、PowerShell スクリプト (.ps1) を使用して定義することができます、bash シェル スクリプト (.sh)、PHP スクリプト (.php)、Python スクリプト (.py)、JavaScript コード (.js)、実行可能プログラム (.exe、.jar など)。
- **展開**: スクリプトを作成し、使用して、展開、Azure ポータルを使用して実行可能ファイルを展開できると、 [WebJobsVs](https://visualstudiogallery.msdn.microsoft.com/f4824551-2660-4afa-aba1-1fcc1673c3d0) Visual Studio のアドインまたは [Visual Studio 2013 更新 4](http://www.visualstudio.com/news/vs2013-update4-rc-vs)、を使用して、 [紺碧の WebJobs SDK](websites-dotnet-webjobs-sdk-get-started.md)、または次の場所に直接それらをコピーすることによって。
  - 実行のトリガー: サイト/wwwroot/アプリ_データ/ジョブ/トリガー/{ジョブ名}
  - 連続実行: サイト/wwwroot/アプリ_データ/ジョブ/連続/{ジョブ名}
- **ログ**: Console.Out は、情報とエラーとして Console.Error として (マーク) で扱われます。Azure ポータルを使用して監視および診断情報にアクセスすることができます、ログ ファイルは、サイトから直接ダウンロードすることができます。彼らは、次の場所に保存されます。
  - 実行のトリガー: Vfs/データ/ジョブ/連続/jobName
  - 連続実行: Vfs/データ/ジョブ/トリガー/jobName
- **構成**: WebJobs は、ポータル、REST API、および PowerShell を使用して構成できます。ジョブ スクリプト ジョブの構成情報を提供するために使用できるように、構成ファイルは同じルート ディレクトリに settings.job をという名前。たとえば。
  - {"停止_待機_「時間: 60}
  - {"が_シングルトン」: true}

### 上の考慮事項

- 既定では、web サイトと WebJobs スケール。ただし、ジョブを設定することによって 1 つのインスタンス上で実行する構成できます、 **は_シングルトン** 構成プロパティを true にします。1 つのインスタンス WebJobs タスクをスケールまたは同時に複数として実行しないようにするのに便利だ場合、インデックスの再作成、データ解析、および同様の作業など。
- Web サイトのパフォーマンス上のジョブの影響を最小限に抑える、集中ホスト長時間実行される可能性があります WebJobs またはリソースに新しいアプリ サービス計画における空 Azure Web サイト インスタンスを作成することを検討してください。

### 詳細については

- [紺碧の WebJobs 推奨リソース](websites-webjobs-resources/) WebJobs の多くの有用なリソース、ダウンロード、およびサンプルを示します。

## Azure クラウド サービス web ロールおよびワーカー ロール

Web ロールまたは個別のワーカー ロールでは、バック グラウンド タスクを実行できます。ケイデンス、セキュリティ、フォールト トレランス、競合、複雑さ、および論理アーキテクチャをリリース拡張性と弾力性要件、タスクの有効期間の考察のロールベース ワーカーを使用するべきであるかどうか決定。詳細については、次を参照してください。 [リソース統合パターンを計算します。](http://msdn.microsoft.com/library/dn589778.aspx).

クラウド サービス ロール内でバック グラウンド タスクを実装するいくつかの方法があります。

- 実装を作成します **RoleEntryPoint** ロールのクラスし、そのメソッドを使用してバック グラウンド タスクを実行します。タスク WaIISHost.exe のコンテキストで実行され、使用することができます、 **GetSetting** 法、 **CloudConfigurationManager** 設定をロードするクラス。詳細については、次を参照してください。 [ライフ サイクル (クラウド サービス)](#lifecycle-cloud-services-).
- スタートアップ タスクを使用して、アプリケーションの起動時にバック グラウンド タスクを実行します。背景セットで実行を継続タスクを強制的に、 **taskType** プロパティ **バック グラウンド** (もしこれを実行しないと、アプリケーションの起動プロセスが停止され、タスクが完了するを待つ)。詳細については、次を参照してください。 [Azure でスタートアップ タスクを実行します。](http://msdn.microsoft.com/library/azure/hh180155.aspx).
- WebJobs SDK を使用すると、スタートアップ タスクとして開始された WebJobs としてのバック グラウンド タスクを実装します。詳細については、次を参照してください。 [紺碧の WebJobs SDK を始める](websites-dotnet-webjobs-sdk-get-started.md).
- スタートアップ タスクを使用して、1 つまたは複数のバック グラウンド タスクを実行する Windows サービスをインストールします。設定する必要があります、 **taskType** プロパティ **バック グラウンド** そのサービスは、バック グラウンドで実行します。詳細については、次を参照してください。 [Azure でスタートアップ タスクを実行します。](http://msdn.microsoft.com/library/azure/hh180155.aspx).

### Web ロールのバック グラウンド タスクを実行中

Web ロールのバック グラウンド タスクを実行中の主な利点は、追加のロールを配置する必要はありませんので、ホスティング費用の節約です。

### ワーカー ロールのバック グラウンド タスクを実行中

ワーカー ロールでバック グラウンド タスクを実行するいくつかの利点があります。

- それは、管理役割の種類ごとに個別にスケーリングすることができます。たとえば、現在の負荷をサポートする web ロールの複数のインスタンスがバック グラウンド タスクを実行するワーカー ロールの少ないインスタンス必要があります。UI のロールから別にバック グラウンド タスク コンピューティング インスタンスをスケールは許容範囲のパフォーマンスを維持しながらホスティング コストを減らすことができます。
- Web ロールからバック グラウンド タスクの処理オーバーヘッドに肩代わりさせます。UI を提供する web ロール、応答性の高いままで、少ないインスタンスは、ユーザーからの要求の特定のボリュームをサポートする必要は可能性があります。
- それは、関心の分離を実装することができます。各役割の種類は、特定の明確に定義および関連タスク セットを実装できます。これにより設計とコードと各ロール間の機能のより少ない相互依存関係があるのでコードを簡単に維持します。
- それは敏感なプロセスとデータを分離することができます。たとえば、UI を実装する web ロールは、管理およびワーカー ロールによって制御データにアクセスする必要はありません。これ特にようにパターンを使用する場合、セキュリティの強化に役に立ちます、 [ゲートキーパー パターン](http://msdn.microsoft.com/library/dn589793.aspx).  

### 上の考慮事項

方法と場所を選択するとき、次の点を考慮してクラウド サービス web ロールおよびワーカー ロールを使用すると、バック グラウンド タスクを展開します。

- バック グラウンド タスクをホストしている既存の web の役割は、これらのタスクのためだけの個別のワーカー ロールを実行するコストを節減できますが、処理、およびその他のリソースの競合がある場合、パフォーマンスとアプリケーションの可用性に影響を与えるそうです。個別のワーカー ロールを使用して web ロールを長期実行しているまたはリソース集中的なバック グラウンド タスクの影響に防ぎます。
- 使用してバック グラウンド タスクをホストしている場合、 **RoleEntryPoint** クラスは、簡単に移動できますこれを別のロール。たとえば、web ロールと後でクラスを作成する場合、移動できます worker ロール内のタスクを実行する必要がありますを決定します **RoleEntryPoint** worker ロールにクラスの実装。
- スタートアップ タスクは、プログラムまたはスクリプトを実行する設計されています。実行可能プログラムとバック グラウンド ジョブを展開する依存アセンブリの展開も必要とする場合は特により困難かもしれない。簡単に展開、スクリプトを使用してスタートアップ タスクを使用する場合は、バック グラウンド ジョブを定義する場合があります。
- バック グラウンド タスクが失敗を引き起こす例外は、ホストされている方法に応じて異なる影響を与えます。
  - 使用するかどうかは、 **RoleEntryPoint** クラス アプローチ失敗したタスクは、タスクが自動的に再起動するを再起動する役割になります。アプリケーションの可用性に影響を与えることができます。これを防ぐためには、堅牢な例外処理の内で含まれていることを確認します **RoleEntryPoint** クラスとすべてのバック グラウンド タスク。これが適切である失敗するタスクを再起動するコードを使用し、優雅に、コード内でエラーから回復できない場合にのみ、役割を再起動する例外をスローします。
  - スタートアップ タスクを使用する場合のタスクの実行を管理し、それが失敗した場合があります。
- 管理および監視スタートアップ タスクを使用してより難しいです、 **RoleEntryPoint** クラス アプローチ。ただし、Azure WebJobs SDK には、スタートアップ タスクを開始する WebJobs を管理しやすくダッシュ ボードが含まれて。

### 詳細については

- [リソース統合パターンを計算します。](http://msdn.microsoft.com/library/dn589778.aspx)
- [紺碧の WebJobs SDK を始める](websites-dotnet-webjobs-sdk-get-started/)

## Azure バーチャル マシン

バック グラウンド タスクは、Azure Web サイトやクラウド サービスに展開されているからそれらを防ぐ方法で実装する可能性があります。 または、これは便利ではない場合があります。典型的な例は、Windows サービス、およびサードパーティ製のユーティリティや実行可能プログラムです。それは、異なるアプリケーションをホストする実行環境用に書かれたプログラムもあります。たとえば、Windows または .NET アプリケーションから実行する Unix または Linux プログラムがあります。Azure の仮想マシンのオペレーティング システムの範囲から選択し、その仮想マシンのサービスまたは実行可能ファイルを実行できます。

仮想マシンを使用するときに選択するために、次を参照してください。 [Azure の web サイト、クラウド サービスおよびバーチャル マシンの比較](choose-web-site-cloud-service-vm.md).オプションについて [仮想マシンは、仮想マシンと Azure のクラウド サービスのサイズを参照してください。](http://msdn.microsoft.com/library/azure/dn197896.aspx).仮想マシンのオペレーティング システムおよび利用可能な構築済みの画像の詳細については、次を参照してください。 [Azure バーチャル マシン ギャラリー](http://azure.microsoft.com/gallery/virtual-machines/).

別の仮想マシンでバック グラウンド タスクを開始するためのオプションの範囲があります。

- オンデマンド タスクをタスクを必要とするデータを渡し、タスクを公開するエンドポイントに要求を送信することによって、アプリケーションから直接実行できます。このエンドポイントには、タスクが呼び出されます。
- スケジューラまたは選択したオペレーティング システムで利用可能なタイマーを使用してスケジュールで実行するタスクを構成できます。たとえば、Windows のスクリプトとタスクを実行する Windows タスク スケジューラを使用することができます。 または、仮想マシンにインストールされている SQL Server の場合は、SQL Server エージェントを使用すると、スクリプトとタスクを実行できます。
- Azure スケジューラを使用すると、タスクを開始するタスクがリッスンするキューにメッセージを追加するかタスクを公開する API リクエストを送信することができます。

前のセクションを参照してください。 [トリガー](#triggers) 方法の詳細については、バック グラウンド タスクを開始できます。  

### 上の考慮事項

Azure のバーチャル マシンでバック グラウンド タスクを展開するかどうかを決定するときは、次の点を考慮してください。

- 別の Azure バーチャル マシンでバック グラウンド タスクをホストしている柔軟で、開始、実行、スケジュール、およびリソースの割り当てを正確に制御できます。しかし、バック グラウンド タスクを実行するバーチャル マシンを展開する必要がある場合のランタイム コストを増加します。
- 仮想マシンの基本的な状態を監視し、管理を使用して、Azure ポータル、および失敗したタスクの自動再起動機能なしでタスクを監視する機能はありません、 [Azure サービス管理のコマンドレット](http://msdn.microsoft.com/library/azure/dn495240.aspx).ただし、計算ノードのプロセスとスレッドを制御する設備がないです。通常、仮想マシンを使用してタスクに、インストルメンテーションおよび仮想マシン内のオペレーティング システムからデータを収集するメカニズムを実装する追加の作業が必要になります。使用する適切なことができる 1 つのソリューションは、 [Azure の system Center 管理パック](http://technet.microsoft.com/library/gg276383.aspx).
- HTTP エンドポイントを介して公開される監視プローブを作成することがあります。これらのプローブのコード可能性があります正常性チェックを実行、運用情報と統計情報を収集またはエラー情報を照合、管理アプリケーションに戻る。詳細については、次を参照してください。 [健康エンドポイント監視パターン](http://msdn.microsoft.com/library/dn589789.aspx).

### 詳細については

- [仮想マシン](http://azure.microsoft.com/services/virtual-machines/) 紺碧のウェブサイト
- [Azure バーチャル マシンに関するよくある質問](http://msdn.microsoft.com/library/azure/dn683781.aspx)

## 設計に関する考慮事項

バック グラウンド タスクを設計するときに考慮するいくつかの根本的な要因があります。パーティション分割、競合、および調整について説明します。

## パーティション分割

(ウェブサイト、web ロール、既存ワーカー ロール、または仮想マシン) などの既存のコンピューティング インスタンス内でバック グラウンド タスクを含める場合は、計算インスタンスとバック グラウンド タスク自体の品質属性に影響するかを考慮する必要があります。これらの要因が既存のコンピューティング インスタンスとタスクを配置するかどうかを決定することができます。 またはそれら独立したコンピューティング インスタンスを分けます。

- **可用性**: バック グラウンド タスク UI およびユーザーとの対話に直接関与する他の部分特にとして、アプリケーションの他の部分の有効性の同じレベルを持っている必要はありません。他の要因に影響を与える可用性操作をキューすることができますので、バック グラウンド タスクがより再試行接続障害、遅延に対する耐性あります。ただし、バックアップ要求キューをブロックし、アプリケーション全体に影響を与えるを防ぐために十分な容量がなければなりません。
- **スケーラビリティ**: バック グラウンド タスクは、UI とアプリケーションの対話型の部分に異なる拡張性要件を持っている可能性があります。UI を拡大縮小、需要ピークを満たしながら、優れたバック グラウンド タスクにより少ない以下の忙しい時に完了する必要があります計算のインスタンスの数。
- **弾力性**: ちょうどホストのバック グラウンド タスク可能性があります致命的を与えないこと全体としてアプリケーションこれらのタスクのための要求をキューに置かれたまたはタスクに延期できる場合計算インスタンスの障害が再び利用可能。適切な間隔の内でコンピューティング インスタンスやタスクを再起動することができる場合、アプリケーションのユーザーの影響は不明。
- **セキュリティ**: バック グラウンド タスクは、さまざまなセキュリティ要件や UI やアプリケーションの他の部分よりも制限があります。独立したコンピューティング インスタンスを使用して、タスクの異なるセキュリティ環境を指定できます。セキュリティと分離を最大化するために、UI から背景コンピューティング インスタンスを分離するのにゲートキーパーなどパターンを使用することができますも。
- **パフォーマンス**: 計算タスクのパフォーマンス要件を具体的に一致するバック グラウンド タスクのインスタンスの型を選択できます。つまりタスク追加容量とリソースが必要な場合、UI または大きいインスタンスと同じ処理機能が必要ない場合、安価な計算オプションを使用します。
- **管理の容易性**: バック グラウンド タスクをメイン アプリケーション コードまたは UI から別の開発と展開のリズムとあります。独立したコンピューティング インスタンスに配置すると、更新プログラムとバージョン管理を簡素化できます。
- **コスト**: 背景を実行するコンピューティング インスタンスの追加タスクのホスティング費用の増加。追加容量とこれらの余分なコストとのトレードオフを慎重に検討する必要があります。

詳細については、次を参照してください。 [リーダー選挙パターン](http://msdn.microsoft.com/library/dn568104.aspx) と [競合する消費者パターン](http://msdn.microsoft.com/library/dn568101.aspx).

## 競合

バック グラウンド ジョブの複数のインスタンスがある場合は、リソースおよびデータベースやストレージなどのサービスへのアクセスの競合が発生することが可能です。この同時アクセスは、サービスの可用性とストレージ内のデータの整合性で競合が発生する可能性がありますリソースの競合で起因できます。リソースの競合を防ぐために排他ロックの方法を使用して解決できるタスクを同時に、サービスへのアクセスまたはデータの破損からの競合するインスタンス。

競合を解決する別のアプローチは、シングルトンとしてバック グラウンド タスクを定義する、1 つだけのインスタンスが実行中です。ただし、UI は、1 つ以上のバック グラウンド タスクをビジー状態に保つための十分な仕事を供給できる場合は特に複数インスタンス構成がありますが、信頼性とパフォーマンス上の利点がなくなります。それは、バック グラウンド タスクは自動的に再起動することができます、ピーク需要に対処するための十分な容量があることを確認することが重要です。これは、需要が低下すると、後で実行する要求を格納することができますキューイング機構を実装することによって、またはこれらの手法の組み合わせによって、十分なリソースを持つコンピューティング インスタンスを割り当てることによって達成されるかもしれません。

## 調整

バック グラウンド タスクは、複雑になる可能性があります、実行結果を生成する、またはすべての要望を満たすために複数の個々 のタスクを必要とします。小さい控えめなステップまたは複数の消費者によって実行されるサブタスクにタスクを分割するこれらのシナリオでは一般的です。マルチ ステップ ジョブは、個々 のステップは複数のジョブで再利用できる可能性があるためにより効率的なより柔軟なをすることができます。追加、削除、またはステップの順序を変更する簡単です。

複数のタスクおよび手順を調整、挑戦することができますが、ソリューションの実装をガイドに使用することができます 3 つの一般的なパターンがあります。

- **複数の再利用可能なステップにタスクの分解**.アプリケーションの処理についてさまざまな複雑さを様々 なタスクを実行する必要があります。このアプリケーションを実装するために簡単ですが、柔軟性があるアプローチは、モノリシック モジュールとしてこの処理を実行することです。ただし、この方法は、コードのリファクタリング、最適化、または同じ処理の部分が別の場所、アプリケーションで必要な場合、それを再利用のための機会を減らすために可能性があります。詳細については、次を参照してください。 [パイプとフィルター パターン](http://msdn.microsoft.com/library/dn568100.aspx).
- **タスクの手順の実行を管理します。**.手順については、いくつかのリモート サービスを呼び出し、リモート リソースにアクセス数を構成するタスクは、アプリケーションで実行可能性があります。個々 のステップは、他の独立したかもしれませんが、彼らはタスクを実装するアプリケーション ロジックによって管弦楽に編曲されます。詳細については、次を参照してください。 [スケジューラ エージェント スーパーバイザー パターン](http://msdn.microsoft.com/library/dn589780.aspx).
- **失敗したタスクの手順の回復を管理します。**.アプリケーションは、一連の手順は、1 つ以上のステップが失敗した場合、最終的に一貫した操作を一緒に定義によって実行される作業を元に戻す必要があります。詳細については、次を参照してください。 [補償トランザクション パターン](http://msdn.microsoft.com/library/dn589804.aspx).

## ライフ サイクル (クラウド サービス)

 バック グラウンド ジョブを使用して、web ロールとワーカー ロールを使用してクラウド サービス アプリケーションを実装する場合、 **RoleEntryPoint** クラス、それはそれを正しく使用するためにこのクラスのライフ サイクルを理解することが重要です。

Web ロールおよびワーカー ロールは、として彼らを開始、実行、および停止一連の段階を通過します。、 **RoleEntryPoint** クラスは、一連のこれらの段階の発生時を示すイベントを公開します。実行すると、初期化、するこれらを使用してカスタム バック グラウンド タスクを停止します。完全なサイクルです。

- Azure は、ロール アセンブリをロードしから派生するクラスを検索 **RoleEntryPoint**.
- このクラスが見つかると、それを呼び出す **RoleEntryPoint.OnStart()**.バック グラウンド タスクを初期化するこのメソッドをオーバーライドすると。
- 後、 **OnStart** メソッドが完了すると、Azure を呼び出します **アプリケーション_Start()** アプリケーションのグローバル (たとえば、ASP.NET を実行している web ロールで Global.asax) 場合は、このファイルが存在します。
- 紺碧の呼び出し **RoleEntryPoint.Run()** 並行して実行される新しいフォア グラウンド スレッドで **OnStart()**.バック グラウンド タスクを開始するこのメソッドをオーバーライドすると。
- Azure をまず呼び出す Run メソッドが終了したとき **アプリケーション_End()** アプリケーションのグローバル場合このファイルが存在し、呼び出しです。 **RoleEntryPoint.OnStop()**.オーバーライドする、 **OnStop** バック グラウンド タスクを停止、リソースのクリーンアップ、オブジェクトの破棄、タスク可能性があります使用している接続を閉じるメソッド。
- Azure ワーカー ロールのホスト プロセスが停止します。この時点で、ロールがリサイクルされる、再起動します。

詳細については、のメソッドの使用例を **RoleEntryPoint** クラスには、参照してください。 [リソース統合パターンを計算します。](http://msdn.microsoft.com/library/dn589778.aspx).

## 上の考慮事項

Web またはワーカー ロールのバック グラウンド タスクを実行する方法を計画するときは、次の点を考慮してください。

- 既定値 **実行** メソッドの実装、 **RoleEntryPoint** クラスの呼び出しを含む **Thread.Sleep(Timeout.Infinite)** それはいつまでも生きている役割を保持します。オーバーライドするかどうかは、 **実行** メソッド (これは通常バック グラウンド タスクを実行する必要は) ロール インスタンスをリサイクルする場合を除き、このメソッドを終了するコードを許可する必要があります。
- 典型的な実装、 **実行** メソッドには、各バック グラウンド タスクおよびすべてのバック グラウンド タスクの状態を定期的にチェックするループ構造を開始するコードが含まれています。それは失敗したか、またはジョブが完了したことを示すキャンセル トークンを監視を再開できます。
- バック グラウンド タスクは、処理されない例外をスローした場合、そのタスクは実行を継続する役割で他のバック グラウンド タスクを可能にしながらリサイクルする必要があります。ただし、例外はタスク、共有ストレージなどの外部オブジェクトの破損によって引き起こされている場合、例外が処理によって、 **RoleEntryPoint** クラス、すべてのタスクを対象に、キャンセルと **実行** メソッドを終了する許可されていません。Azure では、ロールは再起動します。
- 使用、 **OnStop** 一時停止またはバック グラウンド タスクを殺すために、リソースをクリーンアップ メソッド。実行時間の長いまたはマルチ ステップ タスクを停止する場合があります、これを行うしてデータ不整合を回避する方法を検討することが重要です。ロール インスタンスがユーザーにより開始されるシャット ダウンで実行するコード以外の理由で停止したかどうか、 **OnStop** メソッドは、強制的に終了されるまで 5 分以内で完了する必要があります。コードがその時間内に完了することができますまたは容認することは実行が完了しないことを確認します。  
- Azure のロード バランサーの役割にトラフィックを誘導開始インスタンスの場合、 **RoleEntryPoint.OnStart** メソッドが true を返します。したがって、あなたのすべての初期化コードを置くことを考慮、 **OnStart** メソッドを意志を正常に初期化できませんロール インスタンスはすべてのトラフィックを受け取らないようにします。
- スタートアップ タスクのメソッドに加えてを使用できます、 **RoleEntryPoint** クラスです。スタートアップ タスクを使用すると、役割は、要求を受信する前にこれらのタスクが実行されるため、Azure のロード バランサーで変更する必要が任意の設定を初期化する必要があります。詳細については、次を参照してください。 [Azure でスタートアップ タスクを実行します。](http://msdn.microsoft.com/library/azure/hh180155.aspx).
- スタートアップ タスクでエラーがある場合は、継続的に再起動する役割を強いられるかもしれない。これは、スワップ、役割への排他的アクセスを必要とする、役割の再起動中これを取得できませんので以前上演版に戻って VIP スワップを実行するからあなたを防ぐことができます。この問題を解決: する
	-  先頭に次のコードを追加、 **OnStart** と **実行** あなたの役割のメソッド:

	```C#
	var freeze = CloudConfigurationManager.GetSetting("Freeze");
	if (freeze != null)
	{
		if (Boolean.Parse(freeze))
	  	{
		    Thread.Sleep(System.Threading.Timeout.Infinite);
		}
	}
	```

   - 定義を追加、 **凍結** ServiceDefinition.csdef、ServiceConfiguration ブール値として設定します。*役割の .cscfg ファイルに設定 **false**.役割は繰り返し再起動モードに入る場合に、設定を変更できます。 **場合は true。** 役割実行を凍結し、以前のバージョンと交換することができます。

## 復元に関する考慮事項

バック グラウンド タスクは、アプリケーションに信頼性の高いサービスを提供するために弾力性のある必要があります。計画およびバック グラウンド タスクを設計、際、次の点を考慮します。

- バック グラウンド タスクは、データの破損、またはアプリケーションに不整合を導入せず役割またはサービスの再起動を適切に処理できる必要があります。実行時間の長いまたはマルチ ステップ タスクの使用を検討します。 _ポイントをチェックします。_ キュー内のメッセージの永続的なストレージのジョブの状態を保存する場合、これは適切なです。たとえば、キュー内のメッセージの状態情報を保持でき、先頭から再起動する代わりに最後の既知の良いチェックポイントからタスクを処理できるように、タスクの進行状況と状態情報を増分更新します。Azure サービス バス キューを使用している場合は、同じシナリオを有効にするメッセージ セッションを使用できます。セッションを保存し、使用して、アプリケーションの処理状態を取得することができます、 [SetState](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.setstate.aspx) と [GetState](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.getstate.aspx) メソッド。設計信頼性の高いマルチ ステップ プロセスとワークフローの詳細については、次を参照してください。 [スケジューラ エージェント スーパーバイザー パターン](http://msdn.microsoft.com/library/dn589780.aspx).
- Web またはワーカー ロールを使用して、複数のバック グラウンド タスクをホストするのオーバーライドをデザイン、 **実行** 監視するためのメソッドが失敗したか、タスクを停止、それらを再起動します。これは実用的ではないと、ワーカー ロールを使用している場合、強制終了して再起動するワーカー ロール、 **実行** メソッドです。
- バック グラウンド タスクとの通信にキューを使用する場合、キューはタスクに送信されると、アプリケーションは通常の負荷よりも高い要求を格納するためのバッファーとして機能できます。これにより少なく混雑時に UI に追いつくためにタスクです。それはまた役割をリサイクルでは、UI はブロックされないことを意味します。詳細については、次を参照してください。 [キュー ベースの負荷パターンを平準化](http://msdn.microsoft.com/library/dn589783.aspx).いくつかのタスクは他人より重要である場合、実装を検討、 [優先度キュー パターン](http://msdn.microsoft.com/library/dn589794.aspx) 重要度の低いメッセージの前にこれらのタスクを実行することを確認します。
- メッセージ到着、繰り返し (呼ばれるとしてエラーが発生したメッセージなどの矛盾を処理するバック グラウンド タスクによって、開始またはその他のメッセージの処理を設計する必要があります。 _有害なメッセージ_) と 2 回以上配信されるメッセージ。次のことを検討してください。
  - Messages that must be processed in a specific order, such as those that change data based on its existing value (for example, adding a value to an existing value), may not arrive in the original order they were sent. Alternatively, they may be handled by different instances of a background task in a different order due to varying loads on each instance. Messages that must be processed in a specific order should include a sequence number, key, or some other indicator that background tasks can use to ensure they are processed in the correct order. If you are using Azure Service Bus, you can use message sessions to guarantee the order of delivery. However, it is usually more efficient where possible to design the process so that the message order is not important.
  - Typically, a background task will peek messages in the queue, which temporarily hides them from other message consumers, and then delete the messages after they have been successfully processed. If a background task fails when processing a message, that message will reappear on the queue after the peek timeout expires, and will be processed by another instance of the task or during the next processing cycle of this instance. If the message consistently causes an error in the consumer, it will block the task, the queue, and eventually the application itself when the queue becomes full. Therefore, it is vital to detect and remove poison messages from the queue. If you are using Azure Service Bus, messages that cause an error can be moved automatically or manually to an associated dead letter queue.
  - 保証値のキューでは _少なくとも 1 回_ delivery mechanisms, but they may deliver the same message more than once. In addition, if a background task fails after processing a message but before deleting it from the queue, the message will become available for processing again. Background tasks should be idempotent, which means that processing the same message more than once does not cause an error or inconsistency in the application’s data. Some operations are naturally idempotent, such as setting a stored value to a specific new value. However, operations such as adding a value to an existing stored value without checking that the stored value is still the same as when the message was originally sent will cause inconsistencies.  Azure Service Bus queues can be configured to automatically remove duplicated messages.
  - Azure ストレージ キューや Azure サービス バス キューなど、一部のメッセージング システムは、メッセージ キューから読み取られた回数を示す de-queue カウント プロパティをサポートします。これは、繰り返されると有害メッセージの処理に役立ちます。詳細については、次を参照してください。 [非同期メッセージング プライマー](http://msdn.microsoft.com/library/dn589781.aspx) と [等羃性パターン](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/).

## スケーリングおよびパフォーマンスに関する考慮事項

バック グラウンド タスクは、アプリケーションをブロックしていない、または遅延操作により不整合が発生するときに、システムが高負荷を確保するため十分なパフォーマンスを提供しなければなりません。通常、バック グラウンド タスクをホスト コンピューティング インスタンスを拡大することでパフォーマンスが向上します。計画と、バック グラウンド タスクの設計は、スケーラビリティおよびパフォーマンスに関する次の点を考慮してください。

- 現在の需要と負荷に基づいて azure サポート自動スケール (スケール アウトおよびスケールに戻って) または定義済みのスケジュールに Web サイトのクラウド サービス web およびワーカー ロールと仮想マシン ホストの展開。全体ランタイム コストを最小限に抑えながら十分な性能があり、アプリケーションを確保するためには、この機能を使用します。
- バック グラウンド タスクは、クラウド サービス アプリケーション (UI またはデータ アクセス層などのコンポーネント) の他の部分から異なる性能を持っている、別の worker ロールで一緒にバック グラウンド タスクをホストしている可能 UI とバック グラウンド タスクの負荷管理を個別に拡張する役割複数のバック グラウンド タスクは、お互いから大幅に異なるパフォーマンス機能を持って、独立して、入力が、これは少数のロールにすべてのタスクを組み合わせることと比較してランタイム コストを高める可能性がありますに注意してください個別のワーカーの役割に分けて、それぞれの役割を拡大/縮小を検討してください。
- 単に役割をスケーリングしない負荷の下でパフォーマンスの低下を防ぐために十分かもしれません。ストレージ キューおよび単一の全体的なポイントを防ぐために他のリソースを拡張する必要がありますもボトルネックになってチェーンを処理します。また、ストレージのスループットなど、その他の制限も検討しその他のアプリケーション サービスし、バック グラウンド タスクに依存します。
- バック グラウンド タスクは、スケーリングの設計をする必要があります。たとえば、彼らはリッスンまたは適切なキューにメッセージを送信するために使用しているストレージのキューの数を動的に検出できなければなりません。
- 既定では、関連付けられた Azure の Web サイト インスタンスで WebJobs スケール。ただし、WebJob のみの単一のインスタンスとして実行する場合は、JSON データを含む Settings.job ファイルを作成することができます。 **{"が_シングルトン」: true}**.これは、スケジュールされたジョブの 1 つのインスタンスとして実行する必要があります便利な方法をすることができます関連のウェブサイトの複数のインスタンスがある場合でも、WebJob の 1 つのインスタンスのみ実行に Azure を強制します。

## 関連パターン

- [非同期メッセージング プライマー](http://msdn.microsoft.com/library/dn589781.aspx)
- [自動スケール ガイダンス](http://msdn.microsoft.com/library/dn589774.aspx)
- [補償トランザクション パターン](http://msdn.microsoft.com/library/dn589804.aspx)
- [競合する消費者パターン](http://msdn.microsoft.com/library/dn568101.aspx)
- [ガイド パーティション分割を計算します。](http://msdn.microsoft.com/library/dn589773.aspx)
- [リソース統合パターンを計算します。](http://msdn.microsoft.com/library/dn589778.aspx)
- [ゲートキーパー パターン](http://msdn.microsoft.com/library/dn589793.aspx)
- [リーダー選挙パターン](http://msdn.microsoft.com/library/dn568104.aspx)
- [パイプとフィルター パターン](http://msdn.microsoft.com/library/dn568100.aspx)
- [優先度キュー パターン](http://msdn.microsoft.com/library/dn589794.aspx)
- [キュー ベースの負荷パターンを平準化](http://msdn.microsoft.com/library/dn589783.aspx)
- [スケジューラ エージェント スーパーバイザー パターン](http://msdn.microsoft.com/library/dn589780.aspx)

## 詳細については

- [ワーカー ロールと Azure アプリケーションのスケーリング](http://msdn.microsoft.com/library/hh534484.aspx#sec8)
- [バック グラウンド タスクを実行します。](http://msdn.microsoft.com/library/ff803365.aspx)
- [Azure のロール起動ライフ サイクル](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx) (ブログの投稿)
- [Azure クラウド サービス ロールのライフ サイクル](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (ビデオの)
- [紺碧の WebJobs SDK を始める](websites-dotnet-webjobs-sdk-get-started/)
- [Azure キューおよびサービス バス キュー - 比較および対照](http://msdn.microsoft.com/library/hh767287.aspx)
- [クラウド サービスでの診断を有効にするには、方法](http://msdn.microsoft.com/library/dn482131.aspx)
