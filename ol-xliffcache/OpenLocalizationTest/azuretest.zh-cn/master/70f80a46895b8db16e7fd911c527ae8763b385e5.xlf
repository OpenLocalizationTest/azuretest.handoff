<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-cn" original="2/17/2016 2:53:00 PM" tool-id="MarkdownTransformer" product-name="N/A" product-version="N/A" build-num="1">
    <header>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">70f80a46895b8db16e7fd911c527ae8763b385e5</xliffext:olfilehash>
      <tool tool-id="MarkdownTransformer" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
    </header>
    <body>
      <group extype="content">
        <group id="101">
          <trans-unit id="101" xml:space="preserve">
            <source>Data partitioning guidance | Microsoft Azure</source>
            <target state="new">Data partitioning guidance | Microsoft Azure</target>
          </trans-unit>
          <trans-unit id="102" xml:space="preserve">
            <source>Guidance upon how to separate partitions to be managed and accessed separately.</source>
            <target state="new">Guidance upon how to separate partitions to be managed and accessed separately.</target>
          </trans-unit>
          <trans-unit id="103" xml:space="preserve">
            <source>データ パーティション分割指導</source>
            <target state="new">データ パーティション分割指導</target>
          </trans-unit>
          <trans-unit id="104" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="105" xml:space="preserve">
            <source>概要</source>
            <target state="new">概要</target>
          </trans-unit>
          <trans-unit id="106" xml:space="preserve">
            <source>多くの大規模なソリューションで、データが別々 のパーティションに管理、個別にアクセスすることができますに分かれています。パーティション分割戦略は、副作用を最小限に抑えつつ、メリットを最大限に注意深く選ばれなければなりません。分割は、スケーラビリティが向上し、競合が低減するパフォーマンスを最適化できます。パーティション分割の副次的な利点は、使用パターンによってデータを分割するための機構を提供することができますも安価なデータ ストレージに古いよりアクティブでない (冷たい) データをアーカイブすることができます。</source>
            <target state="new">多くの大規模なソリューションで、データが別々 のパーティションに管理、個別にアクセスすることができますに分かれています。パーティション分割戦略は、副作用を最小限に抑えつつ、メリットを最大限に注意深く選ばれなければなりません。分割は、スケーラビリティが向上し、競合が低減するパフォーマンスを最適化できます。パーティション分割の副次的な利点は、使用パターンによってデータを分割するための機構を提供することができますも安価なデータ ストレージに古いよりアクティブでない (冷たい) データをアーカイブすることができます。</target>
          </trans-unit>
          <trans-unit id="107" xml:space="preserve">
            <source>なぜデータをパーティション?</source>
            <target state="new">なぜデータをパーティション?</target>
          </trans-unit>
          <trans-unit id="108" xml:space="preserve">
            <source>ほとんどのクラウド アプリケーションとサービスを格納および彼らの操作の一部としてデータを取得します。アプリケーションが使用するデータ ストアの設計は、パフォーマンス、スループット、およびシステムのスケーラビリティに大きな影響を持つことができます。大規模なシステムでは一般的に適用される 1 つの方法は、別々 のパーティションにデータを分割します。</source>
            <target state="new">ほとんどのクラウド アプリケーションとサービスを格納および彼らの操作の一部としてデータを取得します。アプリケーションが使用するデータ ストアの設計は、パフォーマンス、スループット、およびシステムのスケーラビリティに大きな影響を持つことができます。大規模なシステムでは一般的に適用される 1 つの方法は、別々 のパーティションにデータを分割します。</target>
          </trans-unit>
          <trans-unit id="109" xml:space="preserve">
            <source>用語 <bpt id="2">&lt;em&gt;</bpt>パーティション分割<ept id="2">&lt;/em&gt;</ept> このガイダンスは、物理的に別のデータ ストアにデータを分割するプロセスを指します。これは SQL Server テーブルをパーティション分割すると同じ別の概念であります。</source>
            <target state="new">用語 <bpt id="2">&lt;em&gt;</bpt>パーティション分割<ept id="2">&lt;/em&gt;</ept> このガイダンスは、物理的に別のデータ ストアにデータを分割するプロセスを指します。これは SQL Server テーブルをパーティション分割すると同じ別の概念であります。</target>
          </trans-unit>
          <trans-unit id="110" xml:space="preserve">
            <source>データを分割する多くの利点を提供できます。たとえば、するために適用できます。</source>
            <target state="new">データを分割する多くの利点を提供できます。たとえば、するために適用できます。</target>
          </trans-unit>
          <trans-unit id="111" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>スケーラビリティを向上させる<ept id="1">&lt;/strong&gt;</ept>.1 つのデータベース システムをスケール アップと、物理的なハードウェア制限を最終的に達する。それぞれが別のサーバーでホストされている複数のパーティション間でデータを分割システムがほぼ無限にスケール アウトすることができます。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>スケーラビリティを向上させる<ept id="1">&lt;/strong&gt;</ept>.1 つのデータベース システムをスケール アップと、物理的なハードウェア制限を最終的に達する。それぞれが別のサーバーでホストされている複数のパーティション間でデータを分割システムがほぼ無限にスケール アウトすることができます。</target>
          </trans-unit>
          <trans-unit id="112" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>パフォーマンスを向上させる<ept id="1">&lt;/strong&gt;</ept>.各パーティションのデータ アクセス操作を引き継ぐデータの小さいボリュームの場所。ただし、適切な方法で、データを分割すると、これははるかに効率的です。1 つ以上のパーティションに影響する操作は、並列に実行できます。各パーティションは、ネットワーク待機時間を最小限に抑えるために使用するアプリケーションの近くにあることができます。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>パフォーマンスを向上させる<ept id="1">&lt;/strong&gt;</ept>.各パーティションのデータ アクセス操作を引き継ぐデータの小さいボリュームの場所。ただし、適切な方法で、データを分割すると、これははるかに効率的です。1 つ以上のパーティションに影響する操作は、並列に実行できます。各パーティションは、ネットワーク待機時間を最小限に抑えるために使用するアプリケーションの近くにあることができます。</target>
          </trans-unit>
          <trans-unit id="113" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>可用性を向上します。<ept id="1">&lt;/strong&gt;</ept>.複数サーバー間でデータを分割するには、単一障害点が回避できます。サーバーが失敗した場合は、パーティションが利用できないという点で、計画的なメンテナンス、データだけを受けているか。他のパーティションで操作を続行できます。パーティションの数を増やすと、利用されるデータの割合を減らすことによって単一のサーバー障害の相対的な影響が軽減されます。各パーティションをレプリケートしてさらに操作に影響を与える単一のパーティション失敗のチャンスを減らすことができます。それはまた、継続的にする必要がある重要なデータの分離を可能し、低値データ (ログ ファイル) などから高度利用することが可用性の要件が低い。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>可用性を向上します。<ept id="1">&lt;/strong&gt;</ept>.複数サーバー間でデータを分割するには、単一障害点が回避できます。サーバーが失敗した場合は、パーティションが利用できないという点で、計画的なメンテナンス、データだけを受けているか。他のパーティションで操作を続行できます。パーティションの数を増やすと、利用されるデータの割合を減らすことによって単一のサーバー障害の相対的な影響が軽減されます。各パーティションをレプリケートしてさらに操作に影響を与える単一のパーティション失敗のチャンスを減らすことができます。それはまた、継続的にする必要がある重要なデータの分離を可能し、低値データ (ログ ファイル) などから高度利用することが可用性の要件が低い。</target>
          </trans-unit>
          <trans-unit id="114" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>セキュリティを向上させる<ept id="1">&lt;/strong&gt;</ept>.データとパーティション分割方法の性質によっては、機密、非機密データを異なるパーティションおよび異なるサーバーまたはデータ ストアに分割することが可能があります。セキュリティは、機密性の高いデータのため特に最適化ことができます。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>セキュリティを向上させる<ept id="1">&lt;/strong&gt;</ept>.データとパーティション分割方法の性質によっては、機密、非機密データを異なるパーティションおよび異なるサーバーまたはデータ ストアに分割することが可能があります。セキュリティは、機密性の高いデータのため特に最適化ことができます。</target>
          </trans-unit>
          <trans-unit id="115" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>運用上の柔軟性を提供します。<ept id="1">&lt;/strong&gt;</ept>.分割操作を微調整、管理効率を最大化することやコストを最小限に抑えるのための多くの機会を提供しています。管理、監視、バックアップと復元、異なる戦略を定義しているいくつかの例と、その他の管理タスクは、各パーティション内のデータの重要性に基づきます。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>運用上の柔軟性を提供します。<ept id="1">&lt;/strong&gt;</ept>.分割操作を微調整、管理効率を最大化することやコストを最小限に抑えるのための多くの機会を提供しています。管理、監視、バックアップと復元、異なる戦略を定義しているいくつかの例と、その他の管理タスクは、各パーティション内のデータの重要性に基づきます。</target>
          </trans-unit>
          <trans-unit id="116" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>データ ストアの使用パターンと一致します。<ept id="1">&lt;/strong&gt;</ept>.分割は、コストと提供をデータに保存する組み込みの機能に基づいて、データ ストアの種類に展開する各パーティションできます。たとえば、ドキュメントはデータベースにより構造化されたデータを開催可能性があります大きなバイナリ データを blob データ ストアに格納できます。詳細情報を参照してください。 <bpt id="3CapsExtId1">&lt;link&gt;</bpt><bpt id="3CapsExtId2">&lt;linkText&gt;</bpt>多言語ソリューションの構築<ept id="3CapsExtId2">&lt;/linkText&gt;</ept><bpt id="3CapsExtId3">&lt;title&gt;</bpt><ept id="3CapsExtId3">&lt;/title&gt;</ept><ept id="3CapsExtId1">&lt;/link&gt;</ept> パターンの &amp; 『 実践ガイド 』 <bpt id="5CapsExtId1">&lt;link&gt;</bpt><bpt id="5CapsExtId2">&lt;linkText&gt;</bpt>拡張性の高いソリューションのデータ アクセス: SQL、NoSQL は、および多言語の永続性を使用して<ept id="5CapsExtId2">&lt;/linkText&gt;</ept><bpt id="5CapsExtId3">&lt;title&gt;</bpt><ept id="5CapsExtId3">&lt;/title&gt;</ept><ept id="5CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>データ ストアの使用パターンと一致します。<ept id="1">&lt;/strong&gt;</ept>.分割は、コストと提供をデータに保存する組み込みの機能に基づいて、データ ストアの種類に展開する各パーティションできます。たとえば、ドキュメントはデータベースにより構造化されたデータを開催可能性があります大きなバイナリ データを blob データ ストアに格納できます。詳細情報を参照してください。 <bpt id="3CapsExtId1">&lt;link&gt;</bpt><bpt id="3CapsExtId2">&lt;linkText&gt;</bpt>多言語ソリューションの構築<ept id="3CapsExtId2">&lt;/linkText&gt;</ept><bpt id="3CapsExtId3">&lt;title&gt;</bpt><ept id="3CapsExtId3">&lt;/title&gt;</ept><ept id="3CapsExtId1">&lt;/link&gt;</ept> パターンの &amp; 『 実践ガイド 』 <bpt id="5CapsExtId1">&lt;link&gt;</bpt><bpt id="5CapsExtId2">&lt;linkText&gt;</bpt>拡張性の高いソリューションのデータ アクセス: SQL、NoSQL は、および多言語の永続性を使用して<ept id="5CapsExtId2">&lt;/linkText&gt;</ept><bpt id="5CapsExtId3">&lt;title&gt;</bpt><ept id="5CapsExtId3">&lt;/title&gt;</ept><ept id="5CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</target>
          </trans-unit>
          <trans-unit id="117" xml:space="preserve">
            <source>いくつかのシステムでは、それは利点ではなく、オーバーヘッドと見なされますので、分割を実装していません。この理論的根拠のための一般的な理由があります。</source>
            <target state="new">いくつかのシステムでは、それは利点ではなく、オーバーヘッドと見なされますので、分割を実装していません。この理論的根拠のための一般的な理由があります。</target>
          </trans-unit>
          <trans-unit id="118" xml:space="preserve">
            <source>多くのデータ ・ ストレージ ・ システムは、パーティション間で結合をサポートしていないとそれは分割システムで参照整合性を維持することは困難することができます。それは頻繁に結合を実装する必要と整合性チェック アプリケーション コード (パーティション分割の層) では、追加の I/O およびアプリケーションの複雑さになることができます。</source>
            <target state="new">多くのデータ ・ ストレージ ・ システムは、パーティション間で結合をサポートしていないとそれは分割システムで参照整合性を維持することは困難することができます。それは頻繁に結合を実装する必要と整合性チェック アプリケーション コード (パーティション分割の層) では、追加の I/O およびアプリケーションの複雑さになることができます。</target>
          </trans-unit>
          <trans-unit id="119" xml:space="preserve">
            <source>パーティションを維持は、常に簡単な作業ではありません。システム データは揮発性では、定期的に競合ホット スポットを減らすためにパーティションを再調整する必要があります。</source>
            <target state="new">パーティションを維持は、常に簡単な作業ではありません。システム データは揮発性では、定期的に競合ホット スポットを減らすためにパーティションを再調整する必要があります。</target>
          </trans-unit>
          <trans-unit id="120" xml:space="preserve">
            <source>いくつかの一般的なツールは分割されたデータが当然働かない。</source>
            <target state="new">いくつかの一般的なツールは分割されたデータが当然働かない。</target>
          </trans-unit>
          <trans-unit id="121" xml:space="preserve">
            <source>パーティションの設計</source>
            <target state="new">パーティションの設計</target>
          </trans-unit>
          <trans-unit id="122" xml:space="preserve">
            <source>さまざまな方法でデータを分割することができます: 水平方向、垂直方向、または機能的。選択した戦略は、アプリケーションおよびデータを使用するサービスの要件、データのパーティション分割の理由によって異なります。</source>
            <target state="new">さまざまな方法でデータを分割することができます: 水平方向、垂直方向、または機能的。選択した戦略は、アプリケーションおよびデータを使用するサービスの要件、データのパーティション分割の理由によって異なります。</target>
          </trans-unit>
          <trans-unit id="123" xml:space="preserve">
            <source>[AZURE。メモ] このガイドで説明しているパーティション分割方式は、基になるデータ ストレージ技術に依存しない方法で説明します。彼らは、多くの種類のデータ ストア、リレーショナルを含むと NoSQL データベースに適用できます。</source>
            <target state="new">[AZURE。メモ] このガイドで説明しているパーティション分割方式は、基になるデータ ストレージ技術に依存しない方法で説明します。彼らは、多くの種類のデータ ストア、リレーショナルを含むと NoSQL データベースに適用できます。</target>
          </trans-unit>
          <trans-unit id="124" xml:space="preserve">
            <source>パーティション分割の方法</source>
            <target state="new">パーティション分割の方法</target>
          </trans-unit>
          <trans-unit id="125" xml:space="preserve">
            <source>データのパーティション分割の 3 つの代表的な戦略は次のとおりです。</source>
            <target state="new">データのパーティション分割の 3 つの代表的な戦略は次のとおりです。</target>
          </trans-unit>
          <trans-unit id="126" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>行方向の分割<ept id="1">&lt;/strong&gt;</ept> (呼ばれる <bpt id="3">&lt;em&gt;</bpt>sharding<ept id="3">&lt;/em&gt;</ept>).この戦略で各パーティションは独自の権利でデータ ストアが、すべてのパーティションは、同じスキーマを持ちます。各パーティションは、として知られている、 <bpt id="5">&lt;em&gt;</bpt>シャード<ept id="5">&lt;/em&gt;</ept> e コマース アプリケーションで顧客の特定のセットのすべての注文などのデータの特定のサブセットを保持しているとします。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>行方向の分割<ept id="1">&lt;/strong&gt;</ept> (呼ばれる <bpt id="3">&lt;em&gt;</bpt>sharding<ept id="3">&lt;/em&gt;</ept>).この戦略で各パーティションは独自の権利でデータ ストアが、すべてのパーティションは、同じスキーマを持ちます。各パーティションは、として知られている、 <bpt id="5">&lt;em&gt;</bpt>シャード<ept id="5">&lt;/em&gt;</ept> e コマース アプリケーションで顧客の特定のセットのすべての注文などのデータの特定のサブセットを保持しているとします。</target>
          </trans-unit>
          <trans-unit id="127" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>列方向の分割<ept id="1">&lt;/strong&gt;</ept>.この戦略で各パーティションはデータ ストア内の項目のフィールドのサブセットを保持します。フィールドが 1 つの垂直方向のパーティションと別のアクセス頻度の低いフィールドで頻繁にアクセスされるフィールドを配置するなど、使用の彼らのパターンに従って分かれています。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>列方向の分割<ept id="1">&lt;/strong&gt;</ept>.この戦略で各パーティションはデータ ストア内の項目のフィールドのサブセットを保持します。フィールドが 1 つの垂直方向のパーティションと別のアクセス頻度の低いフィールドで頻繁にアクセスされるフィールドを配置するなど、使用の彼らのパターンに従って分かれています。</target>
          </trans-unit>
          <trans-unit id="128" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>機能分割<ept id="1">&lt;/strong&gt;</ept>.この方法ではデータはシステムの各境界コンテキストによってどのように使用されるに従って集計されます。たとえば、e コマース システム、別請求のビジネス機能の実装と管理製品在庫は別の 1 つのパーティションや商品在庫データに請求書データを格納可能性があります。</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>機能分割<ept id="1">&lt;/strong&gt;</ept>.この方法ではデータはシステムの各境界コンテキストによってどのように使用されるに従って集計されます。たとえば、e コマース システム、別請求のビジネス機能の実装と管理製品在庫は別の 1 つのパーティションや商品在庫データに請求書データを格納可能性があります。</target>
          </trans-unit>
          <trans-unit id="129" xml:space="preserve">
            <source>ここで説明した 3 つの戦略を結合することができることに注意することが重要です。 彼らは相互に排他的ではないと、パーティション分割スキームを設計するときそれらをすべて検討してください。たとえば、破片にデータを分割し、各シャードのデータをさらに分割する垂直分割を使用可能性があります。同様に、機能のパーティション内のデータは、(これも垂直方向に分割でき) 破片に裂けるかもしれない。</source>
            <target state="new">ここで説明した 3 つの戦略を結合することができることに注意することが重要です。 彼らは相互に排他的ではないと、パーティション分割スキームを設計するときそれらをすべて検討してください。たとえば、破片にデータを分割し、各シャードのデータをさらに分割する垂直分割を使用可能性があります。同様に、機能のパーティション内のデータは、(これも垂直方向に分割でき) 破片に裂けるかもしれない。</target>
          </trans-unit>
          <trans-unit id="130" xml:space="preserve">
            <source>ただし、それぞれの戦略のそれぞれ異なる要件は、全体的なデータ処理システムのパフォーマンス目標を満たしているパーティション分割スキームを設計するとき数を評価する必要があります競合する問題とバランスを上げることができます。次のセクションの各戦略の詳細を探索します。</source>
            <target state="new">ただし、それぞれの戦略のそれぞれ異なる要件は、全体的なデータ処理システムのパフォーマンス目標を満たしているパーティション分割スキームを設計するとき数を評価する必要があります競合する問題とバランスを上げることができます。次のセクションの各戦略の詳細を探索します。</target>
          </trans-unit>
          <trans-unit id="131" xml:space="preserve">
            <source>水平分割 (分割)</source>
            <target state="new">水平分割 (分割)</target>
          </trans-unit>
          <trans-unit id="132" xml:space="preserve">
            <source>水平分割または分割の概要を図 1 に示します。この例では、製品のインベントリ データは、プロダクト キーに基づいて破片に分かれています。各シャードでは、アルファベット順の破片キー (A G および H Z) の連続した範囲のデータを保持します。</source>
            <target state="new">水平分割または分割の概要を図 1 に示します。この例では、製品のインベントリ データは、プロダクト キーに基づいて破片に分かれています。各シャードでは、アルファベット順の破片キー (A G および H Z) の連続した範囲のデータを保持します。</target>
          </trans-unit>
          <trans-unit id="133" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="134" xml:space="preserve">
            <source>_図 1。-水平方向のパーティション キーに基づいて (シャーディング) データのパーティション分割_</source>
            <target state="new">_図 1。-水平方向のパーティション キーに基づいて (シャーディング) データのパーティション分割_</target>
          </trans-unit>
          <trans-unit id="135" xml:space="preserve">
            <source>Sharding を複数のコンピューターに負荷を分散することができます。競合を抑え、パフォーマンスを向上させます。さらに追加のサーバーで実行されている破片を追加することによって、システムを拡張できます。</source>
            <target state="new">Sharding を複数のコンピューターに負荷を分散することができます。競合を抑え、パフォーマンスを向上させます。さらに追加のサーバーで実行されている破片を追加することによって、システムを拡張できます。</target>
          </trans-unit>
          <trans-unit id="136" xml:space="preserve">
            <source>The most important factor when implementing this partitioning strategy is the choice of sharding key.</source>
            <target state="new">The most important factor when implementing this partitioning strategy is the choice of sharding key.</target>
          </trans-unit>
          <trans-unit id="137" xml:space="preserve">
            <source>It can be difficult to change the key after the system is in operation.</source>
            <target state="new">It can be difficult to change the key after the system is in operation.</target>
          </trans-unit>
          <trans-unit id="138" xml:space="preserve">
            <source>The key must ensure that data is partitioned so that the workload is as even as possible across the shards.</source>
            <target state="new">The key must ensure that data is partitioned so that the workload is as even as possible across the shards.</target>
          </trans-unit>
          <trans-unit id="139" xml:space="preserve">
            <source>Note that different shards do not have to contain similar volumes of data, rather the important consideration is to balance the number of requests; some shards may be very large but each item is the subject of a low number of access operations, while other shards may be smaller but each item is accessed much more frequently.</source>
            <target state="new">Note that different shards do not have to contain similar volumes of data, rather the important consideration is to balance the number of requests; some shards may be very large but each item is the subject of a low number of access operations, while other shards may be smaller but each item is accessed much more frequently.</target>
          </trans-unit>
          <trans-unit id="140" xml:space="preserve">
            <source>It is also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store being used to host that shard.</source>
            <target state="new">It is also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store being used to host that shard.</target>
          </trans-unit>
          <trans-unit id="141" xml:space="preserve">
            <source>分割方式は、ホット スポット (またはパーティション) の作成を避ける必要がありますもパフォーマンスと可用性に影響する可能性があります。たとえば、顧客の名前の最初の文字ではなく顧客の識別子のハッシュを使用すると、一般的なより少なく共通の頭文字からなる不均衡ができなくなります。これのパーティション間でより均等にデータを分散することができます典型的な技法です。</source>
            <target state="new">分割方式は、ホット スポット (またはパーティション) の作成を避ける必要がありますもパフォーマンスと可用性に影響する可能性があります。たとえば、顧客の名前の最初の文字ではなく顧客の識別子のハッシュを使用すると、一般的なより少なく共通の頭文字からなる不均衡ができなくなります。これのパーティション間でより均等にデータを分散することができます典型的な技法です。</target>
          </trans-unit>
          <trans-unit id="142" xml:space="preserve">
            <source>The sharding key you choose should minimize any future requirements to split large shards into smaller pieces, coalesce small shards into larger partitions, or change the schema that describes the data stored in a set of partitions.</source>
            <target state="new">The sharding key you choose should minimize any future requirements to split large shards into smaller pieces, coalesce small shards into larger partitions, or change the schema that describes the data stored in a set of partitions.</target>
          </trans-unit>
          <trans-unit id="143" xml:space="preserve">
            <source>These operations can be very time consuming, and may require taking one or more shards offline while they are performed.</source>
            <target state="new">These operations can be very time consuming, and may require taking one or more shards offline while they are performed.</target>
          </trans-unit>
          <trans-unit id="144" xml:space="preserve">
            <source>If shards are replicated, it may be possible to keep some of the replicas online while others are split, merged, or reconfigured, but the system may need to limit the operations that can be performed on the data in these shards while the reconfiguration is taking place.</source>
            <target state="new">If shards are replicated, it may be possible to keep some of the replicas online while others are split, merged, or reconfigured, but the system may need to limit the operations that can be performed on the data in these shards while the reconfiguration is taking place.</target>
          </trans-unit>
          <trans-unit id="145" xml:space="preserve">
            <source>For example, the data in the replicas could be marked as read-only to limit the scope of any inconsistences that could otherwise occur while shards are being restructured.</source>
            <target state="new">For example, the data in the replicas could be marked as read-only to limit the scope of any inconsistences that could otherwise occur while shards are being restructured.</target>
          </trans-unit>
          <trans-unit id="146" xml:space="preserve">
            <source>詳細な情報、これらの考慮事項の多くについてのガイダンスおよび良い実践テクニックを実装する水平分割、保存データのデザインをご覧ください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept></source>
            <target state="new">詳細な情報、これらの考慮事項の多くについてのガイダンスおよび良い実践テクニックを実装する水平分割、保存データのデザインをご覧ください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept></target>
          </trans-unit>
          <trans-unit id="147" xml:space="preserve">
            <source>列方向の分割</source>
            <target state="new">列方向の分割</target>
          </trans-unit>
          <trans-unit id="148" xml:space="preserve">
            <source>列方向の分割の最も一般的な用途は、I/O を削減してアイテムをフェッチに関連するパフォーマンス コストは最も頻繁にアクセスされます。図 2 データ項目ごとに異なるプロパティが異なるパーティションで開催される、列方向の分割の例の概要を示しています。名前、説明、および製品の価格情報は株式または最終注文日のボリュームよりも頻繁にアクセスされます。</source>
            <target state="new">列方向の分割の最も一般的な用途は、I/O を削減してアイテムをフェッチに関連するパフォーマンス コストは最も頻繁にアクセスされます。図 2 データ項目ごとに異なるプロパティが異なるパーティションで開催される、列方向の分割の例の概要を示しています。名前、説明、および製品の価格情報は株式または最終注文日のボリュームよりも頻繁にアクセスされます。</target>
          </trans-unit>
          <trans-unit id="149" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="150" xml:space="preserve">
            <source>_図 2。-垂直使用のパターンによってデータのパーティション分割_</source>
            <target state="new">_図 2。-垂直使用のパターンによってデータのパーティション分割_</target>
          </trans-unit>
          <trans-unit id="151" xml:space="preserve">
            <source>この例では、アプリケーションは、顧客に製品の詳細を表示するときに、製品名、説明、および価格一緒を定期的に照会します。製品を製造元からに最後に注文した日付と在庫レベルは、これらの 2 つの項目は一緒によく使用されるため別のパーティションに保持されます。このパーティション スキームが追加の利点を比較的低速で移動データ (製品名、説明、および価格) がより動的なデータ (株価レベルおよび最後の順序の日付) から切り離されていること。アプリケーションは、頻繁にアクセスする場合メモリ内の低速移動データをキャッシュに有益かもしれません。</source>
            <target state="new">この例では、アプリケーションは、顧客に製品の詳細を表示するときに、製品名、説明、および価格一緒を定期的に照会します。製品を製造元からに最後に注文した日付と在庫レベルは、これらの 2 つの項目は一緒によく使用されるため別のパーティションに保持されます。このパーティション スキームが追加の利点を比較的低速で移動データ (製品名、説明、および価格) がより動的なデータ (株価レベルおよび最後の順序の日付) から切り離されていること。アプリケーションは、頻繁にアクセスする場合メモリ内の低速移動データをキャッシュに有益かもしれません。</target>
          </trans-unit>
          <trans-unit id="152" xml:space="preserve">
            <source>このパーティション分割戦略のもう 1 つの一般的なシナリオは、機密データのセキュリティを高めるためです。たとえば、によってクレジット カード番号と対応するカード セキュリティ検証番号を別々 のパーティションに格納します。</source>
            <target state="new">このパーティション分割戦略のもう 1 つの一般的なシナリオは、機密データのセキュリティを高めるためです。たとえば、によってクレジット カード番号と対応するカード セキュリティ検証番号を別々 のパーティションに格納します。</target>
          </trans-unit>
          <trans-unit id="153" xml:space="preserve">
            <source>列方向の分割も、データに必要な同時アクセスの量を減らすことができます。</source>
            <target state="new">列方向の分割も、データに必要な同時アクセスの量を減らすことができます。</target>
          </trans-unit>
          <trans-unit id="154" xml:space="preserve">
            <source>部分的から打破するエンティティの正規化、データ ストア内のエンティティ レベルで動作する垂直分割、 <bpt id="2">&lt;em&gt;</bpt>広い<ept id="2">&lt;/em&gt;</ept> 項目のセットを <bpt id="4">&lt;em&gt;</bpt>絞り込む<ept id="4">&lt;/em&gt;</ept> アイテム。列指向データ ストア HBase やカサンドラなどに最適です。列のコレクションにデータを変更する可能性がありますできない場合、SQL Server では列に保存を使用してまた考慮できます。</source>
            <target state="new">部分的から打破するエンティティの正規化、データ ストア内のエンティティ レベルで動作する垂直分割、 <bpt id="2">&lt;em&gt;</bpt>広い<ept id="2">&lt;/em&gt;</ept> 項目のセットを <bpt id="4">&lt;em&gt;</bpt>絞り込む<ept id="4">&lt;/em&gt;</ept> アイテム。列指向データ ストア HBase やカサンドラなどに最適です。列のコレクションにデータを変更する可能性がありますできない場合、SQL Server では列に保存を使用してまた考慮できます。</target>
          </trans-unit>
          <trans-unit id="155" xml:space="preserve">
            <source>機能分割</source>
            <target state="new">機能分割</target>
          </trans-unit>
          <trans-unit id="156" xml:space="preserve">
            <source>システムは、それぞれ異なるビジネス領域またはアプリケーション内のサービスのための境界コンテキストを識別するために、機能的なパーティショニングは、分離とデータ アクセスのパフォーマンスを向上させる手法を提供します。機能分割の別の一般的な用途は、読み取り/書き込みデータ レポートのために使用される読み取り専用のデータから分離することです。図 3 は、インベントリ データ、顧客データから分離されている機能的なパーティショニングの概要を示します。</source>
            <target state="new">システムは、それぞれ異なるビジネス領域またはアプリケーション内のサービスのための境界コンテキストを識別するために、機能的なパーティショニングは、分離とデータ アクセスのパフォーマンスを向上させる手法を提供します。機能分割の別の一般的な用途は、読み取り/書き込みデータ レポートのために使用される読み取り専用のデータから分離することです。図 3 は、インベントリ データ、顧客データから分離されている機能的なパーティショニングの概要を示します。</target>
          </trans-unit>
          <trans-unit id="157" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="158" xml:space="preserve">
            <source>_図 3。-機能的境界コンテキストまたはサブドメインによってデータのパーティション分割_</source>
            <target state="new">_図 3。-機能的境界コンテキストまたはサブドメインによってデータのパーティション分割_</target>
          </trans-unit>
          <trans-unit id="159" xml:space="preserve">
            <source>このパーティション分割戦略は、システムのさまざまな部分の間でデータ アクセスの競合を減らすために助けることができます。</source>
            <target state="new">このパーティション分割戦略は、システムのさまざまな部分の間でデータ アクセスの競合を減らすために助けることができます。</target>
          </trans-unit>
          <trans-unit id="160" xml:space="preserve">
            <source>スケーラビリティのためのパーティションの設計</source>
            <target state="new">スケーラビリティのためのパーティションの設計</target>
          </trans-unit>
          <trans-unit id="161" xml:space="preserve">
            <source>サイズと各パーティションの作業負荷を考慮し、最大のスケーラビリティを実現するデータが分散されるようにそれらのバランスが重要です。ただし、1 つのパーティション ストアのスケーラビリティの制限を超えないようには、データをパーティション分割してもする必要があります。</source>
            <target state="new">サイズと各パーティションの作業負荷を考慮し、最大のスケーラビリティを実現するデータが分散されるようにそれらのバランスが重要です。ただし、1 つのパーティション ストアのスケーラビリティの制限を超えないようには、データをパーティション分割してもする必要があります。</target>
          </trans-unit>
          <trans-unit id="162" xml:space="preserve">
            <source>スケーラビリティのパーティションを設計する際は、以下の手順を実行。</source>
            <target state="new">スケーラビリティのパーティションを設計する際は、以下の手順を実行。</target>
          </trans-unit>
          <trans-unit id="163" xml:space="preserve">
            <source>各クエリによって返される結果セットのサイズなどのデータ アクセス パターンを理解するためにアプリケーションの分析、アクセス、固有のレイテンシー、およびサーバー側の周波数計算処理の要件。多くの場合、いくつかの主要なエンティティの処理リソースのほとんどを要求します。</source>
            <target state="new">各クエリによって返される結果セットのサイズなどのデータ アクセス パターンを理解するためにアプリケーションの分析、アクセス、固有のレイテンシー、およびサーバー側の周波数計算処理の要件。多くの場合、いくつかの主要なエンティティの処理リソースのほとんどを要求します。</target>
          </trans-unit>
          <trans-unit id="164" xml:space="preserve">
            <source>分析に基づいて、現在および将来の拡張ターゲット データのサイズと、ワークロードなどを決定し、スケーラビリティの目標を達成するパーティションに、データを分散します。水平方向のパーティション分割戦略の適切な破片のキーを選択配布が偶数かどうかを確認することが重要です。詳細については"を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</source>
            <target state="new">分析に基づいて、現在および将来の拡張ターゲット データのサイズと、ワークロードなどを決定し、スケーラビリティの目標を達成するパーティションに、データを分散します。水平方向のパーティション分割戦略の適切な破片のキーを選択配布が偶数かどうかを確認することが重要です。詳細については"を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="165" xml:space="preserve">
            <source>Make sure that the resources available to each partition are sufficient to handle the scalability requirements in terms of data size and throughput.</source>
            <target state="new">Make sure that the resources available to each partition are sufficient to handle the scalability requirements in terms of data size and throughput.</target>
          </trans-unit>
          <trans-unit id="166" xml:space="preserve">
            <source>For example, the node hosting a partition might impose a hard limit on the amount of storage space, processing power, or network bandwidth that it provides.</source>
            <target state="new">For example, the node hosting a partition might impose a hard limit on the amount of storage space, processing power, or network bandwidth that it provides.</target>
          </trans-unit>
          <trans-unit id="167" xml:space="preserve">
            <source>If the data storage and processing requirements are likely to exceed these limits it may be necessary to refine your partitioning strategy or split data out further.</source>
            <target state="new">If the data storage and processing requirements are likely to exceed these limits it may be necessary to refine your partitioning strategy or split data out further.</target>
          </trans-unit>
          <trans-unit id="168" xml:space="preserve">
            <source>For example, one scalability approach might be to separate logging data from the core application features by using separate data stores to prevent the total data storage requirements exceeding the scaling limit of the node.</source>
            <target state="new">For example, one scalability approach might be to separate logging data from the core application features by using separate data stores to prevent the total data storage requirements exceeding the scaling limit of the node.</target>
          </trans-unit>
          <trans-unit id="169" xml:space="preserve">
            <source>If the total number of data stores exceeds the node limit, it may be necessary to use separate storage nodes.</source>
            <target state="new">If the total number of data stores exceeds the node limit, it may be necessary to use separate storage nodes.</target>
          </trans-unit>
          <trans-unit id="170" xml:space="preserve">
            <source>期待どおりにデータを分散して、パーティションが彼らに課せられた負荷を処理できることを確認する使用の下でシステムを監視します。それは使用のパーティションを再調整することが可能かもしれない分析による予想が一致しないことが可能かもしれない。失敗すると、必要なバランスを得るためにシステムの一部を再設計する必要がある場合があります。</source>
            <target state="new">期待どおりにデータを分散して、パーティションが彼らに課せられた負荷を処理できることを確認する使用の下でシステムを監視します。それは使用のパーティションを再調整することが可能かもしれない分析による予想が一致しないことが可能かもしれない。失敗すると、必要なバランスを得るためにシステムの一部を再設計する必要がある場合があります。</target>
          </trans-unit>
          <trans-unit id="171" xml:space="preserve">
            <source>いくつかのクラウド環境インフラの境界面でのリソースの割り当て、選択した境界の制限がデータ ストレージ、処理能力、および帯域幅の面でのデータ量での予測成長に十分なスペースを提供することを確保する必要がありますに注意してください。たとえば、Azure テーブル ストレージを使用する場合は忙しいシャードは要求を処理する 1 つのパーティションに使用できるよりも多くのリソースを必要があります (一定の時間で 1 つのパーティションで処理できる要求の量に限界がある-をご覧ください <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft のウェブサイトに詳細については)。この場合、シャードは、負荷を分散する分割する必要があります。合計サイズ、またはこれらのテーブルのスループットは、ストレージ アカウントの容量を超えた場合、追加のストレージ アカウントを作成し、これらのアカウントにテーブルを分散する必要があります。ストレージ アカウント数は、サブスクリプションに使用できるアカウントの数を超えた場合、複数のサブスクリプションを使用する必要あります。</source>
            <target state="new">いくつかのクラウド環境インフラの境界面でのリソースの割り当て、選択した境界の制限がデータ ストレージ、処理能力、および帯域幅の面でのデータ量での予測成長に十分なスペースを提供することを確保する必要がありますに注意してください。たとえば、Azure テーブル ストレージを使用する場合は忙しいシャードは要求を処理する 1 つのパーティションに使用できるよりも多くのリソースを必要があります (一定の時間で 1 つのパーティションで処理できる要求の量に限界がある-をご覧ください <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft のウェブサイトに詳細については)。この場合、シャードは、負荷を分散する分割する必要があります。合計サイズ、またはこれらのテーブルのスループットは、ストレージ アカウントの容量を超えた場合、追加のストレージ アカウントを作成し、これらのアカウントにテーブルを分散する必要があります。ストレージ アカウント数は、サブスクリプションに使用できるアカウントの数を超えた場合、複数のサブスクリプションを使用する必要あります。</target>
          </trans-unit>
          <trans-unit id="172" xml:space="preserve">
            <source>クエリのパフォーマンスのためのパーティションの設計</source>
            <target state="new">クエリのパフォーマンスのためのパーティションの設計</target>
          </trans-unit>
          <trans-unit id="173" xml:space="preserve">
            <source>小さいデータ セットとクエリの並列実行を使用してクエリのパフォーマンスを強化多くの場合ことができます。各パーティションは、データ セット全体の小さな割合を含める必要があり、このボリュームの縮小は、クエリのパフォーマンスを向上できます。ただし、分割の設計およびデータベースを適切に構成するための代替手段ではありません。たとえば、リレーショナル データベースを使用する場合の場所で必要なインデックスがあることを確認します。</source>
            <target state="new">小さいデータ セットとクエリの並列実行を使用してクエリのパフォーマンスを強化多くの場合ことができます。各パーティションは、データ セット全体の小さな割合を含める必要があり、このボリュームの縮小は、クエリのパフォーマンスを向上できます。ただし、分割の設計およびデータベースを適切に構成するための代替手段ではありません。たとえば、リレーショナル データベースを使用する場合の場所で必要なインデックスがあることを確認します。</target>
          </trans-unit>
          <trans-unit id="174" xml:space="preserve">
            <source>クエリのパフォーマンスのパーティションを設計する際は、以下の手順を実行。</source>
            <target state="new">クエリのパフォーマンスのパーティションを設計する際は、以下の手順を実行。</target>
          </trans-unit>
          <trans-unit id="175" xml:space="preserve">
            <source>アプリケーションの要件とパフォーマンスを調べます。</source>
            <target state="new">アプリケーションの要件とパフォーマンスを調べます。</target>
          </trans-unit>
          <trans-unit id="176" xml:space="preserve">
            <source>ビジネス要件を使用して、常に迅速に実行する必要があります重要なクエリを調べます。</source>
            <target state="new">ビジネス要件を使用して、常に迅速に実行する必要があります重要なクエリを調べます。</target>
          </trans-unit>
          <trans-unit id="177" xml:space="preserve">
            <source>ゆっくりとを実行するクエリを識別するためにシステムを監視します。</source>
            <target state="new">ゆっくりとを実行するクエリを識別するためにシステムを監視します。</target>
          </trans-unit>
          <trans-unit id="178" xml:space="preserve">
            <source>確立どのクエリが最も頻繁に行われます。各クエリの単一のインスタンスが最小のコスト、リソースの累積消費量は大きな可能性があります。異なるパーティション、またはもキャッシュにこれらのクエリによって取得されたデータを分離する有益なことがあります。</source>
            <target state="new">確立どのクエリが最も頻繁に行われます。各クエリの単一のインスタンスが最小のコスト、リソースの累積消費量は大きな可能性があります。異なるパーティション、またはもキャッシュにこれらのクエリによって取得されたデータを分離する有益なことがあります。</target>
          </trans-unit>
          <trans-unit id="179" xml:space="preserve">
            <source>パフォーマンスの低下の原因となっているデータをパーティション分割します。確認します。</source>
            <target state="new">パフォーマンスの低下の原因となっているデータをパーティション分割します。確認します。</target>
          </trans-unit>
          <trans-unit id="180" xml:space="preserve">
            <source>クエリの応答時間がターゲット内にあるので、各パーティションのサイズを制限します。</source>
            <target state="new">クエリの応答時間がターゲット内にあるので、各パーティションのサイズを制限します。</target>
          </trans-unit>
          <trans-unit id="181" xml:space="preserve">
            <source>水平パーティショニングを実装する場合、アプリケーションは、パーティションを見つける簡単にできる方法でシャード キーを設計します。これは、すべてのパーティションをスキャンする必要があるクエリを防ぎます。</source>
            <target state="new">水平パーティショニングを実装する場合、アプリケーションは、パーティションを見つける簡単にできる方法でシャード キーを設計します。これは、すべてのパーティションをスキャンする必要があるクエリを防ぎます。</target>
          </trans-unit>
          <trans-unit id="182" xml:space="preserve">
            <source>クエリのパフォーマンスのパーティションの位置を考慮します。可能であれば、アプリケーションとそれにアクセスするユーザーの近くに地理的にあるパーティションにデータを保持しようとします。</source>
            <target state="new">クエリのパフォーマンスのパーティションの位置を考慮します。可能であれば、アプリケーションとそれにアクセスするユーザーの近くに地理的にあるパーティションにデータを保持しようとします。</target>
          </trans-unit>
          <trans-unit id="183" xml:space="preserve">
            <source>エンティティにスループットとクエリのパフォーマンス要件がある場合は、そのエンティティに基づく機能のパーティション分割を使用します。これはまだ要件を満たすことができませんが場合、は、同様の水平パーティションを適用します。ほとんどの場合 1 つのパーティション分割戦略で十分ですが、いくつかのケースで両方の方法を組み合わせることが効率的です。</source>
            <target state="new">エンティティにスループットとクエリのパフォーマンス要件がある場合は、そのエンティティに基づく機能のパーティション分割を使用します。これはまだ要件を満たすことができませんが場合、は、同様の水平パーティションを適用します。ほとんどの場合 1 つのパーティション分割戦略で十分ですが、いくつかのケースで両方の方法を組み合わせることが効率的です。</target>
          </trans-unit>
          <trans-unit id="184" xml:space="preserve">
            <source>パフォーマンスを向上させるパーティションで同時に実行される非同期クエリを使用してください。</source>
            <target state="new">パフォーマンスを向上させるパーティションで同時に実行される非同期クエリを使用してください。</target>
          </trans-unit>
          <trans-unit id="185" xml:space="preserve">
            <source>可用性のためのパーティションの設計</source>
            <target state="new">可用性のためのパーティションの設計</target>
          </trans-unit>
          <trans-unit id="186" xml:space="preserve">
            <source>データを分割すると、データセット全体が単一障害点を構成しないし、データセットの個別のサブセットに管理できる独立を確保することによってアプリケーションの可用性が向上します。重要なデータを含むパーティションをレプリケートする可用性を改善できます。</source>
            <target state="new">データを分割すると、データセット全体が単一障害点を構成しないし、データセットの個別のサブセットに管理できる独立を確保することによってアプリケーションの可用性が向上します。重要なデータを含むパーティションをレプリケートする可用性を改善できます。</target>
          </trans-unit>
          <trans-unit id="187" xml:space="preserve">
            <source>デザイン パーティションを実装すると、可用性に影響する次の要因を考慮します。</source>
            <target state="new">デザイン パーティションを実装すると、可用性に影響する次の要因を考慮します。</target>
          </trans-unit>
          <trans-unit id="188" xml:space="preserve">
            <source>どのように重要なデータが業務です。いくつかのデータは、請求明細や銀行取引などの重要なビジネス情報を含むことができます。その他のデータは、ログ ファイル、パフォーマンス トレースなど、重要度の低いオペレーション データだけかもしれない。各種類のデータを識別した後考慮してください。</source>
            <target state="new">どのように重要なデータが業務です。いくつかのデータは、請求明細や銀行取引などの重要なビジネス情報を含むことができます。その他のデータは、ログ ファイル、パフォーマンス トレースなど、重要度の低いオペレーション データだけかもしれない。各種類のデータを識別した後考慮してください。</target>
          </trans-unit>
          <trans-unit id="189" xml:space="preserve">
            <source>適切なバックアップ計画と高可用性パーティションに重要なデータを格納します。</source>
            <target state="new">適切なバックアップ計画と高可用性パーティションに重要なデータを格納します。</target>
          </trans-unit>
          <trans-unit id="190" xml:space="preserve">
            <source>個別の管理と監視の機構または各データセットの異なる criticalities の手順を確立します。できるように、同じパーティション内の重要性の同じレベルを持つ場所データは、適切な頻度で一緒にバックアップされます。たとえば、銀行取引のデータを保持しているパーティションは、ログまたはトレース情報を保持しているパーティションよりも頻繁にバックアップする必要があります。</source>
            <target state="new">個別の管理と監視の機構または各データセットの異なる criticalities の手順を確立します。できるように、同じパーティション内の重要性の同じレベルを持つ場所データは、適切な頻度で一緒にバックアップされます。たとえば、銀行取引のデータを保持しているパーティションは、ログまたはトレース情報を保持しているパーティションよりも頻繁にバックアップする必要があります。</target>
          </trans-unit>
          <trans-unit id="191" xml:space="preserve">
            <source>個々 のパーティションを管理することができますどのように。独立した管理と保守をサポートするためのパーティションの設計は、いくつかの利点を提供します。たとえば。</source>
            <target state="new">個々 のパーティションを管理することができますどのように。独立した管理と保守をサポートするためのパーティションの設計は、いくつかの利点を提供します。たとえば。</target>
          </trans-unit>
          <trans-unit id="192" xml:space="preserve">
            <source>パーティションが失敗した場合、回復できるない独立して他のパーティション内のデータにアクセスするアプリケーションのインスタンスに影響を与えずに。</source>
            <target state="new">パーティションが失敗した場合、回復できるない独立して他のパーティション内のデータにアクセスするアプリケーションのインスタンスに影響を与えずに。</target>
          </trans-unit>
          <trans-unit id="193" xml:space="preserve">
            <source>地域別データの分割を各場所のオフピーク時に実行するスケジュールされた保守タスクができます。パーティションが大きすぎて、計画的なメンテナンスがこの期間中に完了していることを防ぐためにいないことを確認します。</source>
            <target state="new">地域別データの分割を各場所のオフピーク時に実行するスケジュールされた保守タスクができます。パーティションが大きすぎて、計画的なメンテナンスがこの期間中に完了していることを防ぐためにいないことを確認します。</target>
          </trans-unit>
          <trans-unit id="194" xml:space="preserve">
            <source>パーティション間で重要なデータをレプリケートするかどうか。この戦略には、整合性の問題を導入することができますも可用性とパフォーマンスを向上できます。すべてのレプリカと同期するパーティション内のデータに加えられた変更のための時間がかかるし、この期間中にパーティションの異なるさまざまなデータ値が格納されます。</source>
            <target state="new">パーティション間で重要なデータをレプリケートするかどうか。この戦略には、整合性の問題を導入することができますも可用性とパフォーマンスを向上できます。すべてのレプリカと同期するパーティション内のデータに加えられた変更のための時間がかかるし、この期間中にパーティションの異なるさまざまなデータ値が格納されます。</target>
          </trans-unit>
          <trans-unit id="195" xml:space="preserve">
            <source>問題と考慮事項</source>
            <target state="new">問題と考慮事項</target>
          </trans-unit>
          <trans-unit id="196" xml:space="preserve">
            <source>分割法を用いたデザインとシステムの開発に複雑さを追加します。システムだけ最初 1 つのパーティションが含まれる場合でも、システム設計の基本的な部分としてパーティション分割を検討することが重要です。維持するためにライブ システムがある今分割システムのパフォーマンスとスケーラビリティの問題に苦しむ起動時に付け足しだけおそらくあなたの複雑さを増加させるように対処します。だけでなくデータ アクセス ロジックの変更が必要になりますこの環境でパーティション分割を組み込むシステムを更新、それはまた、移行を含むことができる既存のデータに分散パーティション、しばしばユーザー システムを使用し続けることができることを期待しながらの大量。</source>
            <target state="new">分割法を用いたデザインとシステムの開発に複雑さを追加します。システムだけ最初 1 つのパーティションが含まれる場合でも、システム設計の基本的な部分としてパーティション分割を検討することが重要です。維持するためにライブ システムがある今分割システムのパフォーマンスとスケーラビリティの問題に苦しむ起動時に付け足しだけおそらくあなたの複雑さを増加させるように対処します。だけでなくデータ アクセス ロジックの変更が必要になりますこの環境でパーティション分割を組み込むシステムを更新、それはまた、移行を含むことができる既存のデータに分散パーティション、しばしばユーザー システムを使用し続けることができることを期待しながらの大量。</target>
          </trans-unit>
          <trans-unit id="197" xml:space="preserve">
            <source>いくつかのケースで分割不可能である重要な初期データセットが小さい、単一のサーバーで簡単に処理することができます。初期サイズを超えたスケールと予想されていないシステムでもこれが多くの商用システムは、増加するユーザーの数に応じて拡張できる必要があります。この拡張は通常データ量の増加を伴います。また、分割がない常に大きなデータ ストアの機能を理解する必要があります。たとえば、数百の同時実行クライアントによって小さなデータ ストアを大きくアクセス可能性があります。この状況でデータをパーティション分割は、競合を減らし、スループットを向上させるのに役立ちます。</source>
            <target state="new">いくつかのケースで分割不可能である重要な初期データセットが小さい、単一のサーバーで簡単に処理することができます。初期サイズを超えたスケールと予想されていないシステムでもこれが多くの商用システムは、増加するユーザーの数に応じて拡張できる必要があります。この拡張は通常データ量の増加を伴います。また、分割がない常に大きなデータ ストアの機能を理解する必要があります。たとえば、数百の同時実行クライアントによって小さなデータ ストアを大きくアクセス可能性があります。この状況でデータをパーティション分割は、競合を減らし、スループットを向上させるのに役立ちます。</target>
          </trans-unit>
          <trans-unit id="198" xml:space="preserve">
            <source>データ パーティション分割スキームを設計するときは、次の点を考慮してください。</source>
            <target state="new">データ パーティション分割スキームを設計するときは、次の点を考慮してください。</target>
          </trans-unit>
          <trans-unit id="199" xml:space="preserve">
            <source>可能であれば、最も一般的なデータベース操作のためのデータを各パーティション クロス パーティション データ アクセス操作を最小限に抑えるために一緒にしてください。1 つのパーティション内でのみクエリを実行するよりも時間がかかるすることができますパーティション間でのクエリが、クエリの 1 つのセットに対してパーティションの最適化とクエリの他のセットに悪影響を及ぼす可能性があります。これは避けられません、パーティション間で、クエリ時間を最小限に抑えるパーティション上の並列クエリを実行、アプリケーション内で結果を集計します。ただし、この方法も、1 つのクエリから結果を取得し、次のクエリで使用する必要がある場合など、いくつかのケースでことができない場合があります。</source>
            <target state="new">可能であれば、最も一般的なデータベース操作のためのデータを各パーティション クロス パーティション データ アクセス操作を最小限に抑えるために一緒にしてください。1 つのパーティション内でのみクエリを実行するよりも時間がかかるすることができますパーティション間でのクエリが、クエリの 1 つのセットに対してパーティションの最適化とクエリの他のセットに悪影響を及ぼす可能性があります。これは避けられません、パーティション間で、クエリ時間を最小限に抑えるパーティション上の並列クエリを実行、アプリケーション内で結果を集計します。ただし、この方法も、1 つのクエリから結果を取得し、次のクエリで使用する必要がある場合など、いくつかのケースでことができない場合があります。</target>
          </trans-unit>
          <trans-unit id="200" xml:space="preserve">
            <source>場合は、クエリを使用する郵便番号テーブルや製品リストなどの比較的静的な参照データを使用する、すべてのパーティションを別のパーティションに別の参照操作の要件を減らすためにこのデータをレプリケートするを検討してください。このアプローチは追加コストが発生するため、この参照データ変更の同期に関連付けられているがシステム全体にわたってからの大量のトラフィックが「ホット」データセットになる参照データの可能性を削減できます。</source>
            <target state="new">場合は、クエリを使用する郵便番号テーブルや製品リストなどの比較的静的な参照データを使用する、すべてのパーティションを別のパーティションに別の参照操作の要件を減らすためにこのデータをレプリケートするを検討してください。このアプローチは追加コストが発生するため、この参照データ変更の同期に関連付けられているがシステム全体にわたってからの大量のトラフィックが「ホット」データセットになる参照データの可能性を削減できます。</target>
          </trans-unit>
          <trans-unit id="201" xml:space="preserve">
            <source>可能であれば、上下機能パーティション間で参照整合性の要件を最小限に抑えます。これらのスキームでは、アプリケーション自体がデータを更新し、消費されるときのパーティション間で参照整合性を維持する責任です。複数のパーティション間でデータを結合する必要がありますクエリをアプリケーションが通常キーと、外部キーに基づく連続したクエリを実行する必要があるために、同じパーティション内でのみデータを結合するクエリよりゆっくり実行します。代わりに、複製または重複関連データの正規化を検討します。、クロス パーティション結合が必要なクエリの時間を最小限に抑えるパーティション上の並列クエリを実行し、アプリケーション内でデータを結合します。</source>
            <target state="new">可能であれば、上下機能パーティション間で参照整合性の要件を最小限に抑えます。これらのスキームでは、アプリケーション自体がデータを更新し、消費されるときのパーティション間で参照整合性を維持する責任です。複数のパーティション間でデータを結合する必要がありますクエリをアプリケーションが通常キーと、外部キーに基づく連続したクエリを実行する必要があるために、同じパーティション内でのみデータを結合するクエリよりゆっくり実行します。代わりに、複製または重複関連データの正規化を検討します。、クロス パーティション結合が必要なクエリの時間を最小限に抑えるパーティション上の並列クエリを実行し、アプリケーション内でデータを結合します。</target>
          </trans-unit>
          <trans-unit id="202" xml:space="preserve">
            <source>パーティション構成は、パーティション間でデータの一貫性にかもしれない影響を検討してください。強い一貫性が実際に必要かどうかを評価する必要があります。代わりに、クラウドの一般的なアプローチは、最終的な一貫性を実装します。各パーティション内のデータは別々 に更新され、アプリケーション ロジックは、すべてが正常に完了する更新プログラムのための責任を取ることができる、最終的に一貫した操作の実行中にデータを照会する場合に発生する不整合を処理します。イベンチュアル ・ コンシステンシーの実装の詳細については、一貫性のガイダンスを参照してください。(#insertlink #)</source>
            <target state="new">パーティション構成は、パーティション間でデータの一貫性にかもしれない影響を検討してください。強い一貫性が実際に必要かどうかを評価する必要があります。代わりに、クラウドの一般的なアプローチは、最終的な一貫性を実装します。各パーティション内のデータは別々 に更新され、アプリケーション ロジックは、すべてが正常に完了する更新プログラムのための責任を取ることができる、最終的に一貫した操作の実行中にデータを照会する場合に発生する不整合を処理します。イベンチュアル ・ コンシステンシーの実装の詳細については、一貫性のガイダンスを参照してください。(#insertlink #)</target>
          </trans-unit>
          <trans-unit id="203" xml:space="preserve">
            <source>クエリで正しいパーティションを検索する方法を検討してください。クエリがスキャンする必要がある必要なデータを検索するすべてのパーティションは複数の並列クエリを使用した場合でも、パフォーマンスに大きな影響を与えるになります。クエリが垂直で使用され機能パーティション分割戦略は当然のことながらパーティションを指定できます。ただし、水平分割 (シャーディング) を使用して、アイテムを検索するが難しい場合すべての破片が同じスキーマを持っているので。シャーディングの典型的な解決策は、データの特定の項目のための破片の場所を検索に使用することができますマップを維持するためにです。このマップをアプリケーションの分割ロジックで実装または透明分割をサポートしている場合のデータ ストアで保持可能性があります。</source>
            <target state="new">クエリで正しいパーティションを検索する方法を検討してください。クエリがスキャンする必要がある必要なデータを検索するすべてのパーティションは複数の並列クエリを使用した場合でも、パフォーマンスに大きな影響を与えるになります。クエリが垂直で使用され機能パーティション分割戦略は当然のことながらパーティションを指定できます。ただし、水平分割 (シャーディング) を使用して、アイテムを検索するが難しい場合すべての破片が同じスキーマを持っているので。シャーディングの典型的な解決策は、データの特定の項目のための破片の場所を検索に使用することができますマップを維持するためにです。このマップをアプリケーションの分割ロジックで実装または透明分割をサポートしている場合のデータ ストアで保持可能性があります。</target>
          </trans-unit>
          <trans-unit id="204" xml:space="preserve">
            <source>水平方向のパーティション分割戦略を使用する場合は、サイズ、ホット スポットを最小限に抑えるため、クエリのパフォーマンスを最大化するため、物理記憶域の制限を回避するワークロードに均等にデータを分散する破片を定期的にリバランスすることを検討してください。しかし、これは多くの場合カスタム ツールまたはプロセスの使用を必要とする複雑なタスクです。</source>
            <target state="new">水平方向のパーティション分割戦略を使用する場合は、サイズ、ホット スポットを最小限に抑えるため、クエリのパフォーマンスを最大化するため、物理記憶域の制限を回避するワークロードに均等にデータを分散する破片を定期的にリバランスすることを検討してください。しかし、これは多くの場合カスタム ツールまたはプロセスの使用を必要とする複雑なタスクです。</target>
          </trans-unit>
          <trans-unit id="205" xml:space="preserve">
            <source>各パーティションを複製障害に対する追加の保護を提供します。1 つのレプリカが失敗した場合、作業コピーへクエリを送信できます。</source>
            <target state="new">各パーティションを複製障害に対する追加の保護を提供します。1 つのレプリカが失敗した場合、作業コピーへクエリを送信できます。</target>
          </trans-unit>
          <trans-unit id="206" xml:space="preserve">
            <source>パーティション分割戦略の物理的な限界に到達した場合は、別のレベルにスケーラビリティを拡張する必要があります。たとえば、データベース レベルでは、パーティション分割場合は可能性の位置決めや複数のデータベース パーティションをレプリケートします。データベース レベルでは既にパーティション分割、物理的な制限が問題の位置決めや複数のホストのアカウント内のパーティションをレプリケートする可能性します。</source>
            <target state="new">パーティション分割戦略の物理的な限界に到達した場合は、別のレベルにスケーラビリティを拡張する必要があります。たとえば、データベース レベルでは、パーティション分割場合は可能性の位置決めや複数のデータベース パーティションをレプリケートします。データベース レベルでは既にパーティション分割、物理的な制限が問題の位置決めや複数のホストのアカウント内のパーティションをレプリケートする可能性します。</target>
          </trans-unit>
          <trans-unit id="207" xml:space="preserve">
            <source>複数のパーティションでデータにアクセスするトランザクションは避けてください。いくつかのデータ ストアを実装のトランザクション一貫性と操作の整合性、それは 1 つのパーティションである場合にのみ、データを変更します。複数のパーティション間でのトランザクションのサポートが必要な場合は、最もパーティション システムのネイティブ サポートが提供されないため、アプリケーション ロジックの一部として実装する必要があります。</source>
            <target state="new">複数のパーティションでデータにアクセスするトランザクションは避けてください。いくつかのデータ ストアを実装のトランザクション一貫性と操作の整合性、それは 1 つのパーティションである場合にのみ、データを変更します。複数のパーティション間でのトランザクションのサポートが必要な場合は、最もパーティション システムのネイティブ サポートが提供されないため、アプリケーション ロジックの一部として実装する必要があります。</target>
          </trans-unit>
          <trans-unit id="208" xml:space="preserve">
            <source>すべてのデータ ストアには、いくつかの運用管理および監視が必要です。データの読み込み、バックアップしデータを復元する、データを再編成および正しくかつ効率的に、システムが実行されていることを確認、タスクの範囲です。</source>
            <target state="new">すべてのデータ ストアには、いくつかの運用管理および監視が必要です。データの読み込み、バックアップしデータを復元する、データを再編成および正しくかつ効率的に、システムが実行されていることを確認、タスクの範囲です。</target>
          </trans-unit>
          <trans-unit id="209" xml:space="preserve">
            <source>運用管理に影響する次の要因を考慮してください。</source>
            <target state="new">運用管理に影響する次の要因を考慮してください。</target>
          </trans-unit>
          <trans-unit id="210" xml:space="preserve">
            <source>その他の管理タスクと運用タスク データをパーティション分割すると、バックアップと復元、システムの監視、データのアーカイブなどとき、適切な管理を実装する方法を検討してください。たとえば、バックアップと復元操作中に論理的な一貫性維持は挑戦をすることができます。</source>
            <target state="new">その他の管理タスクと運用タスク データをパーティション分割すると、バックアップと復元、システムの監視、データのアーカイブなどとき、適切な管理を実装する方法を検討してください。たとえば、バックアップと復元操作中に論理的な一貫性維持は挑戦をすることができます。</target>
          </trans-unit>
          <trans-unit id="211" xml:space="preserve">
            <source>データが複数のパーティションに読み込まれ、新しい方法をすることができますどのように他の情報源から届いたデータが追加されます。いくつかのツールとユーティリティ可能性があります正しいパーティションにデータを読み込むなどの sharded データ操作をサポートしていません、だから、これは作成または新しいツールとユーティリティを取得必要があります。</source>
            <target state="new">データが複数のパーティションに読み込まれ、新しい方法をすることができますどのように他の情報源から届いたデータが追加されます。いくつかのツールとユーティリティ可能性があります正しいパーティションにデータを読み込むなどの sharded データ操作をサポートしていません、だから、これは作成または新しいツールとユーティリティを取得必要があります。</target>
          </trans-unit>
          <trans-unit id="212" xml:space="preserve">
            <source>どのようにデータをアーカイブしてパーティションの過度の成長を防ぐために (おそらく月額) 定期的に削除されます。異なるアーカイブ スキーマと一致するデータを変換する必要があります。</source>
            <target state="new">どのようにデータをアーカイブしてパーティションの過度の成長を防ぐために (おそらく月額) 定期的に削除されます。異なるアーカイブ スキーマと一致するデータを変換する必要があります。</target>
          </trans-unit>
          <trans-unit id="213" xml:space="preserve">
            <source>別の情報を参照する 1 つのパーティション内のデータなどの整合性の問題を任意のデータを検索する周期的なプロセスを実行する、この情報は不足している検討してください。プロセスでは、いずれかの試みこれらの問題を自動的に修正したり、手動で問題を修正するオペレーターにアラートを生成可能性があります。たとえば、e コマース アプリケーションでは、注文情報は、1 つのパーティションで開催されるかもしれないが、各順序を構成する品目は、別に開催されるかもしれない。注文の処理は、パーティションをわざわざデータを追加する必要があります。このプロセスが失敗した場合、ある品目間保存できる対応する注文が無い。</source>
            <target state="new">別の情報を参照する 1 つのパーティション内のデータなどの整合性の問題を任意のデータを検索する周期的なプロセスを実行する、この情報は不足している検討してください。プロセスでは、いずれかの試みこれらの問題を自動的に修正したり、手動で問題を修正するオペレーターにアラートを生成可能性があります。たとえば、e コマース アプリケーションでは、注文情報は、1 つのパーティションで開催されるかもしれないが、各順序を構成する品目は、別に開催されるかもしれない。注文の処理は、パーティションをわざわざデータを追加する必要があります。このプロセスが失敗した場合、ある品目間保存できる対応する注文が無い。</target>
          </trans-unit>
          <trans-unit id="214" xml:space="preserve">
            <source>さまざまなデータ ストレージ技術は通常、パーティション分割をサポートする独自の機能を提供します。次のセクションでは、Azure アプリケーションで一般的に使用されるデータ ストアによって実装されるオプションを要約し、これらの機能を最大限に活用することができますアプリケーションを設計するための考慮事項について説明。</source>
            <target state="new">さまざまなデータ ストレージ技術は通常、パーティション分割をサポートする独自の機能を提供します。次のセクションでは、Azure アプリケーションで一般的に使用されるデータ ストアによって実装されるオプションを要約し、これらの機能を最大限に活用することができますアプリケーションを設計するための考慮事項について説明。</target>
          </trans-unit>
          <trans-unit id="215" xml:space="preserve">
            <source>Azure の SQL データベースのパーティション分割戦略</source>
            <target state="new">Azure の SQL データベースのパーティション分割戦略</target>
          </trans-unit>
          <trans-unit id="216" xml:space="preserve">
            <source>Azure の SQL データベースは、リレーショナル データベース--サービスとして、クラウドで実行されます。それは、Microsoft SQL Server に基づいています。リレーショナル データベースのテーブルに情報を分割し、各テーブルは一連の行としてエンティティに関する情報を保持します。各行には、エンティティの個々 のフィールドのデータを格納する列が含まれています。、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の SQL データベース<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページを作成すると、SQL データベースを使用して詳細なドキュメントを提供します。</source>
            <target state="new">Azure の SQL データベースは、リレーショナル データベース--サービスとして、クラウドで実行されます。それは、Microsoft SQL Server に基づいています。リレーショナル データベースのテーブルに情報を分割し、各テーブルは一連の行としてエンティティに関する情報を保持します。各行には、エンティティの個々 のフィールドのデータを格納する列が含まれています。、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の SQL データベース<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページを作成すると、SQL データベースを使用して詳細なドキュメントを提供します。</target>
          </trans-unit>
          <trans-unit id="217" xml:space="preserve">
            <source>柔軟な拡張性と行方向の分割</source>
            <target state="new">柔軟な拡張性と行方向の分割</target>
          </trans-unit>
          <trans-unit id="218" xml:space="preserve">
            <source>1 つの SQL データベースを含めること、およびスループットが建築的要因とそれをサポートする同時接続の数が制限されてデータの量に制限があります。Azure の SQL データベースは、SQL データベースの水平方向のスケーリングをサポートする柔軟な拡張性を提供します。柔軟な拡張性を使用して、複数の SQL データベースにわたって広がる破片にデータをパーティション分割することができ、追加または処理する必要があるデータの量が増大し、縮小の破片を削除できます。弾性のスケールを使用しても、データベース間で負荷を分散することによって競合を減らすために役立ちます。</source>
            <target state="new">1 つの SQL データベースを含めること、およびスループットが建築的要因とそれをサポートする同時接続の数が制限されてデータの量に制限があります。Azure の SQL データベースは、SQL データベースの水平方向のスケーリングをサポートする柔軟な拡張性を提供します。柔軟な拡張性を使用して、複数の SQL データベースにわたって広がる破片にデータをパーティション分割することができ、追加または処理する必要があるデータの量が増大し、縮小の破片を削除できます。弾性のスケールを使用しても、データベース間で負荷を分散することによって競合を減らすために役立ちます。</target>
          </trans-unit>
          <trans-unit id="219" xml:space="preserve">
            <source>[AZURE。メモ] 柔軟な拡張性は現在 2015 年 1 月末現在プレビュー中です。それは引退、Azure SQL データベース フェデレーションの交換です。Azure SQL データベース フェデレーションの既存のインストールを使用して柔軟な拡張性に移行できます、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>連合移行ユーティリティ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.また、シナリオに自分自身を貸していない自然に柔軟な拡張性が提供する機能場合は、分割メカニズムを実装できます。</source>
            <target state="new">[AZURE。メモ] 柔軟な拡張性は現在 2015 年 1 月末現在プレビュー中です。それは引退、Azure SQL データベース フェデレーションの交換です。Azure SQL データベース フェデレーションの既存のインストールを使用して柔軟な拡張性に移行できます、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>連合移行ユーティリティ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.また、シナリオに自分自身を貸していない自然に柔軟な拡張性が提供する機能場合は、分割メカニズムを実装できます。</target>
          </trans-unit>
          <trans-unit id="220" xml:space="preserve">
            <source>各シャードは、SQL データベースとして実装されます。破片は 1 つ以上のデータセットを保持できます (と呼ばれる、 <bpt id="2">&lt;em&gt;</bpt>shardlet<ept id="2">&lt;/em&gt;</ept>) と各データベースが含まれている shardlets を記述するメタデータを保持します。Shardlet は、単一のデータ項目をすることができます。 または shardlet キーが同じ項目のグループをすることができます。たとえば、マルチ テナント アプリケーションの分割データの場合は、shardlet キーができるテナント ID と同じ shardlet の一環として開催される特定のテナントのすべてのデータ。他のテナントのデータは、異なる shardlets で開催されるでしょう。</source>
            <target state="new">各シャードは、SQL データベースとして実装されます。破片は 1 つ以上のデータセットを保持できます (と呼ばれる、 <bpt id="2">&lt;em&gt;</bpt>shardlet<ept id="2">&lt;/em&gt;</ept>) と各データベースが含まれている shardlets を記述するメタデータを保持します。Shardlet は、単一のデータ項目をすることができます。 または shardlet キーが同じ項目のグループをすることができます。たとえば、マルチ テナント アプリケーションの分割データの場合は、shardlet キーができるテナント ID と同じ shardlet の一環として開催される特定のテナントのすべてのデータ。他のテナントのデータは、異なる shardlets で開催されるでしょう。</target>
          </trans-unit>
          <trans-unit id="221" xml:space="preserve">
            <source>Shardlet キーにデータセットを関連付けるプログラマの責任です。別の SQL データベースは、各データベースの shardlets についての情報と共にシステム全体を構成するデータベース (破片) のリストを含むグローバル シャード マップ マネージャーとして機能します。データにアクセスするクライアント アプリケーションは、最初シャード-マップの (リストの破片および shardlets) ローカル キャッシュしたコピーを取得するグローバル シャード マップ マネージャー データベースに接続します。次に、アプリケーションは、適切な破片にデータ要求をルーティングするこの情報を使用します。この機能は、Azure SQL データベース弾性スケール クライアント ライブラリは、NuGet パッケージとして入手可能に含まれている Api のシリーズの下に隠れています。ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>SQL azure データベースの柔軟な拡張性の概要<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトでは、ウェブサイトは、弾性のスケールのより包括的な概要を提供します。</source>
            <target state="new">Shardlet キーにデータセットを関連付けるプログラマの責任です。別の SQL データベースは、各データベースの shardlets についての情報と共にシステム全体を構成するデータベース (破片) のリストを含むグローバル シャード マップ マネージャーとして機能します。データにアクセスするクライアント アプリケーションは、最初シャード-マップの (リストの破片および shardlets) ローカル キャッシュしたコピーを取得するグローバル シャード マップ マネージャー データベースに接続します。次に、アプリケーションは、適切な破片にデータ要求をルーティングするこの情報を使用します。この機能は、Azure SQL データベース弾性スケール クライアント ライブラリは、NuGet パッケージとして入手可能に含まれている Api のシリーズの下に隠れています。ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>SQL azure データベースの柔軟な拡張性の概要<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトでは、ウェブサイトは、弾性のスケールのより包括的な概要を提供します。</target>
          </trans-unit>
          <trans-unit id="222" xml:space="preserve">
            <source>[AZURE。メモ] 待ち時間を削減し、可用性を向上させる地球の破片地図マネージャー データベースをレプリケートすることができます。保険料のいずれかを使用して、データベースを実装する場合価格階層レプリケーションを構成できますアクティブなジオ-継続的に別の地域のデータベースにデータをコピーします。それぞれの地域のユーザーが基づいていると、このコピーの破片マップを得るために接続するアプリケーションを構成データベースのコピーを作成します。</source>
            <target state="new">[AZURE。メモ] 待ち時間を削減し、可用性を向上させる地球の破片地図マネージャー データベースをレプリケートすることができます。保険料のいずれかを使用して、データベースを実装する場合価格階層レプリケーションを構成できますアクティブなジオ-継続的に別の地域のデータベースにデータをコピーします。それぞれの地域のユーザーが基づいていると、このコピーの破片マップを得るために接続するアプリケーションを構成データベースのコピーを作成します。</target>
          </trans-unit>
          <trans-unit id="223" xml:space="preserve">
            <source>代替的アプローチは、地域間でシャード マップ マネージャー データベースをレプリケートする Azure SQL データ同期または Azure データ工場パイプラインを使用することです。レプリケーションのこのフォームは、定期的に実行、シャード マップ変更頻度の低い場合より適しています。さらに、シャード マップ マネージャー データベースは、プレミアムの価格階層を使用して作成する必要はありません。</source>
            <target state="new">代替的アプローチは、地域間でシャード マップ マネージャー データベースをレプリケートする Azure SQL データ同期または Azure データ工場パイプラインを使用することです。レプリケーションのこのフォームは、定期的に実行、シャード マップ変更頻度の低い場合より適しています。さらに、シャード マップ マネージャー データベースは、プレミアムの価格階層を使用して作成する必要はありません。</target>
          </trans-unit>
          <trans-unit id="224" xml:space="preserve">
            <source>柔軟な拡張性は、shardlets へのデータのマッピングおよび破片にそれらを格納するための 2 つの方式を提供します。</source>
            <target state="new">柔軟な拡張性は、shardlets へのデータのマッピングおよび破片にそれらを格納するための 2 つの方式を提供します。</target>
          </trans-unit>
          <trans-unit id="225" xml:space="preserve">
            <source>リスト シャード マップでは、1 つのキーと、shardlet 間の関連付けについて説明します。たとえば、マルチ テナント システムでテナントごとにデータ一意なキーに関連付けられているでき、独自の shardlet に格納されています。プライバシーと絶縁 (1 つのテナントの他に使用可能なデータ ストレージ リソースの浪費を防ぐ) を保証するため、独自のシャード内で各 shardlet を保持できます。</source>
            <target state="new">リスト シャード マップでは、1 つのキーと、shardlet 間の関連付けについて説明します。たとえば、マルチ テナント システムでテナントごとにデータ一意なキーに関連付けられているでき、独自の shardlet に格納されています。プライバシーと絶縁 (1 つのテナントの他に使用可能なデータ ストレージ リソースの浪費を防ぐ) を保証するため、独自のシャード内で各 shardlet を保持できます。</target>
          </trans-unit>
          <trans-unit id="226" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="227" xml:space="preserve">
            <source>_図 4。-別の破片にテナント データを格納するのにリスト シャード マップを使用_</source>
            <target state="new">_図 4。-別の破片にテナント データを格納するのにリスト シャード マップを使用_</target>
          </trans-unit>
          <trans-unit id="228" xml:space="preserve">
            <source>範囲の破片の地図では、一連の連続したキー値と、shardlet 間の関連付けについて説明します。専用の shardlets を実装する別の方法として、前述のマルチ テナント例で同じ shardlet 内テナント (それぞれ独自のキー) のセットのデータをグループ化できます。この方式は最初のものより安価 (テナントでデータ ストレージ ・ リソース共有) するが、上のデータのプライバシーと独立性を減少します。</source>
            <target state="new">範囲の破片の地図では、一連の連続したキー値と、shardlet 間の関連付けについて説明します。専用の shardlets を実装する別の方法として、前述のマルチ テナント例で同じ shardlet 内テナント (それぞれ独自のキー) のセットのデータをグループ化できます。この方式は最初のものより安価 (テナントでデータ ストレージ ・ リソース共有) するが、上のデータのプライバシーと独立性を減少します。</target>
          </trans-unit>
          <trans-unit id="229" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="230" xml:space="preserve">
            <source>_図 5。-破片のテナントの範囲のデータを格納するのに範囲シャード マップを使用_</source>
            <target state="new">_図 5。-破片のテナントの範囲のデータを格納するのに範囲シャード マップを使用_</target>
          </trans-unit>
          <trans-unit id="231" xml:space="preserve">
            <source>1 つのシャードがいくつか shardlets のデータを含めることができますに注意してください。たとえば、同じシャードで異なる非連続テナント データを格納するのにリストの shardlets を使用します。彼らは (地球の破片地図マネージャー データベースは、複数シャード マップを含めることができます) グローバル シャード マップ マネージャー データベースに異なるマップを通じて解決される予定が、範囲 shardlets と同じ破片のリスト shardlets を混在させることも。図 6 は、このアプローチを示しています。</source>
            <target state="new">1 つのシャードがいくつか shardlets のデータを含めることができますに注意してください。たとえば、同じシャードで異なる非連続テナント データを格納するのにリストの shardlets を使用します。彼らは (地球の破片地図マネージャー データベースは、複数シャード マップを含めることができます) グローバル シャード マップ マネージャー データベースに異なるマップを通じて解決される予定が、範囲 shardlets と同じ破片のリスト shardlets を混在させることも。図 6 は、このアプローチを示しています。</target>
          </trans-unit>
          <trans-unit id="232" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="233" xml:space="preserve">
            <source>_図 6。をマップ複数の破片を実装します。_</source>
            <target state="new">_図 6。をマップ複数の破片を実装します。_</target>
          </trans-unit>
          <trans-unit id="234" xml:space="preserve">
            <source>パーティション スキームを実装することは、あなたのシステムのパフォーマンスに大きな影響があるし、破片が追加または削除されるあるレートまたは破片間でパーティション データにも影響できます。弾性スケールを使用してデータを分割するときは、次の点を考慮してください。</source>
            <target state="new">パーティション スキームを実装することは、あなたのシステムのパフォーマンスに大きな影響があるし、破片が追加または削除されるあるレートまたは破片間でパーティション データにも影響できます。弾性スケールを使用してデータを分割するときは、次の点を考慮してください。</target>
          </trans-unit>
          <trans-unit id="235" xml:space="preserve">
            <source>Group data that is used together into the same shard and avoid operations that need to access data held in multiple shards.</source>
            <target state="new">Group data that is used together into the same shard and avoid operations that need to access data held in multiple shards.</target>
          </trans-unit>
          <trans-unit id="236" xml:space="preserve">
            <source>Bear in mind that with Elastic Scale a shard is a SQL database in its own right, and Azure SQL Database does not support cross-database joins; these operations have to be performed on the client-side.</source>
            <target state="new">Bear in mind that with Elastic Scale a shard is a SQL database in its own right, and Azure SQL Database does not support cross-database joins; these operations have to be performed on the client-side.</target>
          </trans-unit>
          <trans-unit id="237" xml:space="preserve">
            <source>Also remember that with Azure SQL Database referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another, so don't design a system that has dependencies between shards.</source>
            <target state="new">Also remember that with Azure SQL Database referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another, so don't design a system that has dependencies between shards.</target>
          </trans-unit>
          <trans-unit id="238" xml:space="preserve">
            <source>However, a SQL database can contain tables holding copies of reference data frequently used by queries and other operations, and these tables do not have to belong to any specific shardlet.</source>
            <target state="new">However, a SQL database can contain tables holding copies of reference data frequently used by queries and other operations, and these tables do not have to belong to any specific shardlet.</target>
          </trans-unit>
          <trans-unit id="239" xml:space="preserve">
            <source>Replicating this data across shards can help to remove the need to join data that spans databases.</source>
            <target state="new">Replicating this data across shards can help to remove the need to join data that spans databases.</target>
          </trans-unit>
          <trans-unit id="240" xml:space="preserve">
            <source>Ideally, such data should be static or slow-moving to minimize the replication effort and reduce the chances of it becoming stale.</source>
            <target state="new">Ideally, such data should be static or slow-moving to minimize the replication effort and reduce the chances of it becoming stale.</target>
          </trans-unit>
          <trans-unit id="241" xml:space="preserve">
            <source>[AZURE。メモ] Azure の SQL データベースは、クロス データベース結合をサポートしていませんが弾性のスケール API を使用して、透過的にシャード マップによって参照されるすべての shardlets で開催されたデータを反復処理できるクロス シャード クエリを実行できます。弾性スケール API 休憩の間破片は一連の個々 のクエリ (データベースごとに 1 つ) を照会し、結果を一緒にマージします。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>複数の破片を照会します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">[AZURE。メモ] Azure の SQL データベースは、クロス データベース結合をサポートしていませんが弾性のスケール API を使用して、透過的にシャード マップによって参照されるすべての shardlets で開催されたデータを反復処理できるクロス シャード クエリを実行できます。弾性スケール API 休憩の間破片は一連の個々 のクエリ (データベースごとに 1 つ) を照会し、結果を一緒にマージします。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>複数の破片を照会します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="242" xml:space="preserve">
            <source>同じシャード マップに属する shardlets に格納されたデータは、同じスキーマを持つ必要があります。たとえば、テナントのデータを含むいくつかの shardlets と製品情報を含む他の shardlets が指すリスト シャード マップを作成しないでください。この規則は、柔軟な拡張性、データ管理が適用されず、各 shardlet 別のスキーマを持っている場合、非常に複雑になるクエリを実行します。ちょうど引用した例では、2 つリスト シャード マップを作成する必要があります。他の 1 つの参照テナント データと製品情報をポイントします。同じシャードに異なる shardlets に属するデータを格納できることに注意してください。</source>
            <target state="new">同じシャード マップに属する shardlets に格納されたデータは、同じスキーマを持つ必要があります。たとえば、テナントのデータを含むいくつかの shardlets と製品情報を含む他の shardlets が指すリスト シャード マップを作成しないでください。この規則は、柔軟な拡張性、データ管理が適用されず、各 shardlet 別のスキーマを持っている場合、非常に複雑になるクエリを実行します。ちょうど引用した例では、2 つリスト シャード マップを作成する必要があります。他の 1 つの参照テナント データと製品情報をポイントします。同じシャードに異なる shardlets に属するデータを格納できることに注意してください。</target>
          </trans-unit>
          <trans-unit id="243" xml:space="preserve">
            <source>[AZURE。メモ] 弾性スケール API の間破片クエリ機能は、同じスキーマを含む破片マップの各 shardlet に依存します。</source>
            <target state="new">[AZURE。メモ] 弾性スケール API の間破片クエリ機能は、同じスキーマを含む破片マップの各 shardlet に依存します。</target>
          </trans-unit>
          <trans-unit id="244" xml:space="preserve">
            <source>トランザクション操作は、同じシャード内および破片の間でない情報のみサポートされます。トランザクションは、同じ破片の一部である限り、shardlets をまたがることができます。したがって、トランザクションを実行するビジネス ロジックが必要とする場合、その同じシャードに影響を受けるデータを格納、またはイベンチュアル ・ コンシステンシーを実装します。詳細については、データ整合性のガイダンスを参照してください。</source>
            <target state="new">トランザクション操作は、同じシャード内および破片の間でない情報のみサポートされます。トランザクションは、同じ破片の一部である限り、shardlets をまたがることができます。したがって、トランザクションを実行するビジネス ロジックが必要とする場合、その同じシャードに影響を受けるデータを格納、またはイベンチュアル ・ コンシステンシーを実装します。詳細については、データ整合性のガイダンスを参照してください。</target>
          </trans-unit>
          <trans-unit id="245" xml:space="preserve">
            <source>これらの破片のデータにアクセスするユーザーの近くに破片を置く (ジオ-破片を探します)。この戦略は、待機時間を短縮するのに役立ちます。</source>
            <target state="new">これらの破片のデータにアクセスするユーザーの近くに破片を置く (ジオ-破片を探します)。この戦略は、待機時間を短縮するのに役立ちます。</target>
          </trans-unit>
          <trans-unit id="246" xml:space="preserve">
            <source>高度の混合物を避けるアクティブ (ホット スポット) や比較的アクティブな破片。試してみて、破片に負荷が均等に分散します。これは shardlet キーをハッシュする必要があります。</source>
            <target state="new">高度の混合物を避けるアクティブ (ホット スポット) や比較的アクティブな破片。試してみて、破片に負荷が均等に分散します。これは shardlet キーをハッシュする必要があります。</target>
          </trans-unit>
          <trans-unit id="247" xml:space="preserve">
            <source>ジオロケートする破片の場合は、ハッシュのキーがそのデータにアクセスするユーザーの近くに保存されているシャードで開催された shardlets にマップすることを確認します。</source>
            <target state="new">ジオロケートする破片の場合は、ハッシュのキーがそのデータにアクセスするユーザーの近くに保存されているシャードで開催された shardlets にマップすることを確認します。</target>
          </trans-unit>
          <trans-unit id="248" xml:space="preserve">
            <source>現在、限定型は shardlet キーとしてサポートされて SQL データの設定 <bpt id="2">&lt;em&gt;</bpt>int、bigint、varbinary<ept id="2">&lt;/em&gt;</ept> と <bpt id="4">&lt;em&gt;</bpt>一意識別子<ept id="4">&lt;/em&gt;</ept>.SQL <bpt id="6">&lt;em&gt;</bpt>int<ept id="6">&lt;/em&gt;</ept> と _bigint 型_ 種類に対応、 <bpt id="8">&lt;em&gt;</bpt>int<ept id="8">&lt;/em&gt;</ept> と <bpt id="10">&lt;em&gt;</bpt>長い<ept id="10">&lt;/em&gt;</ept> c# のデータ型と同じ範囲を持っています。SQL <bpt id="12">&lt;em&gt;</bpt>varbinary<ept id="12">&lt;/em&gt;</ept> 型を使用して処理することができます、 <bpt id="14">&lt;em&gt;</bpt>バイト<ept id="14">&lt;/em&gt;</ept> c#、および SQL に配列 <bpt id="16">&lt;em&gt;</bpt>uniqueidentier<ept id="16">&lt;/em&gt;</ept> 種類に対応する、 <bpt id="18">&lt;em&gt;</bpt>Guid<ept id="18">&lt;/em&gt;</ept> .NET Framework のクラス。</source>
            <target state="new">現在、限定型は shardlet キーとしてサポートされて SQL データの設定 <bpt id="2">&lt;em&gt;</bpt>int、bigint、varbinary<ept id="2">&lt;/em&gt;</ept> と <bpt id="4">&lt;em&gt;</bpt>一意識別子<ept id="4">&lt;/em&gt;</ept>.SQL <bpt id="6">&lt;em&gt;</bpt>int<ept id="6">&lt;/em&gt;</ept> と _bigint 型_ 種類に対応、 <bpt id="8">&lt;em&gt;</bpt>int<ept id="8">&lt;/em&gt;</ept> と <bpt id="10">&lt;em&gt;</bpt>長い<ept id="10">&lt;/em&gt;</ept> c# のデータ型と同じ範囲を持っています。SQL <bpt id="12">&lt;em&gt;</bpt>varbinary<ept id="12">&lt;/em&gt;</ept> 型を使用して処理することができます、 <bpt id="14">&lt;em&gt;</bpt>バイト<ept id="14">&lt;/em&gt;</ept> c#、および SQL に配列 <bpt id="16">&lt;em&gt;</bpt>uniqueidentier<ept id="16">&lt;/em&gt;</ept> 種類に対応する、 <bpt id="18">&lt;em&gt;</bpt>Guid<ept id="18">&lt;/em&gt;</ept> .NET Framework のクラス。</target>
          </trans-unit>
          <trans-unit id="249" xml:space="preserve">
            <source>その名のとおり、柔軟な拡張性により、追加および縮小し、大きくなるとデータ量の破片を削除するシステムです。Azure SQL データベース弾性スケール クライアント ライブラリの Api 作成および破片を動的に削除するアプリケーションを有効にする (シャード マップ マネージャーを透過的に更新)、破片の取り外しは破壊的な操作もその破片ですべてのデータを削除する必要があります。アプリケーションは 2 つの独立した破片破片に分割または破片を一緒に結合する必要があります、柔軟な拡張性は別の分裂/統合サービスを提供します。このサービスは、クラウドでホストされるサービス (開発者がこのクラウドでホストされるサービスを作成する)、実行の世話と破片の間でデータを安全に移行します。詳細については、トピックを参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割およびマージによる柔軟な拡張性<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</source>
            <target state="new">その名のとおり、柔軟な拡張性により、追加および縮小し、大きくなるとデータ量の破片を削除するシステムです。Azure SQL データベース弾性スケール クライアント ライブラリの Api 作成および破片を動的に削除するアプリケーションを有効にする (シャード マップ マネージャーを透過的に更新)、破片の取り外しは破壊的な操作もその破片ですべてのデータを削除する必要があります。アプリケーションは 2 つの独立した破片破片に分割または破片を一緒に結合する必要があります、柔軟な拡張性は別の分裂/統合サービスを提供します。このサービスは、クラウドでホストされるサービス (開発者がこのクラウドでホストされるサービスを作成する)、実行の世話と破片の間でデータを安全に移行します。詳細については、トピックを参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割およびマージによる柔軟な拡張性<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</target>
          </trans-unit>
          <trans-unit id="250" xml:space="preserve">
            <source>Azure ストレージのパーティション分割戦略</source>
            <target state="new">Azure ストレージのパーティション分割戦略</target>
          </trans-unit>
          <trans-unit id="251" xml:space="preserve">
            <source>Azure ストレージは、データを管理するための 3 つの抽象化を提供します。</source>
            <target state="new">Azure ストレージは、データを管理するための 3 つの抽象化を提供します。</target>
          </trans-unit>
          <trans-unit id="252" xml:space="preserve">
            <source>テーブル ストレージは、拡張性の高い構造化ストレージの実装します。テーブルには、それぞれのプロパティと値のセットを含むことができるエンティティのコレクションが含まれています。</source>
            <target state="new">テーブル ストレージは、拡張性の高い構造化ストレージの実装します。テーブルには、それぞれのプロパティと値のセットを含むことができるエンティティのコレクションが含まれています。</target>
          </trans-unit>
          <trans-unit id="253" xml:space="preserve">
            <source>Blob ストレージは、大規模なオブジェクトやファイルの記憶域を提供します。</source>
            <target state="new">Blob ストレージは、大規模なオブジェクトやファイルの記憶域を提供します。</target>
          </trans-unit>
          <trans-unit id="254" xml:space="preserve">
            <source>ストレージ ・ キューは、アプリケーション間の信頼性の高い非同期メッセージングをサポートします。</source>
            <target state="new">ストレージ ・ キューは、アプリケーション間の信頼性の高い非同期メッセージングをサポートします。</target>
          </trans-unit>
          <trans-unit id="255" xml:space="preserve">
            <source>Blob ストレージとテーブル ストレージは、構造化および非構造化データをそれぞれ保持するために最適化された本質的にキー値ストアです。ストレージ ・ キューは、疎結合でスケーラブルなアプリケーションを構築するためのメカニズムを提供します。テーブル ストレージ、Blob ストレージとストレージのキューは、Azure ストレージ アカウントのコンテキスト内で作成されます。Azure ストレージ アカウントでは、3 つの形式の冗長性をサポートします。</source>
            <target state="new">Blob ストレージとテーブル ストレージは、構造化および非構造化データをそれぞれ保持するために最適化された本質的にキー値ストアです。ストレージ ・ キューは、疎結合でスケーラブルなアプリケーションを構築するためのメカニズムを提供します。テーブル ストレージ、Blob ストレージとストレージのキューは、Azure ストレージ アカウントのコンテキスト内で作成されます。Azure ストレージ アカウントでは、3 つの形式の冗長性をサポートします。</target>
          </trans-unit>
          <trans-unit id="256" xml:space="preserve">
            <source>ローカルの冗長ストレージでは、単一のデータ センター内のデータの 3 つのコピーを維持します。冗長のこのフォームは、ハードウェア障害に対する、データ センター全体を包含する災害に対してではなくを保護します。</source>
            <target state="new">ローカルの冗長ストレージでは、単一のデータ センター内のデータの 3 つのコピーを維持します。冗長のこのフォームは、ハードウェア障害に対する、データ センター全体を包含する災害に対してではなくを保護します。</target>
          </trans-unit>
          <trans-unit id="257" xml:space="preserve">
            <source>ゾーン冗長ストレージ データの 3 つのコピーを保持する広がる同じ領域内の別のデータ センターにまたがる (または 2 つの地理的に近い地域にわたって)。冗長性のこの形態は単一のデータ センター内で発生するが、防ぐことはできませんの災害から守ることができます大規模なネットワーク切断地域全体に影響を与える。ゾーン冗長ストレージ、ブロック blob に使用できるだけ現在のみに注意してください。</source>
            <target state="new">ゾーン冗長ストレージ データの 3 つのコピーを保持する広がる同じ領域内の別のデータ センターにまたがる (または 2 つの地理的に近い地域にわたって)。冗長性のこの形態は単一のデータ センター内で発生するが、防ぐことはできませんの災害から守ることができます大規模なネットワーク切断地域全体に影響を与える。ゾーン冗長ストレージ、ブロック blob に使用できるだけ現在のみに注意してください。</target>
          </trans-unit>
          <trans-unit id="258" xml:space="preserve">
            <source>地理冗長ストレージ、データの六つのコピーを維持します。1 つの地域 (ローカルの地域) の 3 つのコピーとリモート地域で別の 3 つのコピー。冗長のこのフォームは、障害保護の最高レベルを提供します。</source>
            <target state="new">地理冗長ストレージ、データの六つのコピーを維持します。1 つの地域 (ローカルの地域) の 3 つのコピーとリモート地域で別の 3 つのコピー。冗長のこのフォームは、障害保護の最高レベルを提供します。</target>
          </trans-unit>
          <trans-unit id="259" xml:space="preserve">
            <source>マイクロソフトは、Azure ストレージ アカウントに対するスケーラビリティ目標を公開されていますページを参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。現在、(blob ストレージと未処理のメッセージ記憶域のキューで開催されたテーブル ストレージに保持されたデータのサイズ) の総ストレージのアカウント容量 500 TB を超えることはできません。(1 KB エンティティ、blob またはメッセージのサイズと仮定) 要求の最大レートは、1 秒あたり 20 K です。あなたのシステムがこれらの制限を超えることがほとんどの場合、複数のストレージ アカウントごとに負荷を分割を検討してください。1 つの Azure サブスクリプションは、最大 100 のストレージ アカウントを作成できます。ただし、時間の経過とともに、これらの制限が変更されます。</source>
            <target state="new">マイクロソフトは、Azure ストレージ アカウントに対するスケーラビリティ目標を公開されていますページを参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。現在、(blob ストレージと未処理のメッセージ記憶域のキューで開催されたテーブル ストレージに保持されたデータのサイズ) の総ストレージのアカウント容量 500 TB を超えることはできません。(1 KB エンティティ、blob またはメッセージのサイズと仮定) 要求の最大レートは、1 秒あたり 20 K です。あなたのシステムがこれらの制限を超えることがほとんどの場合、複数のストレージ アカウントごとに負荷を分割を検討してください。1 つの Azure サブスクリプションは、最大 100 のストレージ アカウントを作成できます。ただし、時間の経過とともに、これらの制限が変更されます。</target>
          </trans-unit>
          <trans-unit id="260" xml:space="preserve">
            <source>Azure テーブル ストレージのパーティション分割</source>
            <target state="new">Azure テーブル ストレージのパーティション分割</target>
          </trans-unit>
          <trans-unit id="261" xml:space="preserve">
            <source>Azure テーブル ストレージが格納されているキー/値の分割のまわりで設計。すべてのエンティティは、パーティションに格納されている、パーティションは Azure テーブル ストレージによって内部で管理されます。テーブルに格納されている各エンティティは、2 つの部分のキー構成を提供する必要があります。</source>
            <target state="new">Azure テーブル ストレージが格納されているキー/値の分割のまわりで設計。すべてのエンティティは、パーティションに格納されている、パーティションは Azure テーブル ストレージによって内部で管理されます。テーブルに格納されている各エンティティは、2 つの部分のキー構成を提供する必要があります。</target>
          </trans-unit>
          <trans-unit id="262" xml:space="preserve">
            <source>パーティション キーです。これはどのパーティションに Azure テーブル ストレージがエンティティの配置を指定する文字列値です。同じパーティション キーを持つすべてのエンティティは、同じパーティションに格納されます。</source>
            <target state="new">パーティション キーです。これはどのパーティションに Azure テーブル ストレージがエンティティの配置を指定する文字列値です。同じパーティション キーを持つすべてのエンティティは、同じパーティションに格納されます。</target>
          </trans-unit>
          <trans-unit id="263" xml:space="preserve">
            <source>行キー。これは、パーティション内のエンティティを識別する別の文字列値です。パーティション内のすべてのエンティティは、このキーによって昇順に字句的に並べ替えられます。パーティション キー/行キーの組み合わせは、各エンティティに対して一意である必要があり、長さは 1 KB を超えることはできません。</source>
            <target state="new">行キー。これは、パーティション内のエンティティを識別する別の文字列値です。パーティション内のすべてのエンティティは、このキーによって昇順に字句的に並べ替えられます。パーティション キー/行キーの組み合わせは、各エンティティに対して一意である必要があり、長さは 1 KB を超えることはできません。</target>
          </trans-unit>
          <trans-unit id="264" xml:space="preserve">
            <source>エンティティのデータの残りの部分は、アプリケーション定義のフィールドで構成されます。特定のスキーマが適用されない、各行が異なるアプリケーション定義フィールドのセットを含めることができます。唯一の制限は、エンティティ (パーティションと行のキーを含む) の最大サイズは 1 MB で、現在です。これらの数字は未来 (チェック ページで変更可能性がありますが、テーブルの最大サイズは 200 TB です。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> これらの制限については、最新のマイクロソフトのウェブサイト。この容量を超えるエンティティを格納しようとする場合、複数のテーブルに分割し、検討して列分割を使用し、同時にアクセスされる可能性が最も高いグループにフィールドを分割します。</source>
            <target state="new">エンティティのデータの残りの部分は、アプリケーション定義のフィールドで構成されます。特定のスキーマが適用されない、各行が異なるアプリケーション定義フィールドのセットを含めることができます。唯一の制限は、エンティティ (パーティションと行のキーを含む) の最大サイズは 1 MB で、現在です。これらの数字は未来 (チェック ページで変更可能性がありますが、テーブルの最大サイズは 200 TB です。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> これらの制限については、最新のマイクロソフトのウェブサイト。この容量を超えるエンティティを格納しようとする場合、複数のテーブルに分割し、検討して列分割を使用し、同時にアクセスされる可能性が最も高いグループにフィールドを分割します。</target>
          </trans-unit>
          <trans-unit id="265" xml:space="preserve">
            <source>図 7 は、架空の e コマース アプリケーションの例ストレージ アカウント (Contoso データ) の論理構造を示しています。ストレージ アカウントに 3 つのテーブル (顧客情報、製品情報、および注文情報) が含まれているし、各テーブルには複数のパーティション。顧客情報テーブルのデータ、顧客のある都市に従ってパーティション分割および行キーには、顧客 ID が含まれています。製品情報テーブル製品を製品カテゴリ別分割および行キーには製品番号が含まれています。注文情報テーブルの注文に置かれたおよび行キーは、注文が受信された時間を指定した日付でパーティション分割されます。すべてのデータは各パーティションの行キーが順に注意してください。</source>
            <target state="new">図 7 は、架空の e コマース アプリケーションの例ストレージ アカウント (Contoso データ) の論理構造を示しています。ストレージ アカウントに 3 つのテーブル (顧客情報、製品情報、および注文情報) が含まれているし、各テーブルには複数のパーティション。顧客情報テーブルのデータ、顧客のある都市に従ってパーティション分割および行キーには、顧客 ID が含まれています。製品情報テーブル製品を製品カテゴリ別分割および行キーには製品番号が含まれています。注文情報テーブルの注文に置かれたおよび行キーは、注文が受信された時間を指定した日付でパーティション分割されます。すべてのデータは各パーティションの行キーが順に注意してください。</target>
          </trans-unit>
          <trans-unit id="266" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="267" xml:space="preserve">
            <source>_図 7。● テーブルとパーティション例ストレージ アカウントの_</source>
            <target state="new">_図 7。● テーブルとパーティション例ストレージ アカウントの_</target>
          </trans-unit>
          <trans-unit id="268" xml:space="preserve">
            <source>[AZURE。メモ] Azure テーブル ストレージは、各エンティティにタイムスタンプ フィールドを追加します。タイムスタンプ フィールドはテーブル ストレージによって維持は、エンティティを変更し、パーティションに書き戻すたびに更新されます。テーブル ストレージ サービスでは、このフィールドを使用して、オプティミスティック同時実行制御 (アプリケーションに書き込むたびにエンティティ戻ってテーブル ストレージは、テーブル ストレージ サービス テーブル ストレージに保持された値と書かれているエンティティのタイムスタンプの値を比較し、それが取得されてから、別のアプリケーション必要がありますエンティティに変更が彼らが異なる場合、書き込み操作が失敗した場合) を実装します。独自のコードでこのフィールドを変更しないでください、新しいエンティティを作成するときこのフィールドの値を指定する必要がありますどちらも。</source>
            <target state="new">[AZURE。メモ] Azure テーブル ストレージは、各エンティティにタイムスタンプ フィールドを追加します。タイムスタンプ フィールドはテーブル ストレージによって維持は、エンティティを変更し、パーティションに書き戻すたびに更新されます。テーブル ストレージ サービスでは、このフィールドを使用して、オプティミスティック同時実行制御 (アプリケーションに書き込むたびにエンティティ戻ってテーブル ストレージは、テーブル ストレージ サービス テーブル ストレージに保持された値と書かれているエンティティのタイムスタンプの値を比較し、それが取得されてから、別のアプリケーション必要がありますエンティティに変更が彼らが異なる場合、書き込み操作が失敗した場合) を実装します。独自のコードでこのフィールドを変更しないでください、新しいエンティティを作成するときこのフィールドの値を指定する必要がありますどちらも。</target>
          </trans-unit>
          <trans-unit id="269" xml:space="preserve">
            <source>Azure テーブル ストレージでは、パーティション キーを使用してデータを格納する方法を決定します。未使用のパーティション キーを持つテーブルにエンティティを追加すると、Azure テーブル ストレージにこのエンティティ用の新しいパーティションが作成されます。同じパーティション キーを持つ他のエンティティは、同じパーティションに格納されます。このメカニズムは、自動スケール アウト戦略を効果的に実装します。各パーティションは (1 つのパーティションからデータを取得するクエリがすばやく実行されることを確認のため) Azure データ センターは、単一のサーバーに保存されますが、異なるパーティション複数サーバーに分散することができます。さらに、1 台のサーバーは、これらのパーティションのサイズに制限が場合、複数のパーティションをホストできます。</source>
            <target state="new">Azure テーブル ストレージでは、パーティション キーを使用してデータを格納する方法を決定します。未使用のパーティション キーを持つテーブルにエンティティを追加すると、Azure テーブル ストレージにこのエンティティ用の新しいパーティションが作成されます。同じパーティション キーを持つ他のエンティティは、同じパーティションに格納されます。このメカニズムは、自動スケール アウト戦略を効果的に実装します。各パーティションは (1 つのパーティションからデータを取得するクエリがすばやく実行されることを確認のため) Azure データ センターは、単一のサーバーに保存されますが、異なるパーティション複数サーバーに分散することができます。さらに、1 台のサーバーは、これらのパーティションのサイズに制限が場合、複数のパーティションをホストできます。</target>
          </trans-unit>
          <trans-unit id="270" xml:space="preserve">
            <source>Azure テーブル ストレージのエンティティを設計するときは、次の点を考慮してください。</source>
            <target state="new">Azure テーブル ストレージのエンティティを設計するときは、次の点を考慮してください。</target>
          </trans-unit>
          <trans-unit id="271" xml:space="preserve">
            <source>パーティション キーおよび行キーの値の選択は、データにアクセスするに方法で駆動する必要があります。クエリの大半をサポートするパーティション キー/行のキーの組み合わせを選択する必要があります。最も効率的なクエリ パーティション キーおよび行キーを指定することによってデータが取得されます。パーティション キーおよび行キーの範囲を指定するクエリは、1 つのパーティションをスキャンすることによって満たすことができます。行キーの順序でデータを保持するため比較的高速です。パーティション キーは、少なくとも指定しないクエリは、データのすべてのパーティションをスキャンする Azure テーブル ストレージを必要があります。</source>
            <target state="new">パーティション キーおよび行キーの値の選択は、データにアクセスするに方法で駆動する必要があります。クエリの大半をサポートするパーティション キー/行のキーの組み合わせを選択する必要があります。最も効率的なクエリ パーティション キーおよび行キーを指定することによってデータが取得されます。パーティション キーおよび行キーの範囲を指定するクエリは、1 つのパーティションをスキャンすることによって満たすことができます。行キーの順序でデータを保持するため比較的高速です。パーティション キーは、少なくとも指定しないクエリは、データのすべてのパーティションをスキャンする Azure テーブル ストレージを必要があります。</target>
          </trans-unit>
          <trans-unit id="272" xml:space="preserve">
            <source>[AZURE。ヒント] エンティティに 1 つの自然なキーがある場合は、パーティション キーとしてそれを使用し、行キーとして空の文字列を指定します。エンティティに 2 つのプロパティで構成される複合キーがある場合は、パーティション キーおよび行キーとしてその他として最も遅い変更するプロパティを選択します。エンティティに 2 つ以上のキー プロパティがある場合は、パーティションと行のキーを提供するプロパティの連結を使用します。</source>
            <target state="new">[AZURE。ヒント] エンティティに 1 つの自然なキーがある場合は、パーティション キーとしてそれを使用し、行キーとして空の文字列を指定します。エンティティに 2 つのプロパティで構成される複合キーがある場合は、パーティション キーおよび行キーとしてその他として最も遅い変更するプロパティを選択します。エンティティに 2 つ以上のキー プロパティがある場合は、パーティションと行のキーを提供するプロパティの連結を使用します。</target>
          </trans-unit>
          <trans-unit id="273" xml:space="preserve">
            <source>パーティションと行のキー以外のフィールドを使用してデータを検索するクエリを定期的に実行する場合は、実装を検討、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>インデックス テーブル パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</source>
            <target state="new">パーティションと行のキー以外のフィールドを使用してデータを検索するクエリを定期的に実行する場合は、実装を検討、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>インデックス テーブル パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="274" xml:space="preserve">
            <source>If you generate partition keys using a monotonic increasing or decreasing sequence (such as "0001", "0002", "0003", …)</source>
            <target state="new">If you generate partition keys using a monotonic increasing or decreasing sequence (such as "0001", "0002", "0003", …)</target>
          </trans-unit>
          <trans-unit id="275" xml:space="preserve">
            <source>and each partition only contains a limited amount of data, then Azure table storage may physically group these partitions together on the same server.</source>
            <target state="new">and each partition only contains a limited amount of data, then Azure table storage may physically group these partitions together on the same server.</target>
          </trans-unit>
          <trans-unit id="276" xml:space="preserve">
            <source>This mechanism assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</source>
            <target state="new">This mechanism assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</target>
          </trans-unit>
          <trans-unit id="277" xml:space="preserve">
            <source>However, this approach can lead to hotspots focused on a single server as all inserts of new entities will likely be concentrated at one or other end of the contiguous ranges.</source>
            <target state="new">However, this approach can lead to hotspots focused on a single server as all inserts of new entities will likely be concentrated at one or other end of the contiguous ranges.</target>
          </trans-unit>
          <trans-unit id="278" xml:space="preserve">
            <source>It can also reduce scalability.</source>
            <target state="new">It can also reduce scalability.</target>
          </trans-unit>
          <trans-unit id="279" xml:space="preserve">
            <source>To spread the load more evenly across servers, consider hashing the partition key to make the sequence more random.</source>
            <target state="new">To spread the load more evenly across servers, consider hashing the partition key to make the sequence more random.</target>
          </trans-unit>
          <trans-unit id="280" xml:space="preserve">
            <source>Azure テーブル ストレージでは、同じパーティションに属するエンティティに対してトランザクション操作をサポートしています。これは、アプリケーションが (ない以上 100 エンティティおよびサイズの 4 MB を超えない要求のペイロードを含むトランザクション) の対象原子単位として複数の挿入、更新、削除、置換、またはマージ操作を実行できることを意味します。複数のパーティションの操作は、トランザクションではないとデータ一貫性指導によって説明するように、最終的な一貫性を実装する必要があります。テーブル ストレージのトランザクションの詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>エンティティ グループ トランザクションの実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">Azure テーブル ストレージでは、同じパーティションに属するエンティティに対してトランザクション操作をサポートしています。これは、アプリケーションが (ない以上 100 エンティティおよびサイズの 4 MB を超えない要求のペイロードを含むトランザクション) の対象原子単位として複数の挿入、更新、削除、置換、またはマージ操作を実行できることを意味します。複数のパーティションの操作は、トランザクションではないとデータ一貫性指導によって説明するように、最終的な一貫性を実装する必要があります。テーブル ストレージのトランザクションの詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>エンティティ グループ トランザクションの実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="281" xml:space="preserve">
            <source>パーティション キーの粒度に細心の注意を与えます。</source>
            <target state="new">パーティション キーの粒度に細心の注意を与えます。</target>
          </trans-unit>
          <trans-unit id="282" xml:space="preserve">
            <source>すべてのエンティティに同じパーティション キーを使用してスケール アウトと、代わりに 1 つのサーバーに負荷を中心からそれを防止する 1 つのサーバーに保持され 1 つの大きなパーティションを作成するテーブル ストレージ サービスになります。その結果、このアプローチは管理エンティティの数が少ないシステムに適していますのみ。ただし、このアプローチは、すべてのエンティティはエンティティ グループ トランザクションに参加できること。</source>
            <target state="new">すべてのエンティティに同じパーティション キーを使用してスケール アウトと、代わりに 1 つのサーバーに負荷を中心からそれを防止する 1 つのサーバーに保持され 1 つの大きなパーティションを作成するテーブル ストレージ サービスになります。その結果、このアプローチは管理エンティティの数が少ないシステムに適していますのみ。ただし、このアプローチは、すべてのエンティティはエンティティ グループ トランザクションに参加できること。</target>
          </trans-unit>
          <trans-unit id="283" xml:space="preserve">
            <source>すべてのエンティティの一意のパーティション キーを使用して多数の小さなパーティション (によってエンティティのサイズ) を生じる可能性が、各エンティティの別のパーティションを作成するテーブル ストレージ サービスになります。このアプローチは、1 つのパーティション キーを使用するよりも拡張性が、エンティティ グループ トランザクションは利用できず、1 つ以上のエンティティをフェッチするクエリは、1 つ以上のサーバーからの読み取りを伴うことがあります。ただし、アプリケーションを実行するパーティション キーを生成する単調シーケンスを使用して範囲クエリがこれらのクエリを最適化するために役立つかもしれない。</source>
            <target state="new">すべてのエンティティの一意のパーティション キーを使用して多数の小さなパーティション (によってエンティティのサイズ) を生じる可能性が、各エンティティの別のパーティションを作成するテーブル ストレージ サービスになります。このアプローチは、1 つのパーティション キーを使用するよりも拡張性が、エンティティ グループ トランザクションは利用できず、1 つ以上のエンティティをフェッチするクエリは、1 つ以上のサーバーからの読み取りを伴うことがあります。ただし、アプリケーションを実行するパーティション キーを生成する単調シーケンスを使用して範囲クエリがこれらのクエリを最適化するために役立つかもしれない。</target>
          </trans-unit>
          <trans-unit id="284" xml:space="preserve">
            <source>エンティティのサブセットの間でパーティションのキーを共有することができますグループ同じパーティション内のエンティティを関連します。エンティティ グループ トランザクションを使用して関連エンティティに関連する操作を行うことが、単一のサーバーへのアクセスによって満たされる関連エンティティのセットを取得するクエリ。</source>
            <target state="new">エンティティのサブセットの間でパーティションのキーを共有することができますグループ同じパーティション内のエンティティを関連します。エンティティ グループ トランザクションを使用して関連エンティティに関連する操作を行うことが、単一のサーバーへのアクセスによって満たされる関連エンティティのセットを取得するクエリ。</target>
          </trans-unit>
          <trans-unit id="285" xml:space="preserve">
            <source>Azure テーブル ストレージ内のデータのパーティション分割の詳細については、記事を参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure テーブル ストレージの拡張性の高いパーティション分割戦略の設計<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</source>
            <target state="new">Azure テーブル ストレージ内のデータのパーティション分割の詳細については、記事を参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure テーブル ストレージの拡張性の高いパーティション分割戦略の設計<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</target>
          </trans-unit>
          <trans-unit id="286" xml:space="preserve">
            <source>Azure のブロブ ストレージのパーティション分割</source>
            <target state="new">Azure のブロブ ストレージのパーティション分割</target>
          </trans-unit>
          <trans-unit id="287" xml:space="preserve">
            <source>Azure のブロブ ストレージは、ページ blob のバイナリ ラージ オブジェクト、ブロック blob のサイズを現在 200 GB または 1 TB を保持することができます (最新の情報を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ)。アップロードまたは大量のデータを迅速にダウンロードするストリーミングする必要があるなど、ブロック blob を使用します。ページ blob をランダムではなく、データの部分へのシリアル アクセスを必要とするアプリケーションに使用できます。</source>
            <target state="new">Azure のブロブ ストレージは、ページ blob のバイナリ ラージ オブジェクト、ブロック blob のサイズを現在 200 GB または 1 TB を保持することができます (最新の情報を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ)。アップロードまたは大量のデータを迅速にダウンロードするストリーミングする必要があるなど、ブロック blob を使用します。ページ blob をランダムではなく、データの部分へのシリアル アクセスを必要とするアプリケーションに使用できます。</target>
          </trans-unit>
          <trans-unit id="288" xml:space="preserve">
            <source>各 blob (ブロックまたはページ) は、Azure ストレージ アカウント内のコンテナーに保持されます。コンテナーを使用すると、この分類は論理ではなく、物理的な一緒に、同じセキュリティ要件を持つ関連 blob をグループ化することができます。コンテナーの内部は、各 blob は、ユニークな名前を持ちます。</source>
            <target state="new">各 blob (ブロックまたはページ) は、Azure ストレージ アカウント内のコンテナーに保持されます。コンテナーを使用すると、この分類は論理ではなく、物理的な一緒に、同じセキュリティ要件を持つ関連 blob をグループ化することができます。コンテナーの内部は、各 blob は、ユニークな名前を持ちます。</target>
          </trans-unit>
          <trans-unit id="289" xml:space="preserve">
            <source>Blob ストレージは、blob 名に基づいて自動的に分割されます。各 blob は、独自のパーティションに保持されて、同じコンテナー内の blob がパーティションを共有しません。このアーキテクチャにより、異なるサーバーに分散可能性があります同じコンテナーに異なる blob として透過的にサーバー間で負荷を分散する Azure のブロブ ストレージです。</source>
            <target state="new">Blob ストレージは、blob 名に基づいて自動的に分割されます。各 blob は、独自のパーティションに保持されて、同じコンテナー内の blob がパーティションを共有しません。このアーキテクチャにより、異なるサーバーに分散可能性があります同じコンテナーに異なる blob として透過的にサーバー間で負荷を分散する Azure のブロブ ストレージです。</target>
          </trans-unit>
          <trans-unit id="290" xml:space="preserve">
            <source>1 つのブロック (ブロック blob) またはページ (ページ blob) の書き込みの操作、原子、ブロック、ページ、または blob にまたがる操作はありません。ブロック、ページ、および blob の間で書き込み操作を行う際に、一貫性を確保する必要がある場合、は、blob のリースを使用して、書き込みロックを取得する必要があります。</source>
            <target state="new">1 つのブロック (ブロック blob) またはページ (ページ blob) の書き込みの操作、原子、ブロック、ページ、または blob にまたがる操作はありません。ブロック、ページ、および blob の間で書き込み操作を行う際に、一貫性を確保する必要がある場合、は、blob のリースを使用して、書き込みロックを取得する必要があります。</target>
          </trans-unit>
          <trans-unit id="291" xml:space="preserve">
            <source>Azure のブロブ ストレージは、各 blob の 1 秒あたりの要求数 2 番目または 500 あたり最大 60 MB の転送速度をサポートします。これらの制限を超えると予想される場合、blob データが比較的静的な Azure コンテンツ配信ネットワーク (CDN) を使用して、blob のレプリケーションを考慮しなさい。詳細については、ページを参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CDN を使用してください。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。追加のガイダンスおよび考慮事項については、「コンテンツ配信ネットワーク (CDN)」を参照してください。</source>
            <target state="new">Azure のブロブ ストレージは、各 blob の 1 秒あたりの要求数 2 番目または 500 あたり最大 60 MB の転送速度をサポートします。これらの制限を超えると予想される場合、blob データが比較的静的な Azure コンテンツ配信ネットワーク (CDN) を使用して、blob のレプリケーションを考慮しなさい。詳細については、ページを参照してください。 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CDN を使用してください。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。追加のガイダンスおよび考慮事項については、「コンテンツ配信ネットワーク (CDN)」を参照してください。</target>
          </trans-unit>
          <trans-unit id="292" xml:space="preserve">
            <source>Azure ストレージ キューを分割</source>
            <target state="new">Azure ストレージ キューを分割</target>
          </trans-unit>
          <trans-unit id="293" xml:space="preserve">
            <source>Azure ストレージ キューは、プロセス間の非同期メッセージングを実装することができます。Azure ストレージ アカウントの任意の数のキューを含めることができます、各キューは、任意数のメッセージを含めることができます。唯一の制限は、ストレージ アカウントで利用できるスペースです。個々 のメッセージの最大サイズは 64 KB です。これよりも大きなメッセージが必要な場合は、代わりに Azure サービス バス キューを使用することを考慮しなさい。</source>
            <target state="new">Azure ストレージ キューは、プロセス間の非同期メッセージングを実装することができます。Azure ストレージ アカウントの任意の数のキューを含めることができます、各キューは、任意数のメッセージを含めることができます。唯一の制限は、ストレージ アカウントで利用できるスペースです。個々 のメッセージの最大サイズは 64 KB です。これよりも大きなメッセージが必要な場合は、代わりに Azure サービス バス キューを使用することを考慮しなさい。</target>
          </trans-unit>
          <trans-unit id="294" xml:space="preserve">
            <source>Each storage queue has a unique name within the storage account in which it is contained.</source>
            <target state="new">Each storage queue has a unique name within the storage account in which it is contained.</target>
          </trans-unit>
          <trans-unit id="295" xml:space="preserve">
            <source>Azure partitions queues based on the name, and all messages for the same queue are stored in the same partition, controlled by a single server.</source>
            <target state="new">Azure partitions queues based on the name, and all messages for the same queue are stored in the same partition, controlled by a single server.</target>
          </trans-unit>
          <trans-unit id="296" xml:space="preserve">
            <source>Different queues can be managed by different servers to help balance the load.</source>
            <target state="new">Different queues can be managed by different servers to help balance the load.</target>
          </trans-unit>
          <trans-unit id="297" xml:space="preserve">
            <source>The allocation of queues to servers is transparent to applications and users.</source>
            <target state="new">The allocation of queues to servers is transparent to applications and users.</target>
          </trans-unit>
          <trans-unit id="298" xml:space="preserve">
            <source>In a large scale application, don't use the same storage queue for all instances of the application as this approach may cause the server hosting the queue to become a hotspot; use different queues for different functional areas of the application.</source>
            <target state="new">In a large scale application, don't use the same storage queue for all instances of the application as this approach may cause the server hosting the queue to become a hotspot; use different queues for different functional areas of the application.</target>
          </trans-unit>
          <trans-unit id="299" xml:space="preserve">
            <source>Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</source>
            <target state="new">Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</target>
          </trans-unit>
          <trans-unit id="300" xml:space="preserve">
            <source>Azure ストレージ キューは最大 2000年 1 秒あたりのメッセージ処理できます。 これよりも大きな割合でメッセージを処理する必要があります複数のキューを作成することを検討してください。たとえば、グローバル アプリケーションの各領域で実行されているアプリケーションのインスタンスを処理する別のストレージ アカウント内の別のストレージ ・ キューを作成します。</source>
            <target state="new">Azure ストレージ キューは最大 2000年 1 秒あたりのメッセージ処理できます。 これよりも大きな割合でメッセージを処理する必要があります複数のキューを作成することを検討してください。たとえば、グローバル アプリケーションの各領域で実行されているアプリケーションのインスタンスを処理する別のストレージ アカウント内の別のストレージ ・ キューを作成します。</target>
          </trans-unit>
          <trans-unit id="301" xml:space="preserve">
            <source>Azure のサービス バスのパーティション分割戦略</source>
            <target state="new">Azure のサービス バスのパーティション分割戦略</target>
          </trans-unit>
          <trans-unit id="302" xml:space="preserve">
            <source>Azure のサービス バスは、サービス バス キューまたはトピックに送信されたメッセージを処理するのにメッセージ ブローカーを使用します。既定では、キューまたはトピックに送信されるすべてのメッセージは、同じメッセージ ブローカー プロセスによって処理されます。このアーキテクチャでは、メッセージ キューの全体的なスループットに制限を配置できます。ただし、分割できます、キューまたはトピックを設定して作成する場合、 <bpt id="2">&lt;em&gt;</bpt>EnablePartitioning<ept id="2">&lt;/em&gt;</ept> キューまたはトピックの説明のプロパティ _場合は true。_.</source>
            <target state="new">Azure のサービス バスは、サービス バス キューまたはトピックに送信されたメッセージを処理するのにメッセージ ブローカーを使用します。既定では、キューまたはトピックに送信されるすべてのメッセージは、同じメッセージ ブローカー プロセスによって処理されます。このアーキテクチャでは、メッセージ キューの全体的なスループットに制限を配置できます。ただし、分割できます、キューまたはトピックを設定して作成する場合、 <bpt id="2">&lt;em&gt;</bpt>EnablePartitioning<ept id="2">&lt;/em&gt;</ept> キューまたはトピックの説明のプロパティ _場合は true。_.</target>
          </trans-unit>
          <trans-unit id="303" xml:space="preserve">
            <source>A partitioned queue or topic is divided up into multiple fragments, each of which is backed by a separate message store and message broker.</source>
            <target state="new">A partitioned queue or topic is divided up into multiple fragments, each of which is backed by a separate message store and message broker.</target>
          </trans-unit>
          <trans-unit id="304" xml:space="preserve">
            <source>Service Bus takes responsibility for creating and managing these fragments.</source>
            <target state="new">Service Bus takes responsibility for creating and managing these fragments.</target>
          </trans-unit>
          <trans-unit id="305" xml:space="preserve">
            <source>When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</source>
            <target state="new">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</target>
          </trans-unit>
          <trans-unit id="306" xml:space="preserve">
            <source>When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</source>
            <target state="new">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</target>
          </trans-unit>
          <trans-unit id="307" xml:space="preserve">
            <source>This structure helps to distribute the load across message brokers and message stores, increasing scalability and improving availability; if the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</source>
            <target state="new">This structure helps to distribute the load across message brokers and message stores, increasing scalability and improving availability; if the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</target>
          </trans-unit>
          <trans-unit id="308" xml:space="preserve">
            <source>サービス バスは、ようにフラグメントにメッセージを割り当てます。</source>
            <target state="new">サービス バスは、ようにフラグメントにメッセージを割り当てます。</target>
          </trans-unit>
          <trans-unit id="309" xml:space="preserve">
            <source>同じ値を持つすべてのメッセージ メッセージがセッションに所属している場合、 _ SessionId_  プロパティは、同じフラグメントに送信されます。</source>
            <target state="new">同じ値を持つすべてのメッセージ メッセージがセッションに所属している場合、 _ SessionId_  プロパティは、同じフラグメントに送信されます。</target>
          </trans-unit>
          <trans-unit id="310" xml:space="preserve">
            <source>メッセージがセッションに属していないが、送信者が指定の値、 <bpt id="2">&lt;em&gt;</bpt>PartitionKey<ept id="2">&lt;/em&gt;</ept> プロパティ、し、すべてのメッセージを同じ <bpt id="4">&lt;em&gt;</bpt>PartitionKey<ept id="4">&lt;/em&gt;</ept> 値は、同じフラグメントに送られます。</source>
            <target state="new">メッセージがセッションに属していないが、送信者が指定の値、 <bpt id="2">&lt;em&gt;</bpt>PartitionKey<ept id="2">&lt;/em&gt;</ept> プロパティ、し、すべてのメッセージを同じ <bpt id="4">&lt;em&gt;</bpt>PartitionKey<ept id="4">&lt;/em&gt;</ept> 値は、同じフラグメントに送られます。</target>
          </trans-unit>
          <trans-unit id="311" xml:space="preserve">
            <source>[AZURE。メモ] 場合は、 <bpt id="2">&lt;em&gt;</bpt>SessionId<ept id="2">&lt;/em&gt;</ept> と <bpt id="4">&lt;em&gt;</bpt>PartitionKey<ept id="4">&lt;/em&gt;</ept> プロパティが両方指定されて、し、同じ値のそれ以外の場合、メッセージが拒否されるように設定する必要があります。</source>
            <target state="new">[AZURE。メモ] 場合は、 <bpt id="2">&lt;em&gt;</bpt>SessionId<ept id="2">&lt;/em&gt;</ept> と <bpt id="4">&lt;em&gt;</bpt>PartitionKey<ept id="4">&lt;/em&gt;</ept> プロパティが両方指定されて、し、同じ値のそれ以外の場合、メッセージが拒否されるように設定する必要があります。</target>
          </trans-unit>
          <trans-unit id="312" xml:space="preserve">
            <source>場合は、 <bpt id="2">&lt;em&gt;</bpt>SessionId<ept id="2">&lt;/em&gt;</ept> と <bpt id="4">&lt;em&gt;</bpt>PartitionKey<ept id="4">&lt;/em&gt;</ept> メッセージのプロパティが指定されていないが、重複データ検出が有効になっている、 <bpt id="6">&lt;em&gt;</bpt>MessageId<ept id="6">&lt;/em&gt;</ept> プロパティが使用されます。すべてのメッセージを同じ <bpt id="8">&lt;em&gt;</bpt>MessageId<ept id="8">&lt;/em&gt;</ept> 同じフラグメントに指示されます。</source>
            <target state="new">場合は、 <bpt id="2">&lt;em&gt;</bpt>SessionId<ept id="2">&lt;/em&gt;</ept> と <bpt id="4">&lt;em&gt;</bpt>PartitionKey<ept id="4">&lt;/em&gt;</ept> メッセージのプロパティが指定されていないが、重複データ検出が有効になっている、 <bpt id="6">&lt;em&gt;</bpt>MessageId<ept id="6">&lt;/em&gt;</ept> プロパティが使用されます。すべてのメッセージを同じ <bpt id="8">&lt;em&gt;</bpt>MessageId<ept id="8">&lt;/em&gt;</ept> 同じフラグメントに指示されます。</target>
          </trans-unit>
          <trans-unit id="313" xml:space="preserve">
            <source>メッセージが含まれない場合、 <bpt id="2">&lt;em&gt;</bpt>SessionId、PartitionKey、<ept id="2">&lt;/em&gt;</ept> または <bpt id="4">&lt;em&gt;</bpt>MessageId<ept id="4">&lt;/em&gt;</ept> プロパティ、し、サービス バスは、ラウンド ロビン方式でフラグメントにメッセージを割り当てます。フラグメントが利用できない場合、サービス バスは次移動します。この方法で一時的な障害メッセージング インフラストラクチャでは、メッセージ送信操作が失敗するを発生しません。</source>
            <target state="new">メッセージが含まれない場合、 <bpt id="2">&lt;em&gt;</bpt>SessionId、PartitionKey、<ept id="2">&lt;/em&gt;</ept> または <bpt id="4">&lt;em&gt;</bpt>MessageId<ept id="4">&lt;/em&gt;</ept> プロパティ、し、サービス バスは、ラウンド ロビン方式でフラグメントにメッセージを割り当てます。フラグメントが利用できない場合、サービス バスは次移動します。この方法で一時的な障害メッセージング インフラストラクチャでは、メッセージ送信操作が失敗するを発生しません。</target>
          </trans-unit>
          <trans-unit id="314" xml:space="preserve">
            <source>決定するとき、どのように、次の点を考慮する必要がありますか、パーティション Service Bus メッセージ キューまたはトピックに。</source>
            <target state="new">決定するとき、どのように、次の点を考慮する必要がありますか、パーティション Service Bus メッセージ キューまたはトピックに。</target>
          </trans-unit>
          <trans-unit id="315" xml:space="preserve">
            <source>サービス バスのキューおよびトピックは、サービス バスの名前空間のスコープ内で作成されます。サービス バスは現在、最大 100 分割キューまたは名前空間あたりのトピックをことができます。</source>
            <target state="new">サービス バスのキューおよびトピックは、サービス バスの名前空間のスコープ内で作成されます。サービス バスは現在、最大 100 分割キューまたは名前空間あたりのトピックをことができます。</target>
          </trans-unit>
          <trans-unit id="316" xml:space="preserve">
            <source>各サービス バス名前空間は同時送信数、トピックあたりのサブスクリプション数などのリソースのクォータを課し、確立できる同時接続の最大数、1 秒あたりの要求を受け取る。これらのクォータは、ページ上のマイクロソフト web サイトに記載されて <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>サービス バスのクォータ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.これらの値を超える場合は、キュー、トピック、追加の名前空間を作成し、これらの名前空間にまたがる仕事。たとえば、グローバル アプリケーション各地域別の名前空間を作成し、最も近い名前空間内のキューおよびトピックを使用してアプリケーション インスタンスを構成します。</source>
            <target state="new">各サービス バス名前空間は同時送信数、トピックあたりのサブスクリプション数などのリソースのクォータを課し、確立できる同時接続の最大数、1 秒あたりの要求を受け取る。これらのクォータは、ページ上のマイクロソフト web サイトに記載されて <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>サービス バスのクォータ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.これらの値を超える場合は、キュー、トピック、追加の名前空間を作成し、これらの名前空間にまたがる仕事。たとえば、グローバル アプリケーション各地域別の名前空間を作成し、最も近い名前空間内のキューおよびトピックを使用してアプリケーション インスタンスを構成します。</target>
          </trans-unit>
          <trans-unit id="317" xml:space="preserve">
            <source>トランザクションの一部として送信されるメッセージは、パーティション キーを指定しなければなりません。これは、 <bpt id="2">&lt;em&gt;</bpt>SessionId、PartitionKey、<ept id="2">&lt;/em&gt;</ept> または <bpt id="4">&lt;em&gt;</bpt>MessageId<ept id="4">&lt;/em&gt;</ept>.同じトランザクションの一部として送信されるすべてのメッセージは、同じメッセージ ブローカー プロセスによって処理する必要がありますので、同じパーティション キーを指定しなければなりません。別のキューまたはトピック同じトランザクション内でメッセージを送信できません。</source>
            <target state="new">トランザクションの一部として送信されるメッセージは、パーティション キーを指定しなければなりません。これは、 <bpt id="2">&lt;em&gt;</bpt>SessionId、PartitionKey、<ept id="2">&lt;/em&gt;</ept> または <bpt id="4">&lt;em&gt;</bpt>MessageId<ept id="4">&lt;/em&gt;</ept>.同じトランザクションの一部として送信されるすべてのメッセージは、同じメッセージ ブローカー プロセスによって処理する必要がありますので、同じパーティション キーを指定しなければなりません。別のキューまたはトピック同じトランザクション内でメッセージを送信できません。</target>
          </trans-unit>
          <trans-unit id="318" xml:space="preserve">
            <source>パーティション分割されたキューまたはアイドル状態になるときに自動的に削除するトピックを構成できません。</source>
            <target state="new">パーティション分割されたキューまたはアイドル状態になるときに自動的に削除するトピックを構成できません。</target>
          </trans-unit>
          <trans-unit id="319" xml:space="preserve">
            <source>クロス プラットフォームまたはハイブリッド ソリューションを構築する場合現在使用できませんパーティションのキューおよびトピックで、高度なメッセージ キュー プロトコル (AMQP)。</source>
            <target state="new">クロス プラットフォームまたはハイブリッド ソリューションを構築する場合現在使用できませんパーティションのキューおよびトピックで、高度なメッセージ キュー プロトコル (AMQP)。</target>
          </trans-unit>
          <trans-unit id="320" xml:space="preserve">
            <source>Azure DocumentDB のパーティション分割戦略</source>
            <target state="new">Azure DocumentDB のパーティション分割戦略</target>
          </trans-unit>
          <trans-unit id="321" xml:space="preserve">
            <source>紺碧の DocumentDB は、ドキュメントを保存することができます NoSQL データベースです。DocumentDB 内のドキュメントは、オブジェクトまたはデータの他の部分の JSON シリアル化表現です。すべてのドキュメントは、一意の ID を含める必要があることを除いて固定スキーマは適用されません。</source>
            <target state="new">紺碧の DocumentDB は、ドキュメントを保存することができます NoSQL データベースです。DocumentDB 内のドキュメントは、オブジェクトまたはデータの他の部分の JSON シリアル化表現です。すべてのドキュメントは、一意の ID を含める必要があることを除いて固定スキーマは適用されません。</target>
          </trans-unit>
          <trans-unit id="322" xml:space="preserve">
            <source>ドキュメントは、コレクションに編成されます。コレクションは、関連するドキュメントをグループ化することができます。たとえば、ブログの投稿を維持するシステムでの [各ブログの記事の内容をコレクション内のドキュメントとして保存でき、各サブジェクトの種類のコレクションを作成します。また、異なった著者を可能にするシステムなどのマルチ テナント アプリケーションで記事を自分のブログを管理する、著者によるブログを分割して各著者ごとに別個のコレクションを作成します。コレクションに割り当てられた記憶領域弾性は、縮小、または必要に応じて拡張できます。</source>
            <target state="new">ドキュメントは、コレクションに編成されます。コレクションは、関連するドキュメントをグループ化することができます。たとえば、ブログの投稿を維持するシステムでの [各ブログの記事の内容をコレクション内のドキュメントとして保存でき、各サブジェクトの種類のコレクションを作成します。また、異なった著者を可能にするシステムなどのマルチ テナント アプリケーションで記事を自分のブログを管理する、著者によるブログを分割して各著者ごとに別個のコレクションを作成します。コレクションに割り当てられた記憶領域弾性は、縮小、または必要に応じて拡張できます。</target>
          </trans-unit>
          <trans-unit id="323" xml:space="preserve">
            <source>ドキュメントのコレクションは、単一のデータベース内のデータを分割する自然のメカニズムを提供します。内部的には、DocumentDB データベースは、複数のサーバーにまたがることができます、DocumentDB コレクションをサーバー間で分散して負荷を分散しようとする可能性があります。Sharding を実装する最も簡単な方法は、各シャードのコレクションを作成することです。</source>
            <target state="new">ドキュメントのコレクションは、単一のデータベース内のデータを分割する自然のメカニズムを提供します。内部的には、DocumentDB データベースは、複数のサーバーにまたがることができます、DocumentDB コレクションをサーバー間で分散して負荷を分散しようとする可能性があります。Sharding を実装する最も簡単な方法は、各シャードのコレクションを作成することです。</target>
          </trans-unit>
          <trans-unit id="324" xml:space="preserve">
            <source>[AZURE。メモ] 各 DocumentDB は、の面でリソースを割り当てられる、 _パフォーマンス レベル_.パフォーマンス レベルに関連付けられて、 <bpt id="2">&lt;em&gt;</bpt>要求単位<ept id="2">&lt;/em&gt;</ept> (RU) レートの制限。RU レートの制限は、そのコレクションのために予約されます、そのコレクションが排他的に使用できるリソースの量を指定します。コレクションのコストは、そのコレクションの選択パフォーマンス レベルによって異なります。性能が高いレベル (および RU レートの制限) が高いほどの料金。Azure 管理ポータルを使用して、コレクションのパフォーマンス レベルを調整できます。詳細については、ページを参照してください。 <bpt id="4CapsExtId1">&lt;link&gt;</bpt><bpt id="4CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB のパフォーマンス ・ レベル<ept id="4CapsExtId2">&lt;/linkText&gt;</ept><bpt id="4CapsExtId3">&lt;title&gt;</bpt><ept id="4CapsExtId3">&lt;/title&gt;</ept><ept id="4CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</source>
            <target state="new">[AZURE。メモ] 各 DocumentDB は、の面でリソースを割り当てられる、 _パフォーマンス レベル_.パフォーマンス レベルに関連付けられて、 <bpt id="2">&lt;em&gt;</bpt>要求単位<ept id="2">&lt;/em&gt;</ept> (RU) レートの制限。RU レートの制限は、そのコレクションのために予約されます、そのコレクションが排他的に使用できるリソースの量を指定します。コレクションのコストは、そのコレクションの選択パフォーマンス レベルによって異なります。性能が高いレベル (および RU レートの制限) が高いほどの料金。Azure 管理ポータルを使用して、コレクションのパフォーマンス レベルを調整できます。詳細については、ページを参照してください。 <bpt id="4CapsExtId1">&lt;link&gt;</bpt><bpt id="4CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB のパフォーマンス ・ レベル<ept id="4CapsExtId2">&lt;/linkText&gt;</ept><bpt id="4CapsExtId3">&lt;title&gt;</bpt><ept id="4CapsExtId3">&lt;/title&gt;</ept><ept id="4CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。</target>
          </trans-unit>
          <trans-unit id="325" xml:space="preserve">
            <source>DocumentDB アカウントのコンテキストでは、すべてのデータベースが作成されます。1 つの DocumentDB アカウントは、複数のデータベースを含めることができ、どの領域でデータベースが作成されますを指定します。各 DocumentDB アカウントはまた、独自のアクセス制御を適用します。ゲオと DocumentDB アカウントを使用することができます-、それらにアクセスする必要があるユーザーの近くに (データベース内のコレクション) の破片を見つけて、それらにユーザーのみが接続できるように制限を適用します。</source>
            <target state="new">DocumentDB アカウントのコンテキストでは、すべてのデータベースが作成されます。1 つの DocumentDB アカウントは、複数のデータベースを含めることができ、どの領域でデータベースが作成されますを指定します。各 DocumentDB アカウントはまた、独自のアクセス制御を適用します。ゲオと DocumentDB アカウントを使用することができます-、それらにアクセスする必要があるユーザーの近くに (データベース内のコレクション) の破片を見つけて、それらにユーザーのみが接続できるように制限を適用します。</target>
          </trans-unit>
          <trans-unit id="326" xml:space="preserve">
            <source>各 DocumentDB のアカウントには、データベースと、格納できるコレクションの数、使用できるドキュメント ストレージの量を制限するクォータがあります。これらの制限は、変更されるが、ページに記載して <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB 制限とクォータ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。それは理論的に可能なすべてのサーバーが同じデータベースに属しているシステムを実装する場合は、アカウントの記憶域の容量制限を達する可能性があります。この場合、追加 DocumentDB アカウントとデータベースを作成し、これらのデータベース間で破片を配布する必要があります。ただし、データベースのストレージ容量をヒットする可能性がない場合でも、複数のデータベースを使用するための良い理由は各データベースにユーザーとアクセス許可の独自のセットがあります。このメカニズムを使用すると、データベースごとにコレクションへのアクセスを分離することができます。</source>
            <target state="new">各 DocumentDB のアカウントには、データベースと、格納できるコレクションの数、使用できるドキュメント ストレージの量を制限するクォータがあります。これらの制限は、変更されるが、ページに記載して <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB 制限とクォータ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト。それは理論的に可能なすべてのサーバーが同じデータベースに属しているシステムを実装する場合は、アカウントの記憶域の容量制限を達する可能性があります。この場合、追加 DocumentDB アカウントとデータベースを作成し、これらのデータベース間で破片を配布する必要があります。ただし、データベースのストレージ容量をヒットする可能性がない場合でも、複数のデータベースを使用するための良い理由は各データベースにユーザーとアクセス許可の独自のセットがあります。このメカニズムを使用すると、データベースごとにコレクションへのアクセスを分離することができます。</target>
          </trans-unit>
          <trans-unit id="327" xml:space="preserve">
            <source>図 8 は、DocumentDB アーキテクチャの高レベルな構造を示しています。</source>
            <target state="new">図 8 は、DocumentDB アーキテクチャの高レベルな構造を示しています。</target>
          </trans-unit>
          <trans-unit id="328" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="329" xml:space="preserve">
            <source>_図 8。● DocumentDB の構造_</source>
            <target state="new">_図 8。● DocumentDB の構造_</target>
          </trans-unit>
          <trans-unit id="330" xml:space="preserve">
            <source>それは通常シャードのキーを定義するデータのいくつかの属性に基づいた独自のマッピング メカニズムを実装することによって適切なサーバに要求を直接クライアント アプリケーションの責任です。図 9 は、破片として 2 つのコレクションを含むそれぞれ 2 つの DocumentDB データベースを示しています。データは、テナント ID で sharded は、特定テナントのデータが含まれています。テナントが含まれているデータと同じ地域にある別の DocumenDB アカウントのデータベースが作成されます。クライアント アプリケーションでのルーティング ロジックは、破片のキーとしてテナント ID を使用します。</source>
            <target state="new">それは通常シャードのキーを定義するデータのいくつかの属性に基づいた独自のマッピング メカニズムを実装することによって適切なサーバに要求を直接クライアント アプリケーションの責任です。図 9 は、破片として 2 つのコレクションを含むそれぞれ 2 つの DocumentDB データベースを示しています。データは、テナント ID で sharded は、特定テナントのデータが含まれています。テナントが含まれているデータと同じ地域にある別の DocumenDB アカウントのデータベースが作成されます。クライアント アプリケーションでのルーティング ロジックは、破片のキーとしてテナント ID を使用します。</target>
          </trans-unit>
          <trans-unit id="331" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="332" xml:space="preserve">
            <source>_図 9。Azure DocumentDB を使用して分割を実装します。_</source>
            <target state="new">_図 9。Azure DocumentDB を使用して分割を実装します。_</target>
          </trans-unit>
          <trans-unit id="333" xml:space="preserve">
            <source>DocumentDB を使用してデータをパーティション分割する方法を決定するときは、次の点を考慮してください。</source>
            <target state="new">DocumentDB を使用してデータをパーティション分割する方法を決定するときは、次の点を考慮してください。</target>
          </trans-unit>
          <trans-unit id="334" xml:space="preserve">
            <source>DocumentDB データベースに利用可能なリソースは、DocumentDB アカウントのクォータの制限が適用されます。各データベースはコレクションの数を保持できる (また、限界がある) 各コレクション、そのコレクションの RU レートの制限 (予約スループット) を支配するパフォーマンス レベルと関連付けられる。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB 制限とクォータ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">DocumentDB データベースに利用可能なリソースは、DocumentDB アカウントのクォータの制限が適用されます。各データベースはコレクションの数を保持できる (また、限界がある) 各コレクション、そのコレクションの RU レートの制限 (予約スループット) を支配するパフォーマンス レベルと関連付けられる。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB 制限とクォータ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="335" xml:space="preserve">
            <source>各ドキュメントは、それが開催されますコレクション内でそのドキュメントを一意に識別するために使用できる属性が必要です。これは、ドキュメントを保持するコレクションで定義するシャード キーが違います。コレクションは、多数のドキュメント、理論的にはドキュメント ID の最大の長さによってのみ制限を含めることができます。ドキュメント ID は、最大 255 文字を使用できます。</source>
            <target state="new">各ドキュメントは、それが開催されますコレクション内でそのドキュメントを一意に識別するために使用できる属性が必要です。これは、ドキュメントを保持するコレクションで定義するシャード キーが違います。コレクションは、多数のドキュメント、理論的にはドキュメント ID の最大の長さによってのみ制限を含めることができます。ドキュメント ID は、最大 255 文字を使用できます。</target>
          </trans-unit>
          <trans-unit id="336" xml:space="preserve">
            <source>ドキュメントに対するすべての操作は、ドキュメントが含まれているコレクションのスコープはトランザクションのコンテキスト内で実行されます。操作が失敗すると、それが実行した作業はロールバックされます。 文書は、操作の対象は、行われた変更は予告無くスナップショット レベルの分離されることがあります。たとえば、新規ドキュメントの作成が失敗した場合、別のユーザーが同時にデータベースにクエリを実行するための要求が削除されます部分的なドキュメント表示されない場合は、このメカニズムを保証します。</source>
            <target state="new">ドキュメントに対するすべての操作は、ドキュメントが含まれているコレクションのスコープはトランザクションのコンテキスト内で実行されます。操作が失敗すると、それが実行した作業はロールバックされます。 文書は、操作の対象は、行われた変更は予告無くスナップショット レベルの分離されることがあります。たとえば、新規ドキュメントの作成が失敗した場合、別のユーザーが同時にデータベースにクエリを実行するための要求が削除されます部分的なドキュメント表示されない場合は、このメカニズムを保証します。</target>
          </trans-unit>
          <trans-unit id="337" xml:space="preserve">
            <source>DocumentDB クエリのスコープは、コレクション レベルにも。1 つのクエリのみ 1 つのコレクションからデータを取得できます。複数のコレクションからデータを取得する場合に、各コレクションを個別に照会し、アプリケーション コードで結果をマージする必要があります。</source>
            <target state="new">DocumentDB クエリのスコープは、コレクション レベルにも。1 つのクエリのみ 1 つのコレクションからデータを取得できます。複数のコレクションからデータを取得する場合に、各コレクションを個別に照会し、アプリケーション コードで結果をマージする必要があります。</target>
          </trans-unit>
          <trans-unit id="338" xml:space="preserve">
            <source>DocumentDB supports programmable items that can all be stored in a collection alongside documents: stored procedures, user-defined functions, and triggers (written in JavaScript).</source>
            <target state="new">DocumentDB supports programmable items that can all be stored in a collection alongside documents: stored procedures, user-defined functions, and triggers (written in JavaScript).</target>
          </trans-unit>
          <trans-unit id="339" xml:space="preserve">
            <source>These items can access any document within the same collection.</source>
            <target state="new">These items can access any document within the same collection.</target>
          </trans-unit>
          <trans-unit id="340" xml:space="preserve">
            <source>Furthermore, these items execute either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is executed as the result of an explicit client request).</source>
            <target state="new">Furthermore, these items execute either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is executed as the result of an explicit client request).</target>
          </trans-unit>
          <trans-unit id="341" xml:space="preserve">
            <source>If the code in a programmable item throws an exception, the transaction is rolled back.</source>
            <target state="new">If the code in a programmable item throws an exception, the transaction is rolled back.</target>
          </trans-unit>
          <trans-unit id="342" xml:space="preserve">
            <source>You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</source>
            <target state="new">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</target>
          </trans-unit>
          <trans-unit id="343" xml:space="preserve">
            <source>DocumentDB アカウントのデータベースで保持する場合は、コレクションが、コレクションのパフォーマンス ・ レベルで定義されているスループットの限界を超える可能性がないことを確認してください。これらの制限は、記載されて、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB 容量ニーズを管理します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。これらの制限に達することが予想される場合は、コレクションをコレクションごとに負荷を軽減する別の DocumentDB アカウントにデータベースに分割することを検討してください。</source>
            <target state="new">DocumentDB アカウントのデータベースで保持する場合は、コレクションが、コレクションのパフォーマンス ・ レベルで定義されているスループットの限界を超える可能性がないことを確認してください。これらの制限は、記載されて、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB 容量ニーズを管理します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。これらの制限に達することが予想される場合は、コレクションをコレクションごとに負荷を軽減する別の DocumentDB アカウントにデータベースに分割することを検討してください。</target>
          </trans-unit>
          <trans-unit id="344" xml:space="preserve">
            <source>紺碧の検索パーティション分割戦略</source>
            <target state="new">紺碧の検索パーティション分割戦略</target>
          </trans-unit>
          <trans-unit id="345" xml:space="preserve">
            <source>データを検索する機能は多くの場合プライマリ ナビゲーションと検索条件の組み合わせに基づいて、リソース (たとえば、e コマース アプリケーションで製品) をすばやく検索するユーザーを有効にする、多くの web アプリケーションによって提供される探索法です。Azure 検索サービスは、web コンテンツのフルテキスト検索機能を提供します、マッチ、およびファセット ナビゲーションの近くに基づく先行入力、提案されたクエリなどの機能が含まれています。これらの機能の完全な説明が要、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧の検索の概要<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">データを検索する機能は多くの場合プライマリ ナビゲーションと検索条件の組み合わせに基づいて、リソース (たとえば、e コマース アプリケーションで製品) をすばやく検索するユーザーを有効にする、多くの web アプリケーションによって提供される探索法です。Azure 検索サービスは、web コンテンツのフルテキスト検索機能を提供します、マッチ、およびファセット ナビゲーションの近くに基づく先行入力、提案されたクエリなどの機能が含まれています。これらの機能の完全な説明が要、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧の検索の概要<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="346" xml:space="preserve">
            <source>検索サービスは、検索可能なコンテンツをデータベース内で JSON ドキュメントとして格納します。これらのドキュメントの検索可能なフィールドを指定し、検索サービスにこれらの定義を提供するインデックスを定義します。ユーザーは、検索要求を送信する、検索サービスは適切なインデックスを使用して、一致する項目を検索します。</source>
            <target state="new">検索サービスは、検索可能なコンテンツをデータベース内で JSON ドキュメントとして格納します。これらのドキュメントの検索可能なフィールドを指定し、検索サービスにこれらの定義を提供するインデックスを定義します。ユーザーは、検索要求を送信する、検索サービスは適切なインデックスを使用して、一致する項目を検索します。</target>
          </trans-unit>
          <trans-unit id="347" xml:space="preserve">
            <source>Search サービスによって使用されているストレージの競合を減らすためには、分けることができるを 1、2、3、4、6、または 12 のパーティションと各パーティション レプリケートできます 6 回まで。パーティションのレプリカの数を掛けた数の製品と呼ばれる、 <bpt id="2">&lt;em&gt;</bpt>検索単位<ept id="2">&lt;/em&gt;</ept> (SU)。検索サービスの単一のインスタンスは、最大 36 SUs (12 のパーティションを含むデータベースは、最大 3 のレプリカをサポート) を含めることができます。あなたのサービスに割り当てられている各スに課金されます。検索可能なコンテンツの増加量または検索要求の数が大きくなると、余分な負荷を処理する検索サービスの既存のインスタンスに SUs を追加できます。検索サービス自体は、パーティション間で均等にドキュメントを配布するための責任を受け取り、手動パーティション分割戦略は、現在サポートされていません。</source>
            <target state="new">Search サービスによって使用されているストレージの競合を減らすためには、分けることができるを 1、2、3、4、6、または 12 のパーティションと各パーティション レプリケートできます 6 回まで。パーティションのレプリカの数を掛けた数の製品と呼ばれる、 <bpt id="2">&lt;em&gt;</bpt>検索単位<ept id="2">&lt;/em&gt;</ept> (SU)。検索サービスの単一のインスタンスは、最大 36 SUs (12 のパーティションを含むデータベースは、最大 3 のレプリカをサポート) を含めることができます。あなたのサービスに割り当てられている各スに課金されます。検索可能なコンテンツの増加量または検索要求の数が大きくなると、余分な負荷を処理する検索サービスの既存のインスタンスに SUs を追加できます。検索サービス自体は、パーティション間で均等にドキュメントを配布するための責任を受け取り、手動パーティション分割戦略は、現在サポートされていません。</target>
          </trans-unit>
          <trans-unit id="348" xml:space="preserve">
            <source>各パーティション最大 1500 万のドキュメントまたは 300 GB の記憶域 (ドキュメントおよびインデックスのサイズによっては、低いほう) を占有できます。50 までインデックスを作成できます。サービスのパフォーマンスは、ドキュメント、利用可能なインデックス、およびネットワークの遅延の影響の複雑さによって異なります。平均では、単一のレプリカ (1SU) のスループットのより正確な測定を取得する独自のデータでベンチマークを実行する必要がありますが 15 クエリ/秒 (QPS) を処理することがする必要があります。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>制限および制約 (紺碧検索 API)<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">各パーティション最大 1500 万のドキュメントまたは 300 GB の記憶域 (ドキュメントおよびインデックスのサイズによっては、低いほう) を占有できます。50 までインデックスを作成できます。サービスのパフォーマンスは、ドキュメント、利用可能なインデックス、およびネットワークの遅延の影響の複雑さによって異なります。平均では、単一のレプリカ (1SU) のスループットのより正確な測定を取得する独自のデータでベンチマークを実行する必要がありますが 15 クエリ/秒 (QPS) を処理することがする必要があります。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>制限および制約 (紺碧検索 API)<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="349" xml:space="preserve">
            <source>[AZURE。メモ] 検索可能なドキュメント内データ型の限定されたセットを格納することができます。文字列、ブール値、数値、datetime データ、およびいくつかの地理的なデータ。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>サポートされるデータ型 (紺碧検索)<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">[AZURE。メモ] 検索可能なドキュメント内データ型の限定されたセットを格納することができます。文字列、ブール値、数値、datetime データ、およびいくつかの地理的なデータ。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>サポートされるデータ型 (紺碧検索)<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="350" xml:space="preserve">
            <source>Azure の検索サービスが、サービスの各インスタンスのデータにパーティション分割制御を限られています。ただし、グローバル環境でパフォーマンスが向上し、いずれかの次の方法を使用して自身のサービスを分割することで待機時間とさらに競合を削減することができます。</source>
            <target state="new">Azure の検索サービスが、サービスの各インスタンスのデータにパーティション分割制御を限られています。ただし、グローバル環境でパフォーマンスが向上し、いずれかの次の方法を使用して自身のサービスを分割することで待機時間とさらに競合を削減することができます。</target>
          </trans-unit>
          <trans-unit id="351" xml:space="preserve">
            <source>各地域の検索サービスのインスタンスを作成し、クライアント アプリケーションに向けていることを確認、最も近い利用可能なインスタンス。この戦略では、サービスのすべてのインスタンス間でタイムリーに検索可能なコンテンツの更新がレプリケートされることが必要です。</source>
            <target state="new">各地域の検索サービスのインスタンスを作成し、クライアント アプリケーションに向けていることを確認、最も近い利用可能なインスタンス。この戦略では、サービスのすべてのインスタンス間でタイムリーに検索可能なコンテンツの更新がレプリケートされることが必要です。</target>
          </trans-unit>
          <trans-unit id="352" xml:space="preserve">
            <source>検索サービスの 2 層を作成します。その地域のユーザーが最も頻繁にアクセスするデータを含む各領域とすべてのデータを含むグローバル サービスでローカル サービス。ユーザーは、ローカル サービス (高速、限られた結果) のためにまたは (より遅いより完全な結果) のグローバル サービスに要求を送信できます。この方法は、検索対象のデータの重要な地方変化があるときに最適です。</source>
            <target state="new">検索サービスの 2 層を作成します。その地域のユーザーが最も頻繁にアクセスするデータを含む各領域とすべてのデータを含むグローバル サービスでローカル サービス。ユーザーは、ローカル サービス (高速、限られた結果) のためにまたは (より遅いより完全な結果) のグローバル サービスに要求を送信できます。この方法は、検索対象のデータの重要な地方変化があるときに最適です。</target>
          </trans-unit>
          <trans-unit id="353" xml:space="preserve">
            <source>Azure Redis キャッシュのパーティション分割戦略</source>
            <target state="new">Azure Redis キャッシュのパーティション分割戦略</target>
          </trans-unit>
          <trans-unit id="354" xml:space="preserve">
            <source>紺碧 Redis キャッシュ Redis キー/値データ ストアに基づいているクラウドで共有キャッシュ サービスを提供します。その名の通り、Azure Redis キャッシュ キャッシュ ソリューションでは、そうする必要がありますのみ使用して、永続的なデータ ストアではなく、一時的なデータを保持するためAzure Redis キャッシュを使用するアプリケーションは、キャッシュが利用可能な場合は機能し続けることができるはずです。紺碧 Redis キャッシュは、高可用性を実現するプライマリ/セカンダリ レプリケーションをサポートしていますが、現在 53 GB に最大キャッシュ サイズの制限します。これよりもより多くのスペースを必要がある場合、追加キャッシュを作成する必要があります。詳細については"を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Microsoft Azure キャッシュ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</source>
            <target state="new">紺碧 Redis キャッシュ Redis キー/値データ ストアに基づいているクラウドで共有キャッシュ サービスを提供します。その名の通り、Azure Redis キャッシュ キャッシュ ソリューションでは、そうする必要がありますのみ使用して、永続的なデータ ストアではなく、一時的なデータを保持するためAzure Redis キャッシュを使用するアプリケーションは、キャッシュが利用可能な場合は機能し続けることができるはずです。紺碧 Redis キャッシュは、高可用性を実現するプライマリ/セカンダリ レプリケーションをサポートしていますが、現在 53 GB に最大キャッシュ サイズの制限します。これよりもより多くのスペースを必要がある場合、追加キャッシュを作成する必要があります。詳細については"を参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Microsoft Azure キャッシュ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページ。</target>
          </trans-unit>
          <trans-unit id="355" xml:space="preserve">
            <source>Partitioning a Redis data store involves splitting the data across instances of the Redis service.</source>
            <target state="new">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</target>
          </trans-unit>
          <trans-unit id="356" xml:space="preserve">
            <source>Each instance constitutes a single partition.</source>
            <target state="new">Each instance constitutes a single partition.</target>
          </trans-unit>
          <trans-unit id="357" xml:space="preserve">
            <source>Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</source>
            <target state="new">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</target>
          </trans-unit>
          <trans-unit id="358" xml:space="preserve">
            <source>The simplest way to implement partitioning is to create multiple Azure Redis caches and spread the data across them.</source>
            <target state="new">The simplest way to implement partitioning is to create multiple Azure Redis caches and spread the data across them.</target>
          </trans-unit>
          <trans-unit id="359" xml:space="preserve">
            <source>You can associate each data item with an identifier (a partition key) that specifies in which cache it should be stored.</source>
            <target state="new">You can associate each data item with an identifier (a partition key) that specifies in which cache it should be stored.</target>
          </trans-unit>
          <trans-unit id="360" xml:space="preserve">
            <source>Your client application logic can use this identifier to route requests to the appropriate partition.</source>
            <target state="new">Your client application logic can use this identifier to route requests to the appropriate partition.</target>
          </trans-unit>
          <trans-unit id="361" xml:space="preserve">
            <source>This scheme is very simple, but if the partitioning scheme changes (if additional Azure Redis Caches are created, for example), client applications may need to be reconfigured.</source>
            <target state="new">This scheme is very simple, but if the partitioning scheme changes (if additional Azure Redis Caches are created, for example), client applications may need to be reconfigured.</target>
          </trans-unit>
          <trans-unit id="362" xml:space="preserve">
            <source>Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</source>
            <target state="new">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</target>
          </trans-unit>
          <trans-unit id="363" xml:space="preserve">
            <source>In this approach, the data is divided evenly across servers by using a hashing mechanism.</source>
            <target state="new">In this approach, the data is divided evenly across servers by using a hashing mechanism.</target>
          </trans-unit>
          <trans-unit id="364" xml:space="preserve">
            <source>Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</source>
            <target state="new">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</target>
          </trans-unit>
          <trans-unit id="365" xml:space="preserve">
            <source>Client applications simply send requests to any of the participating Redis servers (probably the closest server).The Redis server examines the client request and if it can be resolved locally it will perform the requested operation, otherwise it will forward the request on to the appropriate server.</source>
            <target state="new">Client applications simply send requests to any of the participating Redis servers (probably the closest server).The Redis server examines the client request and if it can be resolved locally it will perform the requested operation, otherwise it will forward the request on to the appropriate server.</target>
          </trans-unit>
          <trans-unit id="366" xml:space="preserve">
            <source>This model is implemented by using Redis clustering, and is described in more detail on the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis クラスター チュートリアル<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。Redis のクラスタ リングは、クライアント アプリケーションに透過的と Redis サーバーをクライアントを再構成することを必要とせず追加クラスター (およびデータの再分割) することができます。</source>
            <target state="new">This model is implemented by using Redis clustering, and is described in more detail on the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis クラスター チュートリアル<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。Redis のクラスタ リングは、クライアント アプリケーションに透過的と Redis サーバーをクライアントを再構成することを必要とせず追加クラスター (およびデータの再分割) することができます。</target>
          </trans-unit>
          <trans-unit id="367" xml:space="preserve">
            <source>[AZURE。重要です] 紺碧 Redis キャッシュは現在 Redis のクラスタ リングをサポートしていません。Azure ではこのアプローチを実装したい場合は、Azure の仮想マシンのセットに Redis をインストールし、それらを手動で構成する Redis サーバーを実装しなければなりません。ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CentOS Linux VM 上 Redis で実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトの web サイトの構築し、Azure の VM として実行している Redis ノードを構成する方法を示す例について説明します。</source>
            <target state="new">[AZURE。重要です] 紺碧 Redis キャッシュは現在 Redis のクラスタ リングをサポートしていません。Azure ではこのアプローチを実装したい場合は、Azure の仮想マシンのセットに Redis をインストールし、それらを手動で構成する Redis サーバーを実装しなければなりません。ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CentOS Linux VM 上 Redis で実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトの web サイトの構築し、Azure の VM として実行している Redis ノードを構成する方法を示す例について説明します。</target>
          </trans-unit>
          <trans-unit id="368" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis の複数のインスタンス間でデータを分割する方法の分割。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイトは Redis でパーティショニングの実装に関する詳細を提供します。このセクションの残りの部分では、クライアント側またはプロキシによるパーティション分割を実装することを前提としています。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis の複数のインスタンス間でデータを分割する方法の分割。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイトは Redis でパーティショニングの実装に関する詳細を提供します。このセクションの残りの部分では、クライアント側またはプロキシによるパーティション分割を実装することを前提としています。</target>
          </trans-unit>
          <trans-unit id="369" xml:space="preserve">
            <source>Azure Redis キャッシュを使用してデータをパーティション分割する方法を決定するときは、次の点を考慮してください。</source>
            <target state="new">Azure Redis キャッシュを使用してデータをパーティション分割する方法を決定するときは、次の点を考慮してください。</target>
          </trans-unit>
          <trans-unit id="370" xml:space="preserve">
            <source>紺碧 Redis キャッシュを実装するどのようなパーティション構成、アプリケーション コードは、データがキャッシュに見つからないことを受け入れるために準備する必要があり、他の場所から取得する必要がので、永続的なデータ ストアとして機能するものではありません。</source>
            <target state="new">紺碧 Redis キャッシュを実装するどのようなパーティション構成、アプリケーション コードは、データがキャッシュに見つからないことを受け入れるために準備する必要があり、他の場所から取得する必要がので、永続的なデータ ストアとして機能するものではありません。</target>
          </trans-unit>
          <trans-unit id="371" xml:space="preserve">
            <source>頻繁にアクセスされるデータを同じパーティションにまとめます。Redis は単純な文字列から範囲内のデータを構築するためのいくつかの高度に最適化されたメカニズムを提供する強力なキー/値ストア (実際には、バイナリ データの長さが 512 MB) (キューやスタックとして使用できます) のリスト、セット (注文し、順不同)、ハッシュ (つまり、オブジェクト内のフィールドを表す項目など一緒に、関連分野をグループすることができます) などの集約型に。集計の種類は、同じキーを持つ多くの関連する値を関連付けることができますを有効にします。Redis キーは、それに含まれるデータ項目ではなく、リスト、セット、またはハッシュを識別します。これらのタイプは Azure Redis キャッシュで利用可能なすべて、によって記述される、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データ型<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。たとえば、一部の顧客による注文を追跡する e コマース システム、各顧客の詳細に格納できます顧客 ID を使って、キー Redis ハッシュそれぞれのハッシュは、お客様の注文 Id のコレクションを保持できます。別 Redis セットの注文、注文 ID を使用して、キー ハッシュとして再び構造を保持することが 図 10 は、この構造を示しています。Redis しませんので、顧客と注文の間のリレーションシップを維持するために開発者は、参照整合性の任意のフォームを実装しないことに注意してください。</source>
            <target state="new">頻繁にアクセスされるデータを同じパーティションにまとめます。Redis は単純な文字列から範囲内のデータを構築するためのいくつかの高度に最適化されたメカニズムを提供する強力なキー/値ストア (実際には、バイナリ データの長さが 512 MB) (キューやスタックとして使用できます) のリスト、セット (注文し、順不同)、ハッシュ (つまり、オブジェクト内のフィールドを表す項目など一緒に、関連分野をグループすることができます) などの集約型に。集計の種類は、同じキーを持つ多くの関連する値を関連付けることができますを有効にします。Redis キーは、それに含まれるデータ項目ではなく、リスト、セット、またはハッシュを識別します。これらのタイプは Azure Redis キャッシュで利用可能なすべて、によって記述される、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データ型<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。たとえば、一部の顧客による注文を追跡する e コマース システム、各顧客の詳細に格納できます顧客 ID を使って、キー Redis ハッシュそれぞれのハッシュは、お客様の注文 Id のコレクションを保持できます。別 Redis セットの注文、注文 ID を使用して、キー ハッシュとして再び構造を保持することが 図 10 は、この構造を示しています。Redis しませんので、顧客と注文の間のリレーションシップを維持するために開発者は、参照整合性の任意のフォームを実装しないことに注意してください。</target>
          </trans-unit>
          <trans-unit id="372" xml:space="preserve">
            <source><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></source>
            <target state="new"><bpt id="1">&lt;linkText&gt;</bpt><ept id="1">&lt;/linkText&gt;</ept></target>
          </trans-unit>
          <trans-unit id="373" xml:space="preserve">
            <source>_図 10。-Redis ストレージ顧客の注文とその詳細を記録するために提案された構造_</source>
            <target state="new">_図 10。-Redis ストレージ顧客の注文とその詳細を記録するために提案された構造_</target>
          </trans-unit>
          <trans-unit id="374" xml:space="preserve">
            <source>[AZURE。メモ] Redis のすべてのキーは (Redis 文字列) のようなバイナリ データ値、理論的にはキーは、ほとんどの情報を含めることができますので、512 MB までのデータを含めることができます。ただし、データの種類の説明ですと、エンティティを識別する、それは過度に長いではないキー用の一貫性のある命名規約を採用すべき。一般的なアプローチは、フォーム"エンティティのキーを使用するには_タイプ: ID"、「顧客: 99」に顧客 ID 99 のキーを示すなど。</source>
            <target state="new">[AZURE。メモ] Redis のすべてのキーは (Redis 文字列) のようなバイナリ データ値、理論的にはキーは、ほとんどの情報を含めることができますので、512 MB までのデータを含めることができます。ただし、データの種類の説明ですと、エンティティを識別する、それは過度に長いではないキー用の一貫性のある命名規約を採用すべき。一般的なアプローチは、フォーム"エンティティのキーを使用するには_タイプ: ID"、「顧客: 99」に顧客 ID 99 のキーを示すなど。</target>
          </trans-unit>
          <trans-unit id="375" xml:space="preserve">
            <source>同じデータベース内の別の集計の関連情報を格納することによって列方向の分割を実装できます。たとえば、e コマースの一般的格納できます。 アプリケーション アクセス Redis ハッシュは 1 つの製品に関する情報および別のより少なく頻繁に使用される詳細情報。両方のハッシュがたとえば同じプロダクト ID キーの一部として使用できる"製品。<bpt id="2">&lt;em&gt;</bpt>nn<ept id="2">&lt;/em&gt;</ept>「どこで <bpt id="4">&lt;em&gt;</bpt>nn<ept id="4">&lt;/em&gt;</ept> 製品情報や"製品の製品 ID です。_詳細: <bpt id="6">&lt;em&gt;</bpt>nn<ept id="6">&lt;/em&gt;</ept>」の詳細なデータ。この戦略は、ほとんどのクエリが取得する可能性があるデータの量を減らすために助けることができます。</source>
            <target state="new">同じデータベース内の別の集計の関連情報を格納することによって列方向の分割を実装できます。たとえば、e コマースの一般的格納できます。 アプリケーション アクセス Redis ハッシュは 1 つの製品に関する情報および別のより少なく頻繁に使用される詳細情報。両方のハッシュがたとえば同じプロダクト ID キーの一部として使用できる"製品。<bpt id="2">&lt;em&gt;</bpt>nn<ept id="2">&lt;/em&gt;</ept>「どこで <bpt id="4">&lt;em&gt;</bpt>nn<ept id="4">&lt;/em&gt;</ept> 製品情報や"製品の製品 ID です。_詳細: <bpt id="6">&lt;em&gt;</bpt>nn<ept id="6">&lt;/em&gt;</ept>」の詳細なデータ。この戦略は、ほとんどのクエリが取得する可能性があるデータの量を減らすために助けることができます。</target>
          </trans-unit>
          <trans-unit id="376" xml:space="preserve">
            <source>Repartitioning a Redis data store is a complex and time-consuming task.</source>
            <target state="new">Repartitioning a Redis data store is a complex and time-consuming task.</target>
          </trans-unit>
          <trans-unit id="377" xml:space="preserve">
            <source>Redis clustering can repartition data automatically, but this facility is not available with Azure Redis Cache.</source>
            <target state="new">Redis clustering can repartition data automatically, but this facility is not available with Azure Redis Cache.</target>
          </trans-unit>
          <trans-unit id="378" xml:space="preserve">
            <source>Therefore, when you design your partitioning scheme, you should endeavor to leave sufficient free space in each partition to allow for expected data growth over time.</source>
            <target state="new">Therefore, when you design your partitioning scheme, you should endeavor to leave sufficient free space in each partition to allow for expected data growth over time.</target>
          </trans-unit>
          <trans-unit id="379" xml:space="preserve">
            <source>However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</source>
            <target state="new">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</target>
          </trans-unit>
          <trans-unit id="380" xml:space="preserve">
            <source>For relatively volatile data the TTL should be short, but for static data the TTL can be a lot longer.</source>
            <target state="new">For relatively volatile data the TTL should be short, but for static data the TTL can be a lot longer.</target>
          </trans-unit>
          <trans-unit id="381" xml:space="preserve">
            <source>You should avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</source>
            <target state="new">You should avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</target>
          </trans-unit>
          <trans-unit id="382" xml:space="preserve">
            <source>You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</source>
            <target state="new">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</target>
          </trans-unit>
          <trans-unit id="383" xml:space="preserve">
            <source>[AZURE。メモ] 紺碧 Redis キャッシュでは、適切な価格の区分を選択することによって (53 GB 250 MB) からキャッシュの最大サイズを指定できます。ただし、Azure Redis キャッシュが作成されると、ことはできません (増減する) のサイズ。</source>
            <target state="new">[AZURE。メモ] 紺碧 Redis キャッシュでは、適切な価格の区分を選択することによって (53 GB 250 MB) からキャッシュの最大サイズを指定できます。ただし、Azure Redis キャッシュが作成されると、ことはできません (増減する) のサイズ。</target>
          </trans-unit>
          <trans-unit id="384" xml:space="preserve">
            <source>Redis バッチとトランザクションは、バッチまたはトランザクションの影響を受けるすべてのデータが同じデータベース (破片) に開催されなければならないので、複数の接続をまたがることができません。</source>
            <target state="new">Redis バッチとトランザクションは、バッチまたはトランザクションの影響を受けるすべてのデータが同じデータベース (破片) に開催されなければならないので、複数の接続をまたがることができません。</target>
          </trans-unit>
          <trans-unit id="385" xml:space="preserve">
            <source>[AZURE。メモ] Redis トランザクションの操作の順序は必ずしも原子ではないです。トランザクションを構成するコマンドが確認され、実行する前にキューし、キュー全体が破棄されますこのフェーズでエラーが発生した場合。ただし、トランザクションが正常に送信されるキューに登録されたコマンドはシーケンスで実行されます。任意のコマンドは、そのコマンドだけを失敗した場合は中止されます。キュー内のすべての以前およびそれ以降のコマンドが実行されます。場合は、分割不可能な操作を実行する必要があります。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>トランザクション<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</source>
            <target state="new">[AZURE。メモ] Redis トランザクションの操作の順序は必ずしも原子ではないです。トランザクションを構成するコマンドが確認され、実行する前にキューし、キュー全体が破棄されますこのフェーズでエラーが発生した場合。ただし、トランザクションが正常に送信されるキューに登録されたコマンドはシーケンスで実行されます。任意のコマンドは、そのコマンドだけを失敗した場合は中止されます。キュー内のすべての以前およびそれ以降のコマンドが実行されます。場合は、分割不可能な操作を実行する必要があります。詳細についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>トランザクション<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイトのページ。</target>
          </trans-unit>
          <trans-unit id="386" xml:space="preserve">
            <source>Redis アトミック操作の限られた数をサポートしています、このタイプの操作複数のキーと値をサポートするが、(これはキーの指定されたリストの値のコレクションを返します) MGET、MSET (これはキーの指定されたリストの値のコレクションを格納することができます)。これらの操作を使用する場合に MSET と MGET コマンドによって参照されるキーと値のペアは、同じデータベース内で貯えられなければなりません。</source>
            <target state="new">Redis アトミック操作の限られた数をサポートしています、このタイプの操作複数のキーと値をサポートするが、(これはキーの指定されたリストの値のコレクションを返します) MGET、MSET (これはキーの指定されたリストの値のコレクションを格納することができます)。これらの操作を使用する場合に MSET と MGET コマンドによって参照されるキーと値のペアは、同じデータベース内で貯えられなければなりません。</target>
          </trans-unit>
          <trans-unit id="387" xml:space="preserve">
            <source>パーティションをリバランス</source>
            <target state="new">パーティションをリバランス</target>
          </trans-unit>
          <trans-unit id="388" xml:space="preserve">
            <source>システムが成熟しての使用パターンを把握するなり、パーティションの構成を調整する必要がありますされる可能性です。個々 のパーティションの不均衡な量のトラフィックを集めているとホット、過度な競合になる可能性があります。さらに、可能性がありますの下で-予定していたいくつかのパーティション内のデータの量これらのパーティションで記憶容量の限界をアプローチする原因します。何が原因で、負荷をより均等に分散するためのパーティションを再調整する必要があります。</source>
            <target state="new">システムが成熟しての使用パターンを把握するなり、パーティションの構成を調整する必要がありますされる可能性です。個々 のパーティションの不均衡な量のトラフィックを集めているとホット、過度な競合になる可能性があります。さらに、可能性がありますの下で-予定していたいくつかのパーティション内のデータの量これらのパーティションで記憶容量の限界をアプローチする原因します。何が原因で、負荷をより均等に分散するためのパーティションを再調整する必要があります。</target>
          </trans-unit>
          <trans-unit id="389" xml:space="preserve">
            <source>いくつかのケースで利用可能なリソースの限界内のパーティションも公開データはサーバーに割り当てられている方法を公開しないデータのストレージ ・ システムに自動的に再配分できます。状況によっては、2 つの段階で構成される管理タスクをリバランスです。</source>
            <target state="new">いくつかのケースで利用可能なリソースの限界内のパーティションも公開データはサーバーに割り当てられている方法を公開しないデータのストレージ ・ システムに自動的に再配分できます。状況によっては、2 つの段階で構成される管理タスクをリバランスです。</target>
          </trans-unit>
          <trans-unit id="390" xml:space="preserve">
            <source>どのパーティション分割 (または多分結合こと)、必要があります、新しいパーティション キーを設計することによってこれらの新しいパーティションにデータを割り当てる方法を確認するために新しいパーティション分割ストラテジを決定します。</source>
            <target state="new">どのパーティション分割 (または多分結合こと)、必要があります、新しいパーティション キーを設計することによってこれらの新しいパーティションにデータを割り当てる方法を確認するために新しいパーティション分割ストラテジを決定します。</target>
          </trans-unit>
          <trans-unit id="391" xml:space="preserve">
            <source>古いパーティション構成から影響を受けるデータを新しいパーティションのセットに移行します。</source>
            <target state="new">古いパーティション構成から影響を受けるデータを新しいパーティションのセットに移行します。</target>
          </trans-unit>
          <trans-unit id="392" xml:space="preserve">
            <source>[AZURE。メモ] DocumentDB コレクション サーバーへのマッピングが透明でしかしまだ DocumentDB アカウントの記憶域の容量とスループットの制限に到達する可能性があります、その場合、パーティション スキームを再設計し、データを移行する必要があります。</source>
            <target state="new">[AZURE。メモ] DocumentDB コレクション サーバーへのマッピングが透明でしかしまだ DocumentDB アカウントの記憶域の容量とスループットの制限に到達する可能性があります、その場合、パーティション スキームを再設計し、データを移行する必要があります。</target>
          </trans-unit>
          <trans-unit id="393" xml:space="preserve">
            <source>データ ・ ストレージ ・ テクノロジー、データ ストレージ システムの設計によって、(オンライン移行) の使用中のパーティション間でデータを移行することができます。これが可能でない場合は、データの再配置 (オフライン移行) 中影響を受けるパーティションを一時的に使用できないようにする必要があります。</source>
            <target state="new">データ ・ ストレージ ・ テクノロジー、データ ストレージ システムの設計によって、(オンライン移行) の使用中のパーティション間でデータを移行することができます。これが可能でない場合は、データの再配置 (オフライン移行) 中影響を受けるパーティションを一時的に使用できないようにする必要があります。</target>
          </trans-unit>
          <trans-unit id="394" xml:space="preserve">
            <source>オフライン移行</source>
            <target state="new">オフライン移行</target>
          </trans-unit>
          <trans-unit id="395" xml:space="preserve">
            <source>競合が発生している可能性が減るためオフライン移行は恐らく間違いなく最も簡単な方法されている間、移行対象のデータを変更しないでくださいに移動し、再構築します。</source>
            <target state="new">競合が発生している可能性が減るためオフライン移行は恐らく間違いなく最も簡単な方法されている間、移行対象のデータを変更しないでくださいに移動し、再構築します。</target>
          </trans-unit>
          <trans-unit id="396" xml:space="preserve">
            <source>概念的には、このプロセスでは、次の手順から構成されます。</source>
            <target state="new">概念的には、このプロセスでは、次の手順から構成されます。</target>
          </trans-unit>
          <trans-unit id="397" xml:space="preserve">
            <source>オフラインでの破片をマークします。</source>
            <target state="new">オフラインでの破片をマークします。</target>
          </trans-unit>
          <trans-unit id="398" xml:space="preserve">
            <source>分割/マージし、新しいシャードに移動データ</source>
            <target state="new">分割/マージし、新しいシャードに移動データ</target>
          </trans-unit>
          <trans-unit id="399" xml:space="preserve">
            <source>データを確認します。</source>
            <target state="new">データを確認します。</target>
          </trans-unit>
          <trans-unit id="400" xml:space="preserve">
            <source>オンラインでの新しい破片をもたらす</source>
            <target state="new">オンラインでの新しい破片をもたらす</target>
          </trans-unit>
          <trans-unit id="401" xml:space="preserve">
            <source>古い破片を削除します。</source>
            <target state="new">古い破片を削除します。</target>
          </trans-unit>
          <trans-unit id="402" xml:space="preserve">
            <source>いくつかの可用性を保持するには、それを使用できないようにするのではなく、ステップ 1 で読み取り専用として元の破片をマークする可能性があります。これは移動中に、データの読み取りをアプリケーションに許可するだろうが、それを変更できません。</source>
            <target state="new">いくつかの可用性を保持するには、それを使用できないようにするのではなく、ステップ 1 で読み取り専用として元の破片をマークする可能性があります。これは移動中に、データの読み取りをアプリケーションに許可するだろうが、それを変更できません。</target>
          </trans-unit>
          <trans-unit id="403" xml:space="preserve">
            <source>オンライン移行</source>
            <target state="new">オンライン移行</target>
          </trans-unit>
          <trans-unit id="404" xml:space="preserve">
            <source>オンライン移行ですが実行するより複雑な全体の手順中に、データが使用可能で、ユーザーに及ぼす影響が少なく。プロセスは、元の破片は、オフライン (ステップ 1) をマークされていないことを除いてオフライン移行で使用に似ています。読書を処理する必要がありますクライアント アプリケーションでのデータ アクセス コード、(項目または破片の破片による) 移行プロセスの粒度によって、2 つの場所 (元の破片と新しいシャード) で開催されたデータの書き込み</source>
            <target state="new">オンライン移行ですが実行するより複雑な全体の手順中に、データが使用可能で、ユーザーに及ぼす影響が少なく。プロセスは、元の破片は、オフライン (ステップ 1) をマークされていないことを除いてオフライン移行で使用に似ています。読書を処理する必要がありますクライアント アプリケーションでのデータ アクセス コード、(項目または破片の破片による) 移行プロセスの粒度によって、2 つの場所 (元の破片と新しいシャード) で開催されたデータの書き込み</target>
          </trans-unit>
          <trans-unit id="405" xml:space="preserve">
            <source>オンラインでの移行をサポートするソリューションの例についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>弾性スケールの分割/マージ サービス<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>、Microsoft のウェブサイトでオンライン記録。</source>
            <target state="new">オンラインでの移行をサポートするソリューションの例についてを参照してください、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>弾性スケールの分割/マージ サービス<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>、Microsoft のウェブサイトでオンライン記録。</target>
          </trans-unit>
          <trans-unit id="406" xml:space="preserve">
            <source>関連するパターンと指導</source>
            <target state="new">関連するパターンと指導</target>
          </trans-unit>
          <trans-unit id="407" xml:space="preserve">
            <source>次のパターンは、データの整合性を実装するための戦略を検討する際のシナリオに関連あります。</source>
            <target state="new">次のパターンは、データの整合性を実装するための戦略を検討する際のシナリオに関連あります。</target>
          </trans-unit>
          <trans-unit id="408" xml:space="preserve">
            <source>データ整合性ガイダンスのページでは、Microsoft の web サイトで利用可能なクラウドなど分散環境での一貫性を維持するための戦略を説明します。</source>
            <target state="new">データ整合性ガイダンスのページでは、Microsoft の web サイトで利用可能なクラウドなど分散環境での一貫性を維持するための戦略を説明します。</target>
          </trans-unit>
          <trans-unit id="409" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データ パーティション分割指導<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページは、分散ソリューションで様々 な条件を満たすためのパーティション デザインの一般的な概要を提供します。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データ パーティション分割指導<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページは、分散ソリューションで様々 な条件を満たすためのパーティション デザインの一般的な概要を提供します。</target>
          </trans-unit>
          <trans-unit id="410" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>、Microsoft の web サイトに記載されている、分割データのいくつかの一般的な戦略の概要を示します。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>、Microsoft の web サイトに記載されている、分割データのいくつかの一般的な戦略の概要を示します。</target>
          </trans-unit>
          <trans-unit id="411" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>インデックス テーブル パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 記載されているマイクロソフトの web サイトは、データ上のセカンダリ インデックスを作成する方法を示しています。この方法は、すぐにコレクションの主キーを参照しないクエリを使用してデータを取得するアプリケーションをできます。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>インデックス テーブル パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 記載されているマイクロソフトの web サイトは、データ上のセカンダリ インデックスを作成する方法を示しています。この方法は、すぐにコレクションの主キーを参照しないクエリを使用してデータを取得するアプリケーションをできます。</target>
          </trans-unit>
          <trans-unit id="412" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>マテリアライズド ビュー パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 説明したマイクロソフトのウェブサイトは、高速なクエリ操作をサポートするデータを要約するあらかじめ設定されているビューを生成する方法を説明します。このアプローチは、要約するデータを含むパーティションが複数のサイトに分散されて場合パーティション分割されたデータ ストアで便利に使えます。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>マテリアライズド ビュー パターン<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> 説明したマイクロソフトのウェブサイトは、高速なクエリ操作をサポートするデータを要約するあらかじめ設定されているビューを生成する方法を説明します。このアプローチは、要約するデータを含むパーティションが複数のサイトに分散されて場合パーティション分割されたデータ ストアで便利に使えます。</target>
          </trans-unit>
          <trans-unit id="413" xml:space="preserve">
            <source>記事コンテンツ配信ネットワーク (CDN) は、構成および azure CDN を使用の追加のガイダンスを提供します。</source>
            <target state="new">記事コンテンツ配信ネットワーク (CDN) は、構成および azure CDN を使用の追加のガイダンスを提供します。</target>
          </trans-unit>
          <trans-unit id="414" xml:space="preserve">
            <source>詳細については</source>
            <target state="new">詳細については</target>
          </trans-unit>
          <trans-unit id="415" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の SQL データベース<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページを作成し、SQL データベースを使用する方法を説明する詳細なドキュメントを提供します。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の SQL データベース<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページを作成し、SQL データベースを使用する方法を説明する詳細なドキュメントを提供します。</target>
          </trans-unit>
          <trans-unit id="416" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>SQL azure データベースの柔軟な拡張性の概要<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトは、柔軟な拡張性の包括的な概要を提供します。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>SQL azure データベースの柔軟な拡張性の概要<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトは、柔軟な拡張性の包括的な概要を提供します。</target>
          </trans-unit>
          <trans-unit id="417" xml:space="preserve">
            <source>トピック <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割およびマージによる柔軟な拡張性<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトには、分割/マージ サービスを使って柔軟な拡張性の破片を管理する情報が含まれています。</source>
            <target state="new">トピック <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>分割およびマージによる柔軟な拡張性<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトには、分割/マージ サービスを使って柔軟な拡張性の破片を管理する情報が含まれています。</target>
          </trans-unit>
          <trans-unit id="418" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトは、Azure ストレージの現在のサイズとスループットの限界を説明します。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure ストレージのスケーラビリティとパフォーマンスの目標<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトは、Azure ストレージの現在のサイズとスループットの限界を説明します。</target>
          </trans-unit>
          <trans-unit id="419" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>エンティティ グループ トランザクションの実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページでは、Azure テーブル ストレージに格納されているエンティティ経由のトランザクション操作の実装に関する詳細情報を提供します。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>エンティティ グループ トランザクションの実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページでは、Azure テーブル ストレージに格納されているエンティティ経由のトランザクション操作の実装に関する詳細情報を提供します。</target>
          </trans-unit>
          <trans-unit id="420" xml:space="preserve">
            <source>記事 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure テーブル ストレージの拡張性の高いパーティション分割戦略の設計<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトには Azure テーブル ストレージ内のデータのパーティション分割の詳細情報が含まれています。</source>
            <target state="new">記事 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure テーブル ストレージの拡張性の高いパーティション分割戦略の設計<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトには Azure テーブル ストレージ内のデータのパーティション分割の詳細情報が含まれています。</target>
          </trans-unit>
          <trans-unit id="421" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CDN を使用してください。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトは、Azure コンテンツ配信ネットワーク (CDN) を使用して、Azure Blob ストレージに保持されたデータをレプリケートする方法をについて説明します。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CDN を使用してください。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトは、Azure コンテンツ配信ネットワーク (CDN) を使用して、Azure Blob ストレージに保持されたデータをレプリケートする方法をについて説明します。</target>
          </trans-unit>
          <trans-unit id="422" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>プレビュー リリースの DocumentDB 制限<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトでは、Microsoft DocumentDB の現在の制限やクォータを説明します。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>プレビュー リリースの DocumentDB 制限<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトのウェブサイトでは、Microsoft DocumentDB の現在の制限やクォータを説明します。</target>
          </trans-unit>
          <trans-unit id="423" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB 容量とパフォーマンスを管理します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトの web サイトには、Azure DocumentDB がデータベースにリソースを割り当てる方法に関する情報が含まれています。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>DocumentDB 容量とパフォーマンスを管理します。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトの web サイトには、Azure DocumentDB がデータベースにリソースを割り当てる方法に関する情報が含まれています。</target>
          </trans-unit>
          <trans-unit id="424" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧の検索の概要<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft web サイト上のページでは、Azure の検索サービスで利用できる機能の完全な説明を提供します。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>紺碧の検索の概要<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft web サイト上のページでは、Azure の検索サービスで利用できる機能の完全な説明を提供します。</target>
          </trans-unit>
          <trans-unit id="425" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>制限および制約 (紺碧検索 API)<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページには、Azure の検索サービスの各インスタンスの容量に関する情報が含まれています。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>制限および制約 (紺碧検索 API)<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページには、Azure の検索サービスの各インスタンスの容量に関する情報が含まれています。</target>
          </trans-unit>
          <trans-unit id="426" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>サポートされるデータ型 (紺碧検索)<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページは、検索可能なドキュメントおよびインデックスで使用できるデータ型をまとめたものです。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>サポートされるデータ型 (紺碧検索)<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページは、検索可能なドキュメントおよびインデックスで使用できるデータ型をまとめたものです。</target>
          </trans-unit>
          <trans-unit id="427" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Microsoft Azure キャッシュ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページでは、Azure Redis キャッシュについて紹介します。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Microsoft Azure キャッシュ<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Microsoft の web サイト上のページでは、Azure Redis キャッシュについて紹介します。</target>
          </trans-unit>
          <trans-unit id="428" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis の複数のインスタンス間でデータを分割する方法の分割。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイトは Redis でパーティショニングの実装に関する情報を提供します。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Redis の複数のインスタンス間でデータを分割する方法の分割。<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis のウェブサイトは Redis でパーティショニングの実装に関する情報を提供します。</target>
          </trans-unit>
          <trans-unit id="429" xml:space="preserve">
            <source>ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CentOS Linux VM 上 Redis で実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトの web サイトの構築し、Azure の VM として実行している Redis ノードを構成する方法を示す例について説明します。</source>
            <target state="new">ページ <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Azure の CentOS Linux VM 上 Redis で実行<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> マイクロソフトの web サイトの構築し、Azure の VM として実行している Redis ノードを構成する方法を示す例について説明します。</target>
          </trans-unit>
          <trans-unit id="430" xml:space="preserve">
            <source>、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データ型<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイト上のページでは、Redis と Azure Redis キャッシュで使用可能なデータ型について説明します。</source>
            <target state="new">、 <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>データ型<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> Redis ウェブサイト上のページでは、Redis と Azure Redis キャッシュで使用可能なデータ型について説明します。</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>