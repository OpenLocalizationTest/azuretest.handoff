<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-tw" original="2/20/2016 11:45:59 AM" tool-id="MarkdownTransformer" product-name="N/A" product-version="N/A" build-num="1">
    <header>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6167f4e0f78bc8cfe7c5aa5eec86e691ebefae66</xliffext:olfilehash>
      <tool tool-id="MarkdownTransformer" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
    </header>
    <body>
      <group extype="content">
        <group id="101">
          <trans-unit id="101" xml:space="preserve">
            <source>Partitioning data in DocumentDB | Microsoft Azure</source>
            <target state="new">Partitioning data in DocumentDB | Microsoft Azure</target>
          </trans-unit>
          <trans-unit id="102" xml:space="preserve">
            <source>Learn about how to partition data in DocumentDB, and when to use Hash, Range and Lookup partitioning.</source>
            <target state="new">Learn about how to partition data in DocumentDB, and when to use Hash, Range and Lookup partitioning.</target>
          </trans-unit>
          <trans-unit id="103" xml:space="preserve">
            <source>Partitioning data in DocumentDB</source>
            <target state="new">Partitioning data in DocumentDB</target>
          </trans-unit>
          <trans-unit id="104" xml:space="preserve">
            <source><bpt id="1CapsExtId1">&lt;link&gt;</bpt><bpt id="1CapsExtId2">&lt;linkText&gt;</bpt>Microsoft Azure DocumentDB<ept id="1CapsExtId2">&lt;/linkText&gt;</ept><bpt id="1CapsExtId3">&lt;title&gt;</bpt><ept id="1CapsExtId3">&lt;/title&gt;</ept><ept id="1CapsExtId1">&lt;/link&gt;</ept> is designed to help you achieve fast, predictable performance and <bpt id="3">&lt;em&gt;</bpt>scale-out<ept id="3">&lt;/em&gt;</ept> seamlessly along with your application as it grows.</source>
            <target state="new"><bpt id="1CapsExtId1">&lt;link&gt;</bpt><bpt id="1CapsExtId2">&lt;linkText&gt;</bpt>Microsoft Azure DocumentDB<ept id="1CapsExtId2">&lt;/linkText&gt;</ept><bpt id="1CapsExtId3">&lt;title&gt;</bpt><ept id="1CapsExtId3">&lt;/title&gt;</ept><ept id="1CapsExtId1">&lt;/link&gt;</ept> is designed to help you achieve fast, predictable performance and <bpt id="3">&lt;em&gt;</bpt>scale-out<ept id="3">&lt;/em&gt;</ept> seamlessly along with your application as it grows.</target>
          </trans-unit>
          <trans-unit id="105" xml:space="preserve">
            <source>DocumentDB has been used to power high-scale production services at Microsoft like the User Data Store that powers the MSN suite of web and mobile apps.</source>
            <target state="new">DocumentDB has been used to power high-scale production services at Microsoft like the User Data Store that powers the MSN suite of web and mobile apps.</target>
          </trans-unit>
          <trans-unit id="106" xml:space="preserve">
            <source>You can achieve near-infinite scale in terms of storage and throughput for your DocumentDB application by horizontally partitioning your data - a concept commonly referred to as <bpt id="2">&lt;strong&gt;</bpt>sharding<ept id="2">&lt;/strong&gt;</ept>.</source>
            <target state="new">You can achieve near-infinite scale in terms of storage and throughput for your DocumentDB application by horizontally partitioning your data - a concept commonly referred to as <bpt id="2">&lt;strong&gt;</bpt>sharding<ept id="2">&lt;/strong&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="107" xml:space="preserve">
            <source>DocumentDB accounts can be scaled linearly with cost via stackable units a.k.a.</source>
            <target state="new">DocumentDB accounts can be scaled linearly with cost via stackable units a.k.a.</target>
          </trans-unit>
          <trans-unit id="108" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>collections<ept id="1">&lt;/strong&gt;</ept>.</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>collections<ept id="1">&lt;/strong&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="109" xml:space="preserve">
            <source>How you best partition your data across collections will depend on your data format and access patterns.</source>
            <target state="new">How you best partition your data across collections will depend on your data format and access patterns.</target>
          </trans-unit>
          <trans-unit id="110" xml:space="preserve">
            <source>After reading this article you will be able to answer the following questions:</source>
            <target state="new">After reading this article you will be able to answer the following questions:</target>
          </trans-unit>
          <trans-unit id="111" xml:space="preserve">
            <source>What is hash, range and lookup partitioning?</source>
            <target state="new">What is hash, range and lookup partitioning?</target>
          </trans-unit>
          <trans-unit id="112" xml:space="preserve">
            <source>When would you use each partitioning technique and why?</source>
            <target state="new">When would you use each partitioning technique and why?</target>
          </trans-unit>
          <trans-unit id="113" xml:space="preserve">
            <source>How do you go about building a partitioned application on Azure DocumentDB?</source>
            <target state="new">How do you go about building a partitioned application on Azure DocumentDB?</target>
          </trans-unit>
          <trans-unit id="114" xml:space="preserve">
            <source>This article presents some concepts about sharding.</source>
            <target state="new">This article presents some concepts about sharding.</target>
          </trans-unit>
          <trans-unit id="115" xml:space="preserve">
            <source>If you're ready to write code that partitions data using the DocumentDB .NET SDK, take a look at <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Partitioning data with the DocumentDB .NET SDK<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</source>
            <target state="new">If you're ready to write code that partitions data using the DocumentDB .NET SDK, take a look at <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Partitioning data with the DocumentDB .NET SDK<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="116" xml:space="preserve">
            <source>Collections = Partitions</source>
            <target state="new">Collections = Partitions</target>
          </trans-unit>
          <trans-unit id="117" xml:space="preserve">
            <source>Before we dive deeper on data partitioning techniques, it is important to understand what a collection is and what it isn't.</source>
            <target state="new">Before we dive deeper on data partitioning techniques, it is important to understand what a collection is and what it isn't.</target>
          </trans-unit>
          <trans-unit id="118" xml:space="preserve">
            <source>As you may already know, a collection is a container for your JSON documents.</source>
            <target state="new">As you may already know, a collection is a container for your JSON documents.</target>
          </trans-unit>
          <trans-unit id="119" xml:space="preserve">
            <source>Collections in DocumentDB are not just <bpt id="2">&lt;em&gt;</bpt>logical<ept id="2">&lt;/em&gt;</ept> containers, but also <bpt id="4">&lt;em&gt;</bpt>physical<ept id="4">&lt;/em&gt;</ept> containers.</source>
            <target state="new">Collections in DocumentDB are not just <bpt id="2">&lt;em&gt;</bpt>logical<ept id="2">&lt;/em&gt;</ept> containers, but also <bpt id="4">&lt;em&gt;</bpt>physical<ept id="4">&lt;/em&gt;</ept> containers.</target>
          </trans-unit>
          <trans-unit id="120" xml:space="preserve">
            <source>They are the transaction boundary for stored procedures and triggers, and the entry point to queries and CRUD operations.</source>
            <target state="new">They are the transaction boundary for stored procedures and triggers, and the entry point to queries and CRUD operations.</target>
          </trans-unit>
          <trans-unit id="121" xml:space="preserve">
            <source>Each collection is assigned a reserved amount of throughput which is not shared with other collections in the same account.</source>
            <target state="new">Each collection is assigned a reserved amount of throughput which is not shared with other collections in the same account.</target>
          </trans-unit>
          <trans-unit id="122" xml:space="preserve">
            <source>Therefore you can scale out your application both in terms of storage and throughput by adding more collections, and then distributing your documents across them.</source>
            <target state="new">Therefore you can scale out your application both in terms of storage and throughput by adding more collections, and then distributing your documents across them.</target>
          </trans-unit>
          <trans-unit id="123" xml:space="preserve">
            <source>Collections are not the same as tables in relational databases.</source>
            <target state="new">Collections are not the same as tables in relational databases.</target>
          </trans-unit>
          <trans-unit id="124" xml:space="preserve">
            <source>Collections do not enforce schema.</source>
            <target state="new">Collections do not enforce schema.</target>
          </trans-unit>
          <trans-unit id="125" xml:space="preserve">
            <source>Therefore you can store different types of documents with diverse schemas in the same collection.</source>
            <target state="new">Therefore you can store different types of documents with diverse schemas in the same collection.</target>
          </trans-unit>
          <trans-unit id="126" xml:space="preserve">
            <source>You can however choose to use collections to store objects of a single type like you would with tables.</source>
            <target state="new">You can however choose to use collections to store objects of a single type like you would with tables.</target>
          </trans-unit>
          <trans-unit id="127" xml:space="preserve">
            <source>The best model depends only on how the data appears together in queries and transactions.</source>
            <target state="new">The best model depends only on how the data appears together in queries and transactions.</target>
          </trans-unit>
          <trans-unit id="128" xml:space="preserve">
            <source>Partitioning with DocumentDB</source>
            <target state="new">Partitioning with DocumentDB</target>
          </trans-unit>
          <trans-unit id="129" xml:space="preserve">
            <source>The most common techniques used for partitioning data with Azure DocumentDB are <bpt id="2">&lt;em&gt;</bpt>range partitioning<ept id="2">&lt;/em&gt;</ept>, <bpt id="4">&lt;em&gt;</bpt>lookup partitioning<ept id="4">&lt;/em&gt;</ept>, and <bpt id="6">&lt;em&gt;</bpt>hash partitioning<ept id="6">&lt;/em&gt;</ept>.</source>
            <target state="new">The most common techniques used for partitioning data with Azure DocumentDB are <bpt id="2">&lt;em&gt;</bpt>range partitioning<ept id="2">&lt;/em&gt;</ept>, <bpt id="4">&lt;em&gt;</bpt>lookup partitioning<ept id="4">&lt;/em&gt;</ept>, and <bpt id="6">&lt;em&gt;</bpt>hash partitioning<ept id="6">&lt;/em&gt;</ept>.</target>
          </trans-unit>
          <trans-unit id="130" xml:space="preserve">
            <source>Usually you designate a single JSON property name within your document as your partition key like "timestamp" or "userID".</source>
            <target state="new">Usually you designate a single JSON property name within your document as your partition key like "timestamp" or "userID".</target>
          </trans-unit>
          <trans-unit id="131" xml:space="preserve">
            <source>In some cases, this might instead be an inner JSON property, or a different property name for each distinct type of document.</source>
            <target state="new">In some cases, this might instead be an inner JSON property, or a different property name for each distinct type of document.</target>
          </trans-unit>
          <trans-unit id="132" xml:space="preserve">
            <source>Let's take a look at these techniques in some more detail.</source>
            <target state="new">Let's take a look at these techniques in some more detail.</target>
          </trans-unit>
          <trans-unit id="133" xml:space="preserve">
            <source>Range partitioning</source>
            <target state="new">Range partitioning</target>
          </trans-unit>
          <trans-unit id="134" xml:space="preserve">
            <source>In range partitioning, partitions are assigned based on whether the partition key is within a certain range.</source>
            <target state="new">In range partitioning, partitions are assigned based on whether the partition key is within a certain range.</target>
          </trans-unit>
          <trans-unit id="135" xml:space="preserve">
            <source>This is commonly used for partitioning with <bpt id="2">&lt;em&gt;</bpt>time stamp<ept id="2">&lt;/em&gt;</ept> properties (e.g., eventTime between Feb 1, 2015 and Feb 2, 2015).</source>
            <target state="new">This is commonly used for partitioning with <bpt id="2">&lt;em&gt;</bpt>time stamp<ept id="2">&lt;/em&gt;</ept> properties (e.g., eventTime between Feb 1, 2015 and Feb 2, 2015).</target>
          </trans-unit>
          <trans-unit id="136" xml:space="preserve">
            <source>You should use Range partitioning if your queries are restricted to specifc range values against the partition key.</source>
            <target state="new">You should use Range partitioning if your queries are restricted to specifc range values against the partition key.</target>
          </trans-unit>
          <trans-unit id="137" xml:space="preserve">
            <source>Lookup partitioning</source>
            <target state="new">Lookup partitioning</target>
          </trans-unit>
          <trans-unit id="138" xml:space="preserve">
            <source>In lookup partitioning, partitions are assigned based on a lookup map that assigns discrete partition values to specific partitions a.k.a.</source>
            <target state="new">In lookup partitioning, partitions are assigned based on a lookup map that assigns discrete partition values to specific partitions a.k.a.</target>
          </trans-unit>
          <trans-unit id="139" xml:space="preserve">
            <source>a partition or shard map.</source>
            <target state="new">a partition or shard map.</target>
          </trans-unit>
          <trans-unit id="140" xml:space="preserve">
            <source>This is commonly used for partitioning by region (e.g. the partition for Scandinavia contains Norway, Denmark, and Sweden).</source>
            <target state="new">This is commonly used for partitioning by region (e.g. the partition for Scandinavia contains Norway, Denmark, and Sweden).</target>
          </trans-unit>
          <trans-unit id="141" xml:space="preserve">
            <source>Lookup partitioning offers the highest degree of control in managing a multi-tenant application.</source>
            <target state="new">Lookup partitioning offers the highest degree of control in managing a multi-tenant application.</target>
          </trans-unit>
          <trans-unit id="142" xml:space="preserve">
            <source>You can assign multiple tenants to a single collection, single tenant to a single collection, or even a single tenant across multiple collections.</source>
            <target state="new">You can assign multiple tenants to a single collection, single tenant to a single collection, or even a single tenant across multiple collections.</target>
          </trans-unit>
          <trans-unit id="143" xml:space="preserve">
            <source>Hash partitioning</source>
            <target state="new">Hash partitioning</target>
          </trans-unit>
          <trans-unit id="144" xml:space="preserve">
            <source>In hash partitioning, partitions are assigned based on the value of a hash function, allowing you to evenly distribute requests and data across a number of partitions.</source>
            <target state="new">In hash partitioning, partitions are assigned based on the value of a hash function, allowing you to evenly distribute requests and data across a number of partitions.</target>
          </trans-unit>
          <trans-unit id="145" xml:space="preserve">
            <source>This is commonly used to partition data produced or consumed from a large number of distinct clients, and is useful for storing user profiles, catalog items, and IoT ("Internet of Things") telemetry data.</source>
            <target state="new">This is commonly used to partition data produced or consumed from a large number of distinct clients, and is useful for storing user profiles, catalog items, and IoT ("Internet of Things") telemetry data.</target>
          </trans-unit>
          <trans-unit id="146" xml:space="preserve">
            <source>You should use hash partitioning whenever there are too many entities to enumerate through lookup partitioning (e.g. users or devices) and the request rate is fairly uniform across entities.</source>
            <target state="new">You should use hash partitioning whenever there are too many entities to enumerate through lookup partitioning (e.g. users or devices) and the request rate is fairly uniform across entities.</target>
          </trans-unit>
          <trans-unit id="147" xml:space="preserve">
            <source>Choosing the right partitioning technique</source>
            <target state="new">Choosing the right partitioning technique</target>
          </trans-unit>
          <trans-unit id="148" xml:space="preserve">
            <source>So which partitioning technique is right for you?</source>
            <target state="new">So which partitioning technique is right for you?</target>
          </trans-unit>
          <trans-unit id="149" xml:space="preserve">
            <source>It depends on the type of data and your common access patterns.</source>
            <target state="new">It depends on the type of data and your common access patterns.</target>
          </trans-unit>
          <trans-unit id="150" xml:space="preserve">
            <source>Picking the right partitioning technique at design time allows you to avoid technical debt, and handle growth in data size and request volumes.</source>
            <target state="new">Picking the right partitioning technique at design time allows you to avoid technical debt, and handle growth in data size and request volumes.</target>
          </trans-unit>
          <trans-unit id="151" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>Range partitioning<ept id="1">&lt;/strong&gt;</ept> is generally used in the context of dates, as it gives you an easy and natural mechanism for aging out partitions by timestamp.</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>Range partitioning<ept id="1">&lt;/strong&gt;</ept> is generally used in the context of dates, as it gives you an easy and natural mechanism for aging out partitions by timestamp.</target>
          </trans-unit>
          <trans-unit id="152" xml:space="preserve">
            <source>It is also useful when queries are generally constrained to a time range since that is aligned with the partitioning boundaries.</source>
            <target state="new">It is also useful when queries are generally constrained to a time range since that is aligned with the partitioning boundaries.</target>
          </trans-unit>
          <trans-unit id="153" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>Lookup partitioning<ept id="1">&lt;/strong&gt;</ept> allows you to group and organize unordered and unrelated sets of data in a natural way e.g., group tenants by organization or states by geographic region.</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>Lookup partitioning<ept id="1">&lt;/strong&gt;</ept> allows you to group and organize unordered and unrelated sets of data in a natural way e.g., group tenants by organization or states by geographic region.</target>
          </trans-unit>
          <trans-unit id="154" xml:space="preserve">
            <source>Lookup also offers fine-grained control for migrating data between collections.</source>
            <target state="new">Lookup also offers fine-grained control for migrating data between collections.</target>
          </trans-unit>
          <trans-unit id="155" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>Hash partitioning<ept id="1">&lt;/strong&gt;</ept> is useful for uniform load balancing of requests to make effective use of your provisioned storage and throughput.</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>Hash partitioning<ept id="1">&lt;/strong&gt;</ept> is useful for uniform load balancing of requests to make effective use of your provisioned storage and throughput.</target>
          </trans-unit>
          <trans-unit id="156" xml:space="preserve">
            <source>Using <bpt id="2">&lt;em&gt;</bpt>consistent hashing<ept id="2">&lt;/em&gt;</ept> algorithms allow you to minimize the amount of data that has to be moved when adding or removing a partition.</source>
            <target state="new">Using <bpt id="2">&lt;em&gt;</bpt>consistent hashing<ept id="2">&lt;/em&gt;</ept> algorithms allow you to minimize the amount of data that has to be moved when adding or removing a partition.</target>
          </trans-unit>
          <trans-unit id="157" xml:space="preserve">
            <source>You don't have to choose just one partitioning technique.</source>
            <target state="new">You don't have to choose just one partitioning technique.</target>
          </trans-unit>
          <trans-unit id="158" xml:space="preserve">
            <source>A <bpt id="2">&lt;em&gt;</bpt>composite<ept id="2">&lt;/em&gt;</ept> of these techniques can also be useful depending on the scenario.</source>
            <target state="new">A <bpt id="2">&lt;em&gt;</bpt>composite<ept id="2">&lt;/em&gt;</ept> of these techniques can also be useful depending on the scenario.</target>
          </trans-unit>
          <trans-unit id="159" xml:space="preserve">
            <source>For example, if you're storing vehicle telemetry data, a good approach would be to partition device telemetry data by range on timestamp for easy manageability of partitions, then sub-partition on VIN (vehicle identification number) in order to scale-out for throughput (range-hash composite partitioning).</source>
            <target state="new">For example, if you're storing vehicle telemetry data, a good approach would be to partition device telemetry data by range on timestamp for easy manageability of partitions, then sub-partition on VIN (vehicle identification number) in order to scale-out for throughput (range-hash composite partitioning).</target>
          </trans-unit>
          <trans-unit id="160" xml:space="preserve">
            <source>Developing a partitioned application</source>
            <target state="new">Developing a partitioned application</target>
          </trans-unit>
          <trans-unit id="161" xml:space="preserve">
            <source>There are three key design areas to look at when developing a partitioned application on DocumentDB.</source>
            <target state="new">There are three key design areas to look at when developing a partitioned application on DocumentDB.</target>
          </trans-unit>
          <trans-unit id="162" xml:space="preserve">
            <source>How you route your creates and reads (including queries) to the right collections.</source>
            <target state="new">How you route your creates and reads (including queries) to the right collections.</target>
          </trans-unit>
          <trans-unit id="163" xml:space="preserve">
            <source>How you persist and retrieve your partition resolution configuration, a.k.a.</source>
            <target state="new">How you persist and retrieve your partition resolution configuration, a.k.a.</target>
          </trans-unit>
          <trans-unit id="164" xml:space="preserve">
            <source>partition maps.</source>
            <target state="new">partition maps.</target>
          </trans-unit>
          <trans-unit id="165" xml:space="preserve">
            <source>How you add/remove partitions as your data and request volume increases.</source>
            <target state="new">How you add/remove partitions as your data and request volume increases.</target>
          </trans-unit>
          <trans-unit id="166" xml:space="preserve">
            <source>Let's take a closer look at each of these areas.</source>
            <target state="new">Let's take a closer look at each of these areas.</target>
          </trans-unit>
          <trans-unit id="167" xml:space="preserve">
            <source>Routing creates and queries</source>
            <target state="new">Routing creates and queries</target>
          </trans-unit>
          <trans-unit id="168" xml:space="preserve">
            <source>Routing document creation requests is straight-forward for all three techniques we've discussed so far.</source>
            <target state="new">Routing document creation requests is straight-forward for all three techniques we've discussed so far.</target>
          </trans-unit>
          <trans-unit id="169" xml:space="preserve">
            <source>The document is created on the partition from the hash, lookup, or range value corresponding to the partition key.</source>
            <target state="new">The document is created on the partition from the hash, lookup, or range value corresponding to the partition key.</target>
          </trans-unit>
          <trans-unit id="170" xml:space="preserve">
            <source>Queries and reads should typically be scoped to a single partition key, so queries can be fanned out to only the matching partitions.</source>
            <target state="new">Queries and reads should typically be scoped to a single partition key, so queries can be fanned out to only the matching partitions.</target>
          </trans-unit>
          <trans-unit id="171" xml:space="preserve">
            <source>Queries across all data however, would require you to <bpt id="2">&lt;em&gt;</bpt>fan-out<ept id="2">&lt;/em&gt;</ept> the request across multiple partitions, then merge the results.</source>
            <target state="new">Queries across all data however, would require you to <bpt id="2">&lt;em&gt;</bpt>fan-out<ept id="2">&lt;/em&gt;</ept> the request across multiple partitions, then merge the results.</target>
          </trans-unit>
          <trans-unit id="172" xml:space="preserve">
            <source>Keep in mind that some queries might have to perform custom logic to merge results for e.g. when fetching the top N results.</source>
            <target state="new">Keep in mind that some queries might have to perform custom logic to merge results for e.g. when fetching the top N results.</target>
          </trans-unit>
          <trans-unit id="173" xml:space="preserve">
            <source>Managing your partition map</source>
            <target state="new">Managing your partition map</target>
          </trans-unit>
          <trans-unit id="174" xml:space="preserve">
            <source>You also need to decide how you will store your partition map, how your clients load it and receive updates when it changes, and how it is shared across multiple clients.</source>
            <target state="new">You also need to decide how you will store your partition map, how your clients load it and receive updates when it changes, and how it is shared across multiple clients.</target>
          </trans-unit>
          <trans-unit id="175" xml:space="preserve">
            <source>If the partition map does not change often, you can simply save it in your application config file.</source>
            <target state="new">If the partition map does not change often, you can simply save it in your application config file.</target>
          </trans-unit>
          <trans-unit id="176" xml:space="preserve">
            <source>If not, you can store it in any persistent store.</source>
            <target state="new">If not, you can store it in any persistent store.</target>
          </trans-unit>
          <trans-unit id="177" xml:space="preserve">
            <source>A common design pattern we've seen in production is to serialize partition maps as JSON, and store them within DocumentDB collections as well.</source>
            <target state="new">A common design pattern we've seen in production is to serialize partition maps as JSON, and store them within DocumentDB collections as well.</target>
          </trans-unit>
          <trans-unit id="178" xml:space="preserve">
            <source>Clients can then cache the map in order to avoid the extra round trips, and then poll for changes periodically.</source>
            <target state="new">Clients can then cache the map in order to avoid the extra round trips, and then poll for changes periodically.</target>
          </trans-unit>
          <trans-unit id="179" xml:space="preserve">
            <source>If your clients might modify the shard map, ensure that they use a consistent naming schema and use optimistic concurrency (eTags) to allow consistent updates to the partition map.</source>
            <target state="new">If your clients might modify the shard map, ensure that they use a consistent naming schema and use optimistic concurrency (eTags) to allow consistent updates to the partition map.</target>
          </trans-unit>
          <trans-unit id="180" xml:space="preserve">
            <source>Adding and removing partitions</source>
            <target state="new">Adding and removing partitions</target>
          </trans-unit>
          <trans-unit id="181" xml:space="preserve">
            <source>With DocumentDB, you can add and remove collections at any time and use them to store new incoming data or re-balance data available on existing collections.</source>
            <target state="new">With DocumentDB, you can add and remove collections at any time and use them to store new incoming data or re-balance data available on existing collections.</target>
          </trans-unit>
          <trans-unit id="182" xml:space="preserve">
            <source>Review the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Limits<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> page for the number of collections.</source>
            <target state="new">Review the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Limits<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> page for the number of collections.</target>
          </trans-unit>
          <trans-unit id="183" xml:space="preserve">
            <source>You can always call us to increase these limits.</source>
            <target state="new">You can always call us to increase these limits.</target>
          </trans-unit>
          <trans-unit id="184" xml:space="preserve">
            <source>Adding and removing a new partition with lookup and range partitioning is straightforward.</source>
            <target state="new">Adding and removing a new partition with lookup and range partitioning is straightforward.</target>
          </trans-unit>
          <trans-unit id="185" xml:space="preserve">
            <source>For example, adding a new geographic region or new time range for recent data, you just need to append the new partitions to the partition map.</source>
            <target state="new">For example, adding a new geographic region or new time range for recent data, you just need to append the new partitions to the partition map.</target>
          </trans-unit>
          <trans-unit id="186" xml:space="preserve">
            <source>Splitting an existing partition into multiple partitions, or merge two partitions requires a little more effort.</source>
            <target state="new">Splitting an existing partition into multiple partitions, or merge two partitions requires a little more effort.</target>
          </trans-unit>
          <trans-unit id="187" xml:space="preserve">
            <source>You need to either</source>
            <target state="new">You need to either</target>
          </trans-unit>
          <trans-unit id="188" xml:space="preserve">
            <source>Take the shard offline for reads.</source>
            <target state="new">Take the shard offline for reads.</target>
          </trans-unit>
          <trans-unit id="189" xml:space="preserve">
            <source>Route reads to both the partitions using the old partitioning configuration as well as the new partitioning configuration during migration.</source>
            <target state="new">Route reads to both the partitions using the old partitioning configuration as well as the new partitioning configuration during migration.</target>
          </trans-unit>
          <trans-unit id="190" xml:space="preserve">
            <source>Note that transactions and consistency level guarantees will not be available until migration is complete.</source>
            <target state="new">Note that transactions and consistency level guarantees will not be available until migration is complete.</target>
          </trans-unit>
          <trans-unit id="191" xml:space="preserve">
            <source>Hashing is relatively more complicated for adding and removing partitions.</source>
            <target state="new">Hashing is relatively more complicated for adding and removing partitions.</target>
          </trans-unit>
          <trans-unit id="192" xml:space="preserve">
            <source>Simple hashing techniques will cause shuffling, and require most of the data to get moved around.</source>
            <target state="new">Simple hashing techniques will cause shuffling, and require most of the data to get moved around.</target>
          </trans-unit>
          <trans-unit id="193" xml:space="preserve">
            <source>Using <bpt id="2">&lt;strong&gt;</bpt>consistent hashing<ept id="2">&lt;/strong&gt;</ept> ensures that only a fraction of data needs to get moved.</source>
            <target state="new">Using <bpt id="2">&lt;strong&gt;</bpt>consistent hashing<ept id="2">&lt;/strong&gt;</ept> ensures that only a fraction of data needs to get moved.</target>
          </trans-unit>
          <trans-unit id="194" xml:space="preserve">
            <source>A relatively easy way to add new partitions without requiring data movement is to  "spill over" your data to a fresh collection, and then fan-out requests across both the old and new collections.</source>
            <target state="new">A relatively easy way to add new partitions without requiring data movement is to  "spill over" your data to a fresh collection, and then fan-out requests across both the old and new collections.</target>
          </trans-unit>
          <trans-unit id="195" xml:space="preserve">
            <source>This approach, however, should be used only in rare situations (e.g. spill over in peak time workloads and to hold data temporarily until it can be moved).</source>
            <target state="new">This approach, however, should be used only in rare situations (e.g. spill over in peak time workloads and to hold data temporarily until it can be moved).</target>
          </trans-unit>
          <trans-unit id="196" xml:space="preserve">
            <source>Next Steps</source>
            <target state="new">Next Steps</target>
          </trans-unit>
          <trans-unit id="197" xml:space="preserve">
            <source>In this article, we've introduced some common techniques on how you can partition data with DocumentDB, and when to use which technique or combination of techniques.</source>
            <target state="new">In this article, we've introduced some common techniques on how you can partition data with DocumentDB, and when to use which technique or combination of techniques.</target>
          </trans-unit>
          <trans-unit id="198" xml:space="preserve">
            <source>Next, take a look at this <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>article<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> on how you can partition data using partition resolvers with the DocumentDB SDK.</source>
            <target state="new">Next, take a look at this <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>article<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> on how you can partition data using partition resolvers with the DocumentDB SDK.</target>
          </trans-unit>
          <trans-unit id="199" xml:space="preserve">
            <source>Download one of the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>supported SDKs<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept></source>
            <target state="new">Download one of the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>supported SDKs<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept></target>
          </trans-unit>
          <trans-unit id="200" xml:space="preserve">
            <source>Contact us through the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>MSDN support forums<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> if you have questions.</source>
            <target state="new">Contact us through the <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>MSDN support forums<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> if you have questions.</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>