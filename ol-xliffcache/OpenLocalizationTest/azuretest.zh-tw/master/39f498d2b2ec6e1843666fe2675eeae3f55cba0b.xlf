<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-tw" original="2/20/2016 1:15:37 PM" tool-id="MarkdownTransformer" product-name="N/A" product-version="N/A" build-num="1">
    <header>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">39f498d2b2ec6e1843666fe2675eeae3f55cba0b</xliffext:olfilehash>
      <tool tool-id="MarkdownTransformer" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
    </header>
    <body>
      <group extype="content">
        <group id="101">
          <trans-unit id="101" xml:space="preserve">
            <source>Specifying structure definition for rectangular datasets</source>
            <target state="new">Specifying structure definition for rectangular datasets</target>
          </trans-unit>
          <trans-unit id="102" xml:space="preserve">
            <source>The structure section in the datasets JSON is an <bpt id="2">&lt;strong&gt;</bpt>optional<ept id="2">&lt;/strong&gt;</ept> section for rectangular tables (with rows &amp; columns) and contains a collection of columns for the table. You will use the structure section for either providing type information for type conversions or doing column mappings. The following sections describe these features in detail.</source>
            <target state="new">The structure section in the datasets JSON is an <bpt id="2">&lt;strong&gt;</bpt>optional<ept id="2">&lt;/strong&gt;</ept> section for rectangular tables (with rows &amp; columns) and contains a collection of columns for the table. You will use the structure section for either providing type information for type conversions or doing column mappings. The following sections describe these features in detail.</target>
          </trans-unit>
          <trans-unit id="103" xml:space="preserve">
            <source>Each column contains the following properties:</source>
            <target state="new">Each column contains the following properties:</target>
          </trans-unit>
          <trans-unit id="104" xml:space="preserve">
            <source>Property</source>
            <target state="new">Property</target>
          </trans-unit>
          <trans-unit id="105" xml:space="preserve">
            <source>Description</source>
            <target state="new">Description</target>
          </trans-unit>
          <trans-unit id="106" xml:space="preserve">
            <source>Required</source>
            <target state="new">Required</target>
          </trans-unit>
          <trans-unit id="107" xml:space="preserve">
            <source>name</source>
            <target state="new">name</target>
          </trans-unit>
          <trans-unit id="108" xml:space="preserve">
            <source>Name of the column.</source>
            <target state="new">Name of the column.</target>
          </trans-unit>
          <trans-unit id="109" xml:space="preserve">
            <source>Yes</source>
            <target state="new">Yes</target>
          </trans-unit>
          <trans-unit id="110" xml:space="preserve">
            <source>type</source>
            <target state="new">type</target>
          </trans-unit>
          <trans-unit id="111" xml:space="preserve">
            <source>Data type of the column.</source>
            <target state="new">Data type of the column.</target>
          </trans-unit>
          <trans-unit id="112" xml:space="preserve">
            <source>See type conversions section below for more details regarding when should you specify type information</source>
            <target state="new">See type conversions section below for more details regarding when should you specify type information</target>
          </trans-unit>
          <trans-unit id="113" xml:space="preserve">
            <source>No</source>
            <target state="new">No</target>
          </trans-unit>
          <trans-unit id="114" xml:space="preserve">
            <source>culture</source>
            <target state="new">culture</target>
          </trans-unit>
          <trans-unit id="115" xml:space="preserve">
            <source>.NET based culture to be used when type is specified and is .NET type Datetime or Datetimeoffset.</source>
            <target state="new">.NET based culture to be used when type is specified and is .NET type Datetime or Datetimeoffset.</target>
          </trans-unit>
          <trans-unit id="116" xml:space="preserve">
            <source>Default is “en-us”.</source>
            <target state="new">Default is “en-us”.</target>
          </trans-unit>
          <trans-unit id="117" xml:space="preserve">
            <source>No</source>
            <target state="new">No</target>
          </trans-unit>
          <trans-unit id="118" xml:space="preserve">
            <source>format</source>
            <target state="new">format</target>
          </trans-unit>
          <trans-unit id="119" xml:space="preserve">
            <source>Format string to be used when type is specified and is .NET type Datetime or Datetimeoffset.</source>
            <target state="new">Format string to be used when type is specified and is .NET type Datetime or Datetimeoffset.</target>
          </trans-unit>
          <trans-unit id="120" xml:space="preserve">
            <source>No</source>
            <target state="new">No</target>
          </trans-unit>
          <trans-unit id="121" xml:space="preserve">
            <source>The following sample shows the structure section JSON for a table that has three columns userid, name, and lastlogindate.</source>
            <target state="new">The following sample shows the structure section JSON for a table that has three columns userid, name, and lastlogindate.</target>
          </trans-unit>
          <trans-unit id="122" xml:space="preserve">
            <source>Please use the following guidelines for when to include “structure” information and what to include in the <bpt id="2">&lt;strong&gt;</bpt>structure<ept id="2">&lt;/strong&gt;</ept> section.</source>
            <target state="new">Please use the following guidelines for when to include “structure” information and what to include in the <bpt id="2">&lt;strong&gt;</bpt>structure<ept id="2">&lt;/strong&gt;</ept> section.</target>
          </trans-unit>
          <trans-unit id="123" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>For structured data sources<ept id="1">&lt;/strong&gt;</ept> that store data schema and type information along with the data itself (sources like SQL Server, Oracle, Azure table etc.), you should specify the “structure” section only if you want do column mapping of specific source columns to specific columns in sink and their names are not the same (see details in column mapping section below).</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>For structured data sources<ept id="1">&lt;/strong&gt;</ept> that store data schema and type information along with the data itself (sources like SQL Server, Oracle, Azure table etc.), you should specify the “structure” section only if you want do column mapping of specific source columns to specific columns in sink and their names are not the same (see details in column mapping section below).</target>
          </trans-unit>
          <trans-unit id="124" xml:space="preserve">
            <source>As mentioned above, the type information is optional in “structure” section.</source>
            <target state="new">As mentioned above, the type information is optional in “structure” section.</target>
          </trans-unit>
          <trans-unit id="125" xml:space="preserve">
            <source>For structured sources, type information is already available as part of dataset definition in the data store, so you should not include type information when you do include the “structure” section.</source>
            <target state="new">For structured sources, type information is already available as part of dataset definition in the data store, so you should not include type information when you do include the “structure” section.</target>
          </trans-unit>
          <trans-unit id="126" xml:space="preserve">
            <source><bpt id="1">&lt;strong&gt;</bpt>For schema on read data sources (specifically Azure blob)<ept id="1">&lt;/strong&gt;</ept>  you can chose to store data without storing any schema or type information with the data.</source>
            <target state="new"><bpt id="1">&lt;strong&gt;</bpt>For schema on read data sources (specifically Azure blob)<ept id="1">&lt;/strong&gt;</ept>  you can chose to store data without storing any schema or type information with the data.</target>
          </trans-unit>
          <trans-unit id="127" xml:space="preserve">
            <source>For these types of data sources you should include “structure” in the following 2 cases:</source>
            <target state="new">For these types of data sources you should include “structure” in the following 2 cases:</target>
          </trans-unit>
          <trans-unit id="128" xml:space="preserve">
            <source>You want to do column mapping.</source>
            <target state="new">You want to do column mapping.</target>
          </trans-unit>
          <trans-unit id="129" xml:space="preserve">
            <source>When the dataset is a source in a Copy activity, you can provide type information in “structure” and data factory will use this type information for conversion to native types for the sink.</source>
            <target state="new">When the dataset is a source in a Copy activity, you can provide type information in “structure” and data factory will use this type information for conversion to native types for the sink.</target>
          </trans-unit>
          <trans-unit id="130" xml:space="preserve">
            <source>See <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Move data to and from Azure Blob<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> article for more information.</source>
            <target state="new">See <bpt id="2CapsExtId1">&lt;link&gt;</bpt><bpt id="2CapsExtId2">&lt;linkText&gt;</bpt>Move data to and from Azure Blob<ept id="2CapsExtId2">&lt;/linkText&gt;</ept><bpt id="2CapsExtId3">&lt;title&gt;</bpt><ept id="2CapsExtId3">&lt;/title&gt;</ept><ept id="2CapsExtId1">&lt;/link&gt;</ept> article for more information.</target>
          </trans-unit>
          <trans-unit id="131" xml:space="preserve">
            <source>Supported .NET-based types</source>
            <target state="new">Supported .NET-based types</target>
          </trans-unit>
          <trans-unit id="132" xml:space="preserve">
            <source>Data factory supports the following CLS compliant .NET based type values for providing type information in “structure” for schema on read data sources like Azure blob.</source>
            <target state="new">Data factory supports the following CLS compliant .NET based type values for providing type information in “structure” for schema on read data sources like Azure blob.</target>
          </trans-unit>
          <trans-unit id="133" xml:space="preserve">
            <source>Int16</source>
            <target state="new">Int16</target>
          </trans-unit>
          <trans-unit id="134" xml:space="preserve">
            <source>Int32</source>
            <target state="new">Int32</target>
          </trans-unit>
          <trans-unit id="135" xml:space="preserve">
            <source>Int64</source>
            <target state="new">Int64</target>
          </trans-unit>
          <trans-unit id="136" xml:space="preserve">
            <source>Single</source>
            <target state="new">Single</target>
          </trans-unit>
          <trans-unit id="137" xml:space="preserve">
            <source>Double</source>
            <target state="new">Double</target>
          </trans-unit>
          <trans-unit id="138" xml:space="preserve">
            <source>Decimal</source>
            <target state="new">Decimal</target>
          </trans-unit>
          <trans-unit id="139" xml:space="preserve">
            <source>Byte[]</source>
            <target state="new">Byte[]</target>
          </trans-unit>
          <trans-unit id="140" xml:space="preserve">
            <source>Bool</source>
            <target state="new">Bool</target>
          </trans-unit>
          <trans-unit id="141" xml:space="preserve">
            <source>String</source>
            <target state="new">String</target>
          </trans-unit>
          <trans-unit id="142" xml:space="preserve">
            <source>Guid</source>
            <target state="new">Guid</target>
          </trans-unit>
          <trans-unit id="143" xml:space="preserve">
            <source>Datetime</source>
            <target state="new">Datetime</target>
          </trans-unit>
          <trans-unit id="144" xml:space="preserve">
            <source>Datetimeoffset</source>
            <target state="new">Datetimeoffset</target>
          </trans-unit>
          <trans-unit id="145" xml:space="preserve">
            <source>Timespan</source>
            <target state="new">Timespan</target>
          </trans-unit>
          <trans-unit id="146" xml:space="preserve">
            <source>For Datetime &amp; Datetimeoffset you can also optionally specify “culture” &amp; “format” string to facilitate parsing of your custom Datetime string. See sample for type conversion below.</source>
            <target state="new">For Datetime &amp; Datetimeoffset you can also optionally specify “culture” &amp; “format” string to facilitate parsing of your custom Datetime string. See sample for type conversion below.</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>